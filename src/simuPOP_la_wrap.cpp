/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_NO_BUILD_NONE
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_IndividualPair swig_types[0]
#define SWIGTYPE_p_LocGenotype swig_types[1]
#define SWIGTYPE_p_SelCoef swig_types[2]
#define SWIGTYPE_p_allocator_type swig_types[3]
#define SWIGTYPE_p_bool swig_types[4]
#define SWIGTYPE_p_char swig_types[5]
#define SWIGTYPE_p_const_iterator swig_types[6]
#define SWIGTYPE_p_const_reference swig_types[7]
#define SWIGTYPE_p_difference_type swig_types[8]
#define SWIGTYPE_p_double swig_types[9]
#define SWIGTYPE_p_first_type swig_types[10]
#define SWIGTYPE_p_gsl_rng swig_types[11]
#define SWIGTYPE_p_int swig_types[12]
#define SWIGTYPE_p_iterator swig_types[13]
#define SWIGTYPE_p_key_type swig_types[14]
#define SWIGTYPE_p_long swig_types[15]
#define SWIGTYPE_p_long_long swig_types[16]
#define SWIGTYPE_p_mapped_type swig_types[17]
#define SWIGTYPE_p_ostream swig_types[18]
#define SWIGTYPE_p_reference swig_types[19]
#define SWIGTYPE_p_second_type swig_types[20]
#define SWIGTYPE_p_short swig_types[21]
#define SWIGTYPE_p_signed_char swig_types[22]
#define SWIGTYPE_p_simuPOP__AffectionSplitter swig_types[23]
#define SWIGTYPE_p_simuPOP__BackwardMigrator swig_types[24]
#define SWIGTYPE_p_simuPOP__BaseMutator swig_types[25]
#define SWIGTYPE_p_simuPOP__BaseOperator swig_types[26]
#define SWIGTYPE_p_simuPOP__BasePenetrance swig_types[27]
#define SWIGTYPE_p_simuPOP__BaseQuanTrait swig_types[28]
#define SWIGTYPE_p_simuPOP__BaseSelector swig_types[29]
#define SWIGTYPE_p_simuPOP__BaseVspSplitter swig_types[30]
#define SWIGTYPE_p_simuPOP__Bernullitrials swig_types[31]
#define SWIGTYPE_p_simuPOP__Bernullitrials_T swig_types[32]
#define SWIGTYPE_p_simuPOP__BinomialNumOffModel swig_types[33]
#define SWIGTYPE_p_simuPOP__CloneGenoTransmitter swig_types[34]
#define SWIGTYPE_p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t swig_types[35]
#define SWIGTYPE_p_simuPOP__CombinedParentsChooser swig_types[36]
#define SWIGTYPE_p_simuPOP__CombinedSplitter swig_types[37]
#define SWIGTYPE_p_simuPOP__ConditionalMating swig_types[38]
#define SWIGTYPE_p_simuPOP__ConstNumOffModel swig_types[39]
#define SWIGTYPE_p_simuPOP__ContextMutator swig_types[40]
#define SWIGTYPE_p_simuPOP__ControlledOffspringGenerator swig_types[41]
#define SWIGTYPE_p_simuPOP__DiscardIf swig_types[42]
#define SWIGTYPE_p_simuPOP__Dumper swig_types[43]
#define SWIGTYPE_p_simuPOP__Exception swig_types[44]
#define SWIGTYPE_p_simuPOP__FiniteSitesMutator swig_types[45]
#define SWIGTYPE_p_simuPOP__FuncNumOffModel swig_types[46]
#define SWIGTYPE_p_simuPOP__FuncSexModel swig_types[47]
#define SWIGTYPE_p_simuPOP__GenoStruTrait swig_types[48]
#define SWIGTYPE_p_simuPOP__GenoTransmitter swig_types[49]
#define SWIGTYPE_p_simuPOP__GenotypeSplitter swig_types[50]
#define SWIGTYPE_p_simuPOP__GeometricNumOffModel swig_types[51]
#define SWIGTYPE_p_simuPOP__GlobalSeqSexModel swig_types[52]
#define SWIGTYPE_p_simuPOP__HaplodiploidGenoTransmitter swig_types[53]
#define SWIGTYPE_p_simuPOP__HeteroMating swig_types[54]
#define SWIGTYPE_p_simuPOP__HomoMating swig_types[55]
#define SWIGTYPE_p_simuPOP__IdTagger swig_types[56]
#define SWIGTYPE_p_simuPOP__IfElse swig_types[57]
#define SWIGTYPE_p_simuPOP__IndexError swig_types[58]
#define SWIGTYPE_p_simuPOP__Individual swig_types[59]
#define SWIGTYPE_p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t swig_types[60]
#define SWIGTYPE_p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t swig_types[61]
#define SWIGTYPE_p_simuPOP__InfoEval swig_types[62]
#define SWIGTYPE_p_simuPOP__InfoExec swig_types[63]
#define SWIGTYPE_p_simuPOP__InfoSplitter swig_types[64]
#define SWIGTYPE_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t swig_types[65]
#define SWIGTYPE_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t swig_types[66]
#define SWIGTYPE_p_simuPOP__InheritTagger swig_types[67]
#define SWIGTYPE_p_simuPOP__InitGenotype swig_types[68]
#define SWIGTYPE_p_simuPOP__InitInfo swig_types[69]
#define SWIGTYPE_p_simuPOP__InitLineage swig_types[70]
#define SWIGTYPE_p_simuPOP__InitSex swig_types[71]
#define SWIGTYPE_p_simuPOP__KAlleleMutator swig_types[72]
#define SWIGTYPE_p_simuPOP__MaPenetrance swig_types[73]
#define SWIGTYPE_p_simuPOP__MaSelector swig_types[74]
#define SWIGTYPE_p_simuPOP__MapPenetrance swig_types[75]
#define SWIGTYPE_p_simuPOP__MapSelector swig_types[76]
#define SWIGTYPE_p_simuPOP__MatingScheme swig_types[77]
#define SWIGTYPE_p_simuPOP__MatrixMutator swig_types[78]
#define SWIGTYPE_p_simuPOP__MendelianGenoTransmitter swig_types[79]
#define SWIGTYPE_p_simuPOP__MergeSubPops swig_types[80]
#define SWIGTYPE_p_simuPOP__Migrator swig_types[81]
#define SWIGTYPE_p_simuPOP__MitochondrialGenoTransmitter swig_types[82]
#define SWIGTYPE_p_simuPOP__MixedMutator swig_types[83]
#define SWIGTYPE_p_simuPOP__MlPenetrance swig_types[84]
#define SWIGTYPE_p_simuPOP__MlSelector swig_types[85]
#define SWIGTYPE_p_simuPOP__MutSpaceMutator swig_types[86]
#define SWIGTYPE_p_simuPOP__MutSpaceRecombinator swig_types[87]
#define SWIGTYPE_p_simuPOP__MutSpaceRevertFixedSites swig_types[88]
#define SWIGTYPE_p_simuPOP__MutSpaceSelector swig_types[89]
#define SWIGTYPE_p_simuPOP__NoSexModel swig_types[90]
#define SWIGTYPE_p_simuPOP__NoneOp swig_types[91]
#define SWIGTYPE_p_simuPOP__NumOfFemalesSexModel swig_types[92]
#define SWIGTYPE_p_simuPOP__NumOfMalesSexModel swig_types[93]
#define SWIGTYPE_p_simuPOP__NumOffModel swig_types[94]
#define SWIGTYPE_p_simuPOP__OffspringGenerator swig_types[95]
#define SWIGTYPE_p_simuPOP__OffspringTagger swig_types[96]
#define SWIGTYPE_p_simuPOP__ParentChooser swig_types[97]
#define SWIGTYPE_p_simuPOP__ParentsTagger swig_types[98]
#define SWIGTYPE_p_simuPOP__Pause swig_types[99]
#define SWIGTYPE_p_simuPOP__Pedigree swig_types[100]
#define SWIGTYPE_p_simuPOP__PedigreeMating swig_types[101]
#define SWIGTYPE_p_simuPOP__PedigreeTagger swig_types[102]
#define SWIGTYPE_p_simuPOP__PointMutator swig_types[103]
#define SWIGTYPE_p_simuPOP__PoissonNumOffModel swig_types[104]
#define SWIGTYPE_p_simuPOP__PolyParentsChooser swig_types[105]
#define SWIGTYPE_p_simuPOP__Population swig_types[106]
#define SWIGTYPE_p_simuPOP__ProbOfMalesSexModel swig_types[107]
#define SWIGTYPE_p_simuPOP__ProductSplitter swig_types[108]
#define SWIGTYPE_p_simuPOP__ProportionSplitter swig_types[109]
#define SWIGTYPE_p_simuPOP__PyEval swig_types[110]
#define SWIGTYPE_p_simuPOP__PyExec swig_types[111]
#define SWIGTYPE_p_simuPOP__PyMlPenetrance swig_types[112]
#define SWIGTYPE_p_simuPOP__PyMlSelector swig_types[113]
#define SWIGTYPE_p_simuPOP__PyMutator swig_types[114]
#define SWIGTYPE_p_simuPOP__PyOperator swig_types[115]
#define SWIGTYPE_p_simuPOP__PyOutput swig_types[116]
#define SWIGTYPE_p_simuPOP__PyParentsChooser swig_types[117]
#define SWIGTYPE_p_simuPOP__PyPenetrance swig_types[118]
#define SWIGTYPE_p_simuPOP__PyQuanTrait swig_types[119]
#define SWIGTYPE_p_simuPOP__PySelector swig_types[120]
#define SWIGTYPE_p_simuPOP__PyTagger swig_types[121]
#define SWIGTYPE_p_simuPOP__RNG swig_types[122]
#define SWIGTYPE_p_simuPOP__RNG_func swig_types[123]
#define SWIGTYPE_p_simuPOP__RandomParentChooser swig_types[124]
#define SWIGTYPE_p_simuPOP__RandomParentsChooser swig_types[125]
#define SWIGTYPE_p_simuPOP__RandomSexModel swig_types[126]
#define SWIGTYPE_p_simuPOP__RangeSplitter swig_types[127]
#define SWIGTYPE_p_simuPOP__Recombinator swig_types[128]
#define SWIGTYPE_p_simuPOP__ResizeSubPops swig_types[129]
#define SWIGTYPE_p_simuPOP__RevertEvolution swig_types[130]
#define SWIGTYPE_p_simuPOP__RevertFixedSites swig_types[131]
#define SWIGTYPE_p_simuPOP__RevertIf swig_types[132]
#define SWIGTYPE_p_simuPOP__RuntimeError swig_types[133]
#define SWIGTYPE_p_simuPOP__SavePopulation swig_types[134]
#define SWIGTYPE_p_simuPOP__SelfingGenoTransmitter swig_types[135]
#define SWIGTYPE_p_simuPOP__SeqSexModel swig_types[136]
#define SWIGTYPE_p_simuPOP__SequentialParentChooser swig_types[137]
#define SWIGTYPE_p_simuPOP__SexModel swig_types[138]
#define SWIGTYPE_p_simuPOP__SexSplitter swig_types[139]
#define SWIGTYPE_p_simuPOP__Simulator swig_types[140]
#define SWIGTYPE_p_simuPOP__SplitSubPops swig_types[141]
#define SWIGTYPE_p_simuPOP__Stat swig_types[142]
#define SWIGTYPE_p_simuPOP__StepwiseMutator swig_types[143]
#define SWIGTYPE_p_simuPOP__StopEvolution swig_types[144]
#define SWIGTYPE_p_simuPOP__StopIteration swig_types[145]
#define SWIGTYPE_p_simuPOP__SummaryTagger swig_types[146]
#define SWIGTYPE_p_simuPOP__SystemError swig_types[147]
#define SWIGTYPE_p_simuPOP__TerminateIf swig_types[148]
#define SWIGTYPE_p_simuPOP__TicToc swig_types[149]
#define SWIGTYPE_p_simuPOP__UniformNumOffModel swig_types[150]
#define SWIGTYPE_p_simuPOP__ValueError swig_types[151]
#define SWIGTYPE_p_simuPOP__WeightedSampler swig_types[152]
#define SWIGTYPE_p_simuPOP__floatList swig_types[153]
#define SWIGTYPE_p_simuPOP__floatListFunc swig_types[154]
#define SWIGTYPE_p_simuPOP__floatMatrix swig_types[155]
#define SWIGTYPE_p_simuPOP__intList swig_types[156]
#define SWIGTYPE_p_simuPOP__intMatrix swig_types[157]
#define SWIGTYPE_p_simuPOP__lociList swig_types[158]
#define SWIGTYPE_p_simuPOP__opList swig_types[159]
#define SWIGTYPE_p_simuPOP__pyIndIterator swig_types[160]
#define SWIGTYPE_p_simuPOP__pyMutantIterator swig_types[161]
#define SWIGTYPE_p_simuPOP__pyPopIterator swig_types[162]
#define SWIGTYPE_p_simuPOP__stringFunc swig_types[163]
#define SWIGTYPE_p_simuPOP__stringList swig_types[164]
#define SWIGTYPE_p_simuPOP__stringMatrix swig_types[165]
#define SWIGTYPE_p_simuPOP__subPopList swig_types[166]
#define SWIGTYPE_p_simuPOP__uintList swig_types[167]
#define SWIGTYPE_p_simuPOP__uintListFunc swig_types[168]
#define SWIGTYPE_p_simuPOP__uintString swig_types[169]
#define SWIGTYPE_p_simuPOP__vspFunctor swig_types[170]
#define SWIGTYPE_p_simuPOP__vspID swig_types[171]
#define SWIGTYPE_p_size_t swig_types[172]
#define SWIGTYPE_p_size_type swig_types[173]
#define SWIGTYPE_p_std__invalid_argument swig_types[174]
#define SWIGTYPE_p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t swig_types[175]
#define SWIGTYPE_p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t swig_types[176]
#define SWIGTYPE_p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t swig_types[177]
#define SWIGTYPE_p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t swig_types[178]
#define SWIGTYPE_p_std__pairT_size_t_size_t_t swig_types[179]
#define SWIGTYPE_p_std__pairT_std__string_double_t swig_types[180]
#define SWIGTYPE_p_std__string swig_types[181]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t swig_types[182]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator swig_types[183]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t__iterator swig_types[184]
#define SWIGTYPE_p_std__vectorT_long_std__allocatorT_long_t_t swig_types[185]
#define SWIGTYPE_p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator swig_types[186]
#define SWIGTYPE_p_std__vectorT_long_std__allocatorT_long_t_t__iterator swig_types[187]
#define SWIGTYPE_p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t swig_types[188]
#define SWIGTYPE_p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t swig_types[189]
#define SWIGTYPE_p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t swig_types[190]
#define SWIGTYPE_p_std__vectorT_size_t_std__allocatorT_size_t_t_t swig_types[191]
#define SWIGTYPE_p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t swig_types[192]
#define SWIGTYPE_p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t swig_types[193]
#define SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t swig_types[194]
#define SWIGTYPE_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t swig_types[195]
#define SWIGTYPE_p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t swig_types[196]
#define SWIGTYPE_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t swig_types[197]
#define SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t swig_types[198]
#define SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator swig_types[199]
#define SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator swig_types[200]
#define SWIGTYPE_p_swig__SwigPyIterator swig_types[201]
#define SWIGTYPE_p_unsigned_char swig_types[202]
#define SWIGTYPE_p_unsigned_int swig_types[203]
#define SWIGTYPE_p_unsigned_long swig_types[204]
#define SWIGTYPE_p_unsigned_long_long swig_types[205]
#define SWIGTYPE_p_unsigned_short swig_types[206]
#define SWIGTYPE_p_value_type swig_types[207]
#define SWIGTYPE_p_vectorT_bool_std__allocatorT_bool_t_t swig_types[208]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator swig_types[209]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer swig_types[210]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference swig_types[211]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator swig_types[212]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer swig_types[213]
#define SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference swig_types[214]
#define SWIGTYPE_p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator swig_types[215]
#define SWIGTYPE_p_vectorvsp swig_types[216]
static swig_type_info *swig_types[218];
static swig_module_info swig_module = {swig_types, 217, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif
#if (PY_VERSION_HEX <= 0x02020000)
# error "This python version requires swig to be run with the '-nomodern' option"
#endif
#if (PY_VERSION_HEX <= 0x02020000)
# error "This python version requires swig to be run with the '-nomodernargs' option"
#endif
#ifndef METH_O
# error "This python version requires swig to be run with the '-nofastunpack' option"
#endif
#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _simuPOP_la.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__simuPOP_la

#else
#  define SWIG_init    init_simuPOP_la

#endif
#define SWIG_name    "_simuPOP_la"

#define SWIGVERSION 0x030012 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <stdint.h>		// Use the C99 official header



#include "config.h"
#include "simuPOP_cfg.h"
#include "genoStru.h"
#include "individual.h"
#include "population.h"
#include "pedigree.h"
#include "virtualSubPop.h"
#include "operator.h"
#include "simulator.h"

#include "utility.h"
#include "pedigree.h"
#include "initializer.h"
#include "outputer.h"
#include "mating.h"
#include "tagger.h"
#include "stator.h"
#include "migrator.h"
#include "mutator.h"
#include "transmitter.h"
#include "selector.h"
#include "qtrait.h"
#include "penetrance.h"




// templates are used to define array types for genotype and lineage
// because python types uses C functions, they need to be redefined with
// different names when templates are instantiated for these types.
#include "customizedTemplates.cpp"
extern "C"
{
#include "customizedTypes.c"
}


#include <iostream>

#if PY_VERSION_HEX >= 0x03020000
# define SWIGPY_SLICE_ARG(obj) ((PyObject*) (obj))
#else
# define SWIGPY_SLICE_ARG(obj) ((PySliceObject*) (obj))
#endif


#include <typeinfo>
#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>


#include <stddef.h>


namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };

#if defined(SWIGPYTHON_BUILTIN)
  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
  {
    Py_INCREF(pyself);
    return pyself;
  }
#endif
}


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


  #define SWIG_From_long   PyInt_FromLong 


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  (static_cast< long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  }
#endif
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  }
#endif
  return res;
}


#include <algorithm>


#include <vector>


#include <utility>


#include <map>


#include <algorithm>


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#else
#if PY_VERSION_HEX >= 0x03010000
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#else
      return PyUnicode_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_char  (unsigned char value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
  if (PyBytes_Check(obj))
#else
  if (PyUnicode_Check(obj))
#endif
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
#if !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    if(alloc) *alloc = SWIG_NEWOBJ;
#endif
    PyBytes_AsStringAndSize(obj, &cstr, &len);
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	{
	  *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
	  *alloc = SWIG_NEWOBJ;
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
#if PY_VERSION_HEX>=0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
	*cptr = PyBytes_AsString(obj);
#else
	assert(0); /* Should never reach here with Unicode strings in Python 3 */
#endif
#else
	*cptr = SWIG_Python_str_AsChar(obj);
#endif
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000 && !defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
#if defined(SWIG_PYTHON_2_UNICODE)
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
#error "Cannot use both SWIG_PYTHON_2_UNICODE and SWIG_PYTHON_STRICT_BYTE_CHAR at once"
#endif
#if PY_VERSION_HEX<0x03000000
    if (PyUnicode_Check(obj)) {
      char *cstr; Py_ssize_t len;
      if (!alloc && cptr) {
        return SWIG_RuntimeError;
      }
      obj = PyUnicode_AsUTF8String(obj);
      if (PyString_AsStringAndSize(obj, &cstr, &len) != -1) {
        if (cptr) {
          if (alloc) *alloc = SWIG_NEWOBJ;
          *cptr = reinterpret_cast< char* >(memcpy(new char[len + 1], cstr, sizeof(char)*(len + 1)));
        }
        if (psize) *psize = len + 1;

        Py_XDECREF(obj);
        return SWIG_OK;
      } else {
        Py_XDECREF(obj);
      }
    }
#endif
#endif

    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (PyObject * obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


namespace swig {
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  /*
    Partial specialization for pointers (traits_info)
  */
  template <class Type> struct traits_info<Type *> {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers (traits)
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category>
  struct traits_as { };

  template <class Type, class Category>
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_InternalNewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      swig_type_info *descriptor = type_info<Type>();
      int res = descriptor ? SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0) : SWIG_ERROR;
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


#include <functional>

namespace std {
  template <>
  struct less <PyObject *>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occurred in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  template <class Difference>
  inline size_t
  check_index(Difference i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    throw std::out_of_range("index out of range");
  }

  template <class Difference>
  void
  slice_adjust(Difference i, Difference j, Py_ssize_t step, size_t size, Difference &ii, Difference &jj, bool insert = false) {
    if (step == 0) {
      throw std::invalid_argument("slice step cannot be zero");
    } else if (step > 0) {
      // Required range: 0 <= i < size, 0 <= j < size, i <= j
      if (i < 0) {
        ii = 0;
      } else if (i < (Difference)size) {
        ii = i;
      } else if (insert && (i >= (Difference)size)) {
        ii = (Difference)size;
      }
      if (j < 0) {
        jj = 0;
      } else {
        jj = (j < (Difference)size) ? j : (Difference)size;
      }
      if (jj < ii)
        jj = ii;
    } else {
      // Required range: -1 <= i < size-1, -1 <= j < size-1, i >= j
      if (i < -1) {
        ii = -1;
      } else if (i < (Difference) size) {
        ii = i;
      } else if (i >= (Difference)(size-1)) {
        ii = (Difference)(size-1);
      }
      if (j < -1) {
        jj = -1;
      } else {
        jj = (j < (Difference)size ) ? j : (Difference)(size-1);
      }
      if (ii < jj)
        ii = jj;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence>
  inline void
  erase(Sequence* seq, const typename Sequence::iterator& position) {
    seq->erase(position);
  }

  template <class Sequence>
  struct traits_reserve {
    static void reserve(Sequence & /*seq*/, typename Sequence::size_type /*n*/) {
      // This should be specialized for types that support reserve
    }
  };

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj);

    if (step > 0) {
      typename Sequence::const_iterator sb = self->begin();
      typename Sequence::const_iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      if (step == 1) {
        return new Sequence(sb, se);
      } else {
        Sequence *sequence = new Sequence();
        swig::traits_reserve<Sequence>::reserve(*sequence, (jj - ii + step - 1) / step);
        typename Sequence::const_iterator it = sb;
        while (it!=se) {
          sequence->push_back(*it);
          for (Py_ssize_t c=0; c<step && it!=se; ++c)
            it++;
        }
        return sequence;
      } 
    } else {
      Sequence *sequence = new Sequence();
      swig::traits_reserve<Sequence>::reserve(*sequence, (ii - jj - step - 1) / -step);
      typename Sequence::const_reverse_iterator sb = self->rbegin();
      typename Sequence::const_reverse_iterator se = self->rbegin();
      std::advance(sb,size-ii-1);
      std::advance(se,size-jj-1);
      typename Sequence::const_reverse_iterator it = sb;
      while (it!=se) {
        sequence->push_back(*it);
        for (Py_ssize_t c=0; c<-step && it!=se; ++c)
          it++;
      }
      return sequence;
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      if (step == 1) {
        size_t ssize = jj - ii;
        if (ssize <= is.size()) {
          // expanding/staying the same size
          swig::traits_reserve<Sequence>::reserve(*self, self->size() - ssize + is.size());
          typename Sequence::iterator sb = self->begin();
          typename InputSeq::const_iterator isit = is.begin();
          std::advance(sb,ii);
          std::advance(isit, jj - ii);
          self->insert(std::copy(is.begin(), isit, sb), isit, is.end());
        } else {
          // shrinking
          typename Sequence::iterator sb = self->begin();
          typename Sequence::iterator se = self->begin();
          std::advance(sb,ii);
          std::advance(se,jj);
          self->erase(sb,se);
          sb = self->begin();
          std::advance(sb,ii);
          self->insert(sb, is.begin(), is.end());
        }
      } else {
        size_t replacecount = (jj - ii + step - 1) / step;
        if (is.size() != replacecount) {
          char msg[1024];
          sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
          throw std::invalid_argument(msg);
        }
        typename Sequence::const_iterator isit = is.begin();
        typename Sequence::iterator it = self->begin();
        std::advance(it,ii);
        for (size_t rc=0; rc<replacecount; ++rc) {
          *it++ = *isit++;
          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
            it++;
        }
      }
    } else {
      size_t replacecount = (ii - jj - step - 1) / -step;
      if (is.size() != replacecount) {
        char msg[1024];
        sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
        throw std::invalid_argument(msg);
      }
      typename Sequence::const_iterator isit = is.begin();
      typename Sequence::reverse_iterator it = self->rbegin();
      std::advance(it,size-ii-1);
      for (size_t rc=0; rc<replacecount; ++rc) {
        *it++ = *isit++;
        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
          it++;
      }
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      typename Sequence::iterator sb = self->begin();
      std::advance(sb,ii);
      if (step == 1) {
        typename Sequence::iterator se = self->begin();
        std::advance(se,jj);
        self->erase(sb,se);
      } else {
        typename Sequence::iterator it = sb;
        size_t delcount = (jj - ii + step - 1) / step;
        while (delcount) {
          it = self->erase(it);
          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
            it++;
          delcount--;
        }
      }
    } else {
      typename Sequence::reverse_iterator sb = self->rbegin();
      std::advance(sb,size-ii-1);
      typename Sequence::reverse_iterator it = sb;
      size_t delcount = (ii - jj - step - 1) / -step;
      while (delcount) {
        it = typename Sequence::reverse_iterator(self->erase((++it).base()));
        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
          it++;
        delcount--;
      }
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }

}


namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", (int)_index);
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    Py_ssize_t _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  // STL container wrapper around a Python sequence
  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;
    typedef size_t size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      Py_ssize_t s = size();
      for (Py_ssize_t i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", (int)i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}





SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}


namespace swig {
  template <> struct traits< size_t > {
    typedef value_category category;
    static const char* type_name() { return"size_t"; }
  };
  template <>  struct traits_asval< size_t > {
    typedef size_t value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal_size_t (obj, val);
    }
  };
  template <>  struct traits_from< size_t > {
    typedef size_t value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_size_t  (val);
    }
  };
}


namespace swig {
  template <class SwigPySeq, class Seq>
  inline void
  assign(const SwigPySeq& swigpyseq, Seq* seq) {
    // seq->assign(swigpyseq.begin(), swigpyseq.end()); // not used as not always implemented
    typedef typename SwigPySeq::value_type value_type;
    typename SwigPySeq::const_iterator it = swigpyseq.begin();
    for (;it != swigpyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(PyObject *obj, sequence **seq) {
      if (obj == Py_None || SWIG_Python_GetSwigThis(obj)) {
	sequence *p;
	swig_type_info *descriptor = swig::type_info<sequence>();
	if (descriptor && SWIG_IsOK(::SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0))) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      } else if (PySequence_Check(obj)) {
	try {
	  SwigPySequence_Cont<value_type> swigpyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(swigpyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return swigpyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    if (!PyErr_Occurred()) {
	      PyErr_SetString(PyExc_TypeError, e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static PyObject *from(const sequence& seq) {
#ifdef SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
      swig_type_info *desc = swig::type_info<sequence>();
      if (desc && desc->clientdata) {
	return SWIG_InternalNewPointerObj(new sequence(seq), desc, SWIG_POINTER_OWN);
      }
#endif
      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	PyObject *obj = PyTuple_New((Py_ssize_t)size);
	Py_ssize_t i = 0;
	for (const_iterator it = seq.begin(); it != seq.end(); ++it, ++i) {
	  PyTuple_SetItem(obj,i,swig::from<value_type>(*it));
	}
	return obj;
      } else {
	PyErr_SetString(PyExc_OverflowError,"sequence size not valid in python");
	return NULL;
      }
    }
  };
}


  namespace swig {
    template <class T>
    struct traits_reserve<std::vector<T> > {
      static void reserve(std::vector<T> &seq, typename std::vector<T>::size_type n) {
        seq.reserve(n);
      }
    };

    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(PyObject *obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static PyObject *from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector< size_t, std::allocator< size_t > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "size_t" "," "std::allocator< size_t >" " >";
	  }
	};
      }
    

namespace swig {
  template <> struct traits< double > {
    typedef value_category category;
    static const char* type_name() { return"double"; }
  };
  template <>  struct traits_asval< double > {
    typedef double value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal_double (obj, val);
    }
  };
  template <>  struct traits_from< double > {
    typedef double value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_double  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector< double, std::allocator< double > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "double" "," "std::allocator< double >" " >";
	  }
	};
      }
    

SWIGINTERN int
SWIG_AsVal_std_string (PyObject * obj, std::string *val)
{
  std::string* v = (std::string *) 0;
  int res = SWIG_AsPtr_std_string (obj, &v);
  if (!SWIG_IsOK(res)) return res;
  if (v) {
    if (val) *val = *v;
    if (SWIG_IsNewObj(res)) {
      delete v;
      res = SWIG_DelNewMask(res);
    }
    return res;
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE PyObject *
SWIG_From_std_string  (const std::string& s)
{
  return SWIG_FromCharPtrAndSize(s.data(), s.size());
}


namespace swig {
  template <> struct traits< std::string > {
    typedef value_category category;
    static const char* type_name() { return"std::string"; }
  };
  template <>  struct traits_asval< std::string > {
    typedef std::string value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal_std_string (obj, val);
    }
  };
  template <>  struct traits_from< std::string > {
    typedef std::string value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_std_string  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector< std::string, std::allocator< std::string > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "std::string" "," "std::allocator< std::string >" " >";
	  }
	};
      }
    

SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


  namespace swig {


















































    template <class T, class U >
    struct traits_asptr<std::pair<T,U> >  {
      typedef std::pair<T,U> value_type;

      static int get_pair(PyObject* first, PyObject* second,
			  std::pair<T,U> **val) 
      {
	if (val) {
	  value_type *vp = (new std::pair<T,U>());
	  T *pfirst = &(vp->first);
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) {
	    delete vp;
	    return res1;
	  }
	  U *psecond = &(vp->second);
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) {
	    delete vp;
	    return res2;
	  }
	  *val = vp;
	  return SWIG_AddNewMask(res1 > res2 ? res1 : res2);
	} else {
	  T *pfirst = 0;
	  int res1 = swig::asval((PyObject*)first, pfirst);
	  if (!SWIG_IsOK(res1)) return res1;
	  U *psecond = 0;
	  int res2 = swig::asval((PyObject*)second, psecond);
	  if (!SWIG_IsOK(res2)) return res2;
	  return res1 > res2 ? res1 : res2;
	}
      }

      static int asptr(PyObject *obj, std::pair<T,U> **val) {
	int res = SWIG_ERROR;
	if (PyTuple_Check(obj)) {
	  if (PyTuple_GET_SIZE(obj) == 2) {
	    res = get_pair(PyTuple_GET_ITEM(obj,0),PyTuple_GET_ITEM(obj,1), val);
	  }
	} else if (PySequence_Check(obj)) {
	  if (PySequence_Size(obj) == 2) {
	    swig::SwigVar_PyObject first = PySequence_GetItem(obj,0);
	    swig::SwigVar_PyObject second = PySequence_GetItem(obj,1);
	    res = get_pair(first, second, val);
	  }
	} else {
	  value_type *p;
	  swig_type_info *descriptor = swig::type_info<value_type>();
	  res = descriptor ? SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0) : SWIG_ERROR;
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	return res;
      }
    };


    template <class T, class U >
    struct traits_from<std::pair<T,U> >   {
      static PyObject *from(const std::pair<T,U>& val) {
	PyObject* obj = PyTuple_New(2);
	PyTuple_SetItem(obj,0,swig::from(val.first));
	PyTuple_SetItem(obj,1,swig::from(val.second));
	return obj;
      }
    };
  }





































      namespace swig {
	template <>  struct traits<std::pair< size_t, size_t > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "size_t" "," "size_t" " >";
	  }
	};
      }
    

namespace swig {
    template <>  struct traits<simuPOP::vspID > {
      typedef pointer_category category;
      static const char* type_name() { return"simuPOP::vspID"; }
    };
  }


  namespace swig {
    template <>  struct traits< simuPOP::BaseVspSplitter > {
      typedef pointer_category category;
      static const char* type_name() { return"simuPOP::BaseVspSplitter"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector< simuPOP::BaseVspSplitter*, std::allocator< simuPOP::BaseVspSplitter * > > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" "simuPOP::BaseVspSplitter" " *," "std::allocator< simuPOP::BaseVspSplitter * >" " >";
	  }
	};
      }
    

/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined __cplusplus && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


  namespace swig {
    template <>  struct traits< simuPOP::Individual > {
      typedef pointer_category category;
      static const char* type_name() { return"simuPOP::Individual"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::pair< simuPOP::Individual*, simuPOP::Individual* > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "simuPOP::Individual" " *," "simuPOP::Individual" " * >";
	  }
	};
      }
    

  namespace swig {
    template <>  struct traits< simuPOP::HomoMating > {
      typedef pointer_category category;
      static const char* type_name() { return"simuPOP::HomoMating"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector< simuPOP::HomoMating*, std::allocator< simuPOP::HomoMating * > > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" "simuPOP::HomoMating" " *," "std::allocator< simuPOP::HomoMating * >" " >";
	  }
	};
      }
    

namespace swig {
  template <> struct traits< long > {
    typedef value_category category;
    static const char* type_name() { return"long"; }
  };
  template <>  struct traits_asval< long > {
    typedef long value_type;
    static int asval(PyObject *obj, value_type *val) {
      return SWIG_AsVal_long (obj, val);
    }
  };
  template <>  struct traits_from< long > {
    typedef long value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_long  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector< long, std::allocator< long > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "long" "," "std::allocator< long >" " >";
	  }
	};
      }
    

      namespace swig {
	template <>  struct traits<std::pair< std::vector< long,std::allocator< long > >, double > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::pair<" "std::vector< long,std::allocator< long > >" "," "double" " >";
	  }
	};
      }
    

  namespace swig {
    template <class ValueType>
    struct from_key_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.first);
      }
    };

    template <class ValueType>
    struct from_value_oper 
    {
      typedef const ValueType& argument_type;
      typedef  PyObject *result_type;
      result_type operator()(argument_type v) const
      {
	return swig::from(v.second);
      }
    };

    template<class OutIterator, class FromOper, class ValueType = typename OutIterator::value_type>
    struct SwigPyMapIterator_T : SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper>
    {
      SwigPyMapIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
      {
      }
    };


    template<class OutIterator,
	     class FromOper = from_key_oper<typename OutIterator::value_type> >
    struct SwigPyMapKeyIterator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapKeyIterator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_key_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapKeyIterator_T<OutIter>(current, begin, end, seq);
    }

    template<class OutIterator,
	     class FromOper = from_value_oper<typename OutIterator::value_type> >
    struct SwigPyMapValueITerator_T : SwigPyMapIterator_T<OutIterator, FromOper>
    {
      SwigPyMapValueITerator_T(OutIterator curr, OutIterator first, OutIterator last, PyObject *seq)
	: SwigPyMapIterator_T<OutIterator, FromOper>(curr, first, last, seq)
      {
      }
    };
    

    template<typename OutIter>
    inline SwigPyIterator*
    make_output_value_iterator(const OutIter& current, const OutIter& begin, const OutIter& end, PyObject *seq = 0)
    {
      return new SwigPyMapValueITerator_T<OutIter>(current, begin, end, seq);
    }
  }


  namespace swig {
    template <class SwigPySeq, class K, class T, class Compare, class Alloc >
    inline void
    assign(const SwigPySeq& swigpyseq, std::map<K,T,Compare,Alloc > *map) {
      typedef typename std::map<K,T,Compare,Alloc >::value_type value_type;
      typename SwigPySeq::const_iterator it = swigpyseq.begin();
      for (;it != swigpyseq.end(); ++it) {
	map->insert(value_type(it->first, it->second));
      }
    }

    template <class K, class T, class Compare, class Alloc>
    struct traits_asptr<std::map<K,T,Compare,Alloc > >  {
      typedef std::map<K,T,Compare,Alloc > map_type;
      static int asptr(PyObject *obj, map_type **val) {
	int res = SWIG_ERROR;
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	if (PyDict_Check(obj)) {
	  SwigVar_PyObject items = PyObject_CallMethod(obj,(char *)"items",NULL);
#if PY_VERSION_HEX >= 0x03000000
          /* In Python 3.x the ".items()" method returns a dict_items object */
          items = PySequence_Fast(items, ".items() didn't return a sequence!");
#endif
	  res = traits_asptr_stdseq<map_type, std::pair<K, T> >::asptr(items, val);
	} else {
	  map_type *p;
	  swig_type_info *descriptor = swig::type_info<map_type>();
	  res = descriptor ? SWIG_ConvertPtr(obj, (void **)&p, descriptor, 0) : SWIG_ERROR;
	  if (SWIG_IsOK(res) && val)  *val = p;
	}
	SWIG_PYTHON_THREAD_END_BLOCK;
	return res;
      }      
    };
      
    template <class K, class T, class Compare, class Alloc >
    struct traits_from<std::map<K,T,Compare,Alloc > >  {
      typedef std::map<K,T,Compare,Alloc > map_type;
      typedef typename map_type::const_iterator const_iterator;
      typedef typename map_type::size_type size_type;

      static PyObject *asdict(const map_type& map) {
	SWIG_PYTHON_THREAD_BEGIN_BLOCK;
	size_type size = map.size();
	Py_ssize_t pysize = (size <= (size_type) INT_MAX) ? (Py_ssize_t) size : -1;
	if (pysize < 0) {
	  PyErr_SetString(PyExc_OverflowError, "map size not valid in python");
	  SWIG_PYTHON_THREAD_END_BLOCK;
	  return NULL;
	}
	PyObject *obj = PyDict_New();
	for (const_iterator i= map.begin(); i!= map.end(); ++i) {
	  swig::SwigVar_PyObject key = swig::from(i->first);
	  swig::SwigVar_PyObject val = swig::from(i->second);
	  PyDict_SetItem(obj, key, val);
	}
	SWIG_PYTHON_THREAD_END_BLOCK;
	return obj;
      }
                
      static PyObject *from(const map_type& map) {
	swig_type_info *desc = swig::type_info<map_type>();
	if (desc && desc->clientdata) {
	  return SWIG_InternalNewPointerObj(new map_type(map), desc, SWIG_POINTER_OWN);
	} else {
	  return asdict(map);
	}
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::map< std::vector< long,std::allocator< long > >, double, std::less< std::vector< long > >, std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::map<" "std::vector< long,std::allocator< long > >" "," "double" "," "std::less< std::vector< long > >" "," "std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > >" " >";
	  }
	};
      }
    
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_SwigPyIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SwigPyIterator" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_value" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)((swig::SwigPyIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 = (size_t) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:SwigPyIterator_incr",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_size_t(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 = (size_t) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:SwigPyIterator_decr",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_size_t(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "x", NULL 
  };
  ptrdiff_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator_distance",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_distance" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = ((swig::SwigPyIterator const *)arg1)->distance((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "x", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator_equal",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_equal" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = (bool)((swig::SwigPyIterator const *)arg1)->equal((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_copy" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->copy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_next" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___next__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->__next__();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_previous" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator_advance",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_advance" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->advance(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "x", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator___eq__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator ==((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "x", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator___ne__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator !=((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator___iadd__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator +=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator___isub__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator -=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:SwigPyIterator___add__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___add__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  ptrdiff_t result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = ((swig::SwigPyIterator const *)arg1)->operator -((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"SwigPyIterator___sub__",0,2,argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v = 0;
    {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__SwigPyIterator, 0);
      _v = SWIG_CheckState(res);
    }
    if (!_v) goto check_1;
    return _wrap_SwigPyIterator___sub____SWIG_1(self, argc, argv);
  }
check_1:
  
  if (argc == 2) {
    return _wrap_SwigPyIterator___sub____SWIG_0(self, argc, argv);
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_swig__SwigPyIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN int Swig_var_MISSING_VALUE_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable MISSING_VALUE is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_MISSING_VALUE_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_double(static_cast< double >(MISSING_VALUE));
  return pyobj;
}


SWIGINTERN int Swig_var_NOT_FOUND_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable NOT_FOUND is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_NOT_FOUND_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_size_t(static_cast< size_t >(NOT_FOUND));
  return pyobj;
}


SWIGINTERN int Swig_var_ModuleMaxAllele_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable ModuleMaxAllele is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_ModuleMaxAllele_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(ModuleMaxAllele));
  return pyobj;
}


SWIGINTERN int Swig_var_MaxRandomNumber_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable MaxRandomNumber is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_MaxRandomNumber_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(MaxRandomNumber));
  return pyobj;
}


SWIGINTERN int Swig_var_MaxTraitIndex_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable MaxTraitIndex is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_MaxTraitIndex_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_unsigned_SS_char(static_cast< unsigned char >(MaxTraitIndex));
  return pyobj;
}


SWIGINTERN int Swig_var_InvalidValue_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable InvalidValue is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_InvalidValue_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_size_t(static_cast< size_t >(InvalidValue));
  return pyobj;
}


SWIGINTERN int Swig_var_MaxIndexSize_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable MaxIndexSize is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_MaxIndexSize_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_size_t(static_cast< size_t >(MaxIndexSize));
  return pyobj;
}


SWIGINTERN PyObject *_wrap_new_Exception(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::Exception *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_Exception",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Exception" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Exception" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (simuPOP::Exception *)new simuPOP::Exception((string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Exception, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Exception_message(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Exception *arg1 = (simuPOP::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Exception, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Exception_message" "', argument " "1"" of type '" "simuPOP::Exception *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Exception * >(argp1);
  result = (char *)(arg1)->message();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Exception(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Exception *arg1 = (simuPOP::Exception *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Exception, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Exception" "', argument " "1"" of type '" "simuPOP::Exception *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Exception * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Exception_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Exception, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Exception_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_StopIteration(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::StopIteration *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_StopIteration",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_StopIteration" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::StopIteration *)new simuPOP::StopIteration(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__StopIteration, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StopIteration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::StopIteration *arg1 = (simuPOP::StopIteration *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__StopIteration, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StopIteration" "', argument " "1"" of type '" "simuPOP::StopIteration *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::StopIteration * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StopIteration_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__StopIteration, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *StopIteration_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_IndexError(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::IndexError *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_IndexError",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_IndexError" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::IndexError *)new simuPOP::IndexError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__IndexError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_IndexError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::IndexError *arg1 = (simuPOP::IndexError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__IndexError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IndexError" "', argument " "1"" of type '" "simuPOP::IndexError *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::IndexError * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *IndexError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__IndexError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *IndexError_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ValueError(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::ValueError *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_ValueError",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_ValueError" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::ValueError *)new simuPOP::ValueError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ValueError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ValueError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ValueError *arg1 = (simuPOP::ValueError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ValueError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ValueError" "', argument " "1"" of type '" "simuPOP::ValueError *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ValueError * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ValueError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ValueError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ValueError_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SystemError(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::SystemError *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_SystemError",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_SystemError" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::SystemError *)new simuPOP::SystemError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SystemError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SystemError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SystemError *arg1 = (simuPOP::SystemError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SystemError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SystemError" "', argument " "1"" of type '" "simuPOP::SystemError *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SystemError * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SystemError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SystemError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SystemError_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RuntimeError(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::RuntimeError *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_RuntimeError",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_RuntimeError" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::RuntimeError *)new simuPOP::RuntimeError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RuntimeError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RuntimeError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RuntimeError *arg1 = (simuPOP::RuntimeError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RuntimeError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RuntimeError" "', argument " "1"" of type '" "simuPOP::RuntimeError *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RuntimeError * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RuntimeError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RuntimeError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RuntimeError_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_StopEvolution(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::StopEvolution *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_StopEvolution",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_StopEvolution" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::StopEvolution *)new simuPOP::StopEvolution(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__StopEvolution, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StopEvolution(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::StopEvolution *arg1 = (simuPOP::StopEvolution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__StopEvolution, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StopEvolution" "', argument " "1"" of type '" "simuPOP::StopEvolution *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::StopEvolution * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StopEvolution_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__StopEvolution, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *StopEvolution_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RevertEvolution(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "msg", NULL 
  };
  simuPOP::RevertEvolution *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_RevertEvolution",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_RevertEvolution" "', argument " "1"" of type '" "string const""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (simuPOP::RevertEvolution *)new simuPOP::RevertEvolution(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RevertEvolution, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RevertEvolution(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RevertEvolution *arg1 = (simuPOP::RevertEvolution *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RevertEvolution, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RevertEvolution" "', argument " "1"" of type '" "simuPOP::RevertEvolution *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RevertEvolution * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RevertEvolution_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RevertEvolution, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RevertEvolution_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_turnOnDebug(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "code", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:turnOnDebug",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "turnOnDebug" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "turnOnDebug" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  {
    try
    {
      simuPOP::turnOnDebug((std::string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_turnOffDebug(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = "DBG_ALL" ;
  string *arg1 = (string *) &arg1_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "code", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:turnOffDebug",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "turnOffDebug" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "turnOffDebug" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  {
    try
    {
      simuPOP::turnOffDebug((std::string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_elapsedTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "name", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:elapsedTime",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "elapsedTime" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "elapsedTime" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      simuPOP::elapsedTime((std::string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_setOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  int arg1 = (int) (int)-1 ;
  char *arg2 = (char *) NULL ;
  unsigned long arg3 = (unsigned long) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  unsigned long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "numThreads",(char *) "name",(char *) "seed", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOO:setOptions",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "setOptions" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = static_cast< int >(val1);
  }
  if (obj1) {
    res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "setOptions" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_unsigned_SS_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "setOptions" "', argument " "3"" of type '" "unsigned long""'");
    } 
    arg3 = static_cast< unsigned long >(val3);
  }
  {
    try
    {
      simuPOP::setOptions(arg1,(char const *)arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_simuPOP_kbhit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"simuPOP_kbhit",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (int)simuPOP::simuPOP_kbhit();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simuPOP_getch(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"simuPOP_getch",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (int)simuPOP::simuPOP_getch();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pow3(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "n", NULL 
  };
  unsigned int result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:pow3",kwnames,&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "pow3" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try
    {
      result = (unsigned int)std::pow3(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_intList(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::intList *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_intList",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::intList *)new simuPOP::intList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__intList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_intList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::intList *arg1 = (simuPOP::intList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__intList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_intList" "', argument " "1"" of type '" "simuPOP::intList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::intList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *intList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__intList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *intList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_uintList(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) Py_True ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::uintList *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_uintList",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::uintList *)new simuPOP::uintList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_uintList_unspecified(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::uintList *arg1 = (simuPOP::uintList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__uintList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "uintList_unspecified" "', argument " "1"" of type '" "simuPOP::uintList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::uintList * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::uintList const *)arg1)->unspecified();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_uintList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::uintList *arg1 = (simuPOP::uintList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__uintList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_uintList" "', argument " "1"" of type '" "simuPOP::uintList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::uintList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *uintList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__uintList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *uintList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_lociList(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) Py_True ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::lociList *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_lociList",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::lociList *)new simuPOP::lociList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__lociList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lociList_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = (simuPOP::lociList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__lociList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lociList_empty" "', argument " "1"" of type '" "simuPOP::lociList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::lociList const *)arg1)->empty();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lociList_dynamic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = (simuPOP::lociList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__lociList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lociList_dynamic" "', argument " "1"" of type '" "simuPOP::lociList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::lociList const *)arg1)->dynamic();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lociList_elems(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = (simuPOP::lociList *) 0 ;
  simuPOP::Population *arg2 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "trait", NULL 
  };
  vectoru *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:lociList_elems",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__lociList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "lociList_elems" "', argument " "1"" of type '" "simuPOP::lociList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "lociList_elems" "', argument " "2"" of type '" "simuPOP::Population const *""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = (vectoru *) &((simuPOP::lociList const *)arg1)->elems((simuPOP::Population const *)arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_lociList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = (simuPOP::lociList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__lociList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_lociList" "', argument " "1"" of type '" "simuPOP::lociList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *lociList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__lociList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *lociList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_floatList__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  simuPOP::floatList *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    arg1 = swig_obj[0];
  }
  {
    try
    {
      result = (simuPOP::floatList *)new simuPOP::floatList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__floatList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_floatList__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  vectorf *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  simuPOP::floatList *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res1 = swig::asptr(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floatList" "', argument " "1"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floatList" "', argument " "1"" of type '" "vectorf const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      result = (simuPOP::floatList *)new simuPOP::floatList((vectorf const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__floatList, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_floatList(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_floatList",0,1,argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v = 0;
    if (argc > 0) {
      {
        _v = (argv[0] != 0);
      }
      if (!_v) goto check_1;
    }
    return _wrap_new_floatList__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_floatList__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_floatList'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::floatList::floatList(PyObject *)\n"
    "    simuPOP::floatList::floatList(vectorf const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_floatList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__floatList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_floatList" "', argument " "1"" of type '" "simuPOP::floatList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *floatList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__floatList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *floatList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_stringList__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  simuPOP::stringList *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    arg1 = swig_obj[0];
  }
  {
    try
    {
      result = (simuPOP::stringList *)new simuPOP::stringList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringList__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  simuPOP::stringList *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_stringList" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_stringList" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_stringList" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_stringList" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = (simuPOP::stringList *)new simuPOP::stringList((string const &)*arg1,(string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringList, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringList__SWIG_2(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  vectorstr *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  simuPOP::stringList *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
    res1 = swig::asptr(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_stringList" "', argument " "1"" of type '" "vectorstr const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_stringList" "', argument " "1"" of type '" "vectorstr const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      result = (simuPOP::stringList *)new simuPOP::stringList((vectorstr const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringList, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringList(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_stringList",0,2,argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v = 0;
    if (argc > 0) {
      {
        _v = (argv[0] != 0);
      }
      if (!_v) goto check_1;
    }
    return _wrap_new_stringList__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_stringList__SWIG_2(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_new_stringList__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_stringList'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::stringList::stringList(PyObject *)\n"
    "    simuPOP::stringList::stringList(string const &,string const &)\n"
    "    simuPOP::stringList::stringList(vectorstr const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_stringList_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringList *arg1 = (simuPOP::stringList *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "str", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:stringList_push_back",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__stringList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "stringList_push_back" "', argument " "1"" of type '" "simuPOP::stringList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringList * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "stringList_push_back" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "stringList_push_back" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      (arg1)->push_back((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_stringList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::stringList *arg1 = (simuPOP::stringList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__stringList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_stringList" "', argument " "1"" of type '" "simuPOP::stringList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *stringList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__stringList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *stringList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_intMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::intMatrix *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_intMatrix",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::intMatrix *)new simuPOP::intMatrix(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__intMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_intMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::intMatrix *arg1 = (simuPOP::intMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__intMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_intMatrix" "', argument " "1"" of type '" "simuPOP::intMatrix *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::intMatrix * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *intMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__intMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *intMatrix_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_floatMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::floatMatrix *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_floatMatrix",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::floatMatrix *)new simuPOP::floatMatrix(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__floatMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_floatMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::floatMatrix *arg1 = (simuPOP::floatMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__floatMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_floatMatrix" "', argument " "1"" of type '" "simuPOP::floatMatrix *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatMatrix * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *floatMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__floatMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *floatMatrix_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_stringMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "str", NULL 
  };
  simuPOP::stringMatrix *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_stringMatrix",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::stringMatrix *)new simuPOP::stringMatrix(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringMatrix, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_stringMatrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::stringMatrix *arg1 = (simuPOP::stringMatrix *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__stringMatrix, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_stringMatrix" "', argument " "1"" of type '" "simuPOP::stringMatrix *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringMatrix * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *stringMatrix_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__stringMatrix, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *stringMatrix_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_uintString__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  size_t arg1 ;
  size_t val1 ;
  int ecode1 = 0 ;
  simuPOP::uintString *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_uintString" "', argument " "1"" of type '" "size_t""'");
  } 
  arg1 = static_cast< size_t >(val1);
  {
    try
    {
      result = (simuPOP::uintString *)new simuPOP::uintString(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintString, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_uintString__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  simuPOP::uintString *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_uintString" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_uintString" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      result = (simuPOP::uintString *)new simuPOP::uintString((string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintString, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_uintString(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_uintString",0,1,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v = 0;
    {
      {
        int res = SWIG_AsVal_size_t(argv[0], NULL);
        _v = SWIG_CheckState(res);
      }
    }
    if (!_v) goto check_1;
    return _wrap_new_uintString__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_uintString__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_uintString'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::uintString::uintString(size_t)\n"
    "    simuPOP::uintString::uintString(string const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_uintString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::uintString *arg1 = (simuPOP::uintString *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__uintString, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_uintString" "', argument " "1"" of type '" "simuPOP::uintString *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::uintString * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *uintString_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__uintString, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *uintString_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_PyObj_AsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "str", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:PyObj_AsString",kwnames,&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    try
    {
      result = simuPOP::PyObj_AsString(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringFunc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  simuPOP::stringFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(swig_obj[0], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_stringFunc" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try
    {
      result = (simuPOP::stringFunc *)new simuPOP::stringFunc((char const *)arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringFunc, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringFunc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::stringFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try
    {
      result = (simuPOP::stringFunc *)new simuPOP::stringFunc(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__stringFunc, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_stringFunc(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_stringFunc",0,1,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
      _v = SWIG_CheckState(res);
    }
    if (!_v) goto check_1;
    return _wrap_new_stringFunc__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_stringFunc__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_stringFunc'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::stringFunc::stringFunc(char const *)\n"
    "    simuPOP::stringFunc::stringFunc(PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_stringFunc_mode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__stringFunc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "stringFunc_mode" "', argument " "1"" of type '" "simuPOP::stringFunc const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  {
    try
    {
      result = ((simuPOP::stringFunc const *)arg1)->mode();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_stringFunc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__stringFunc, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_stringFunc" "', argument " "1"" of type '" "simuPOP::stringFunc *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *stringFunc_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__stringFunc, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *stringFunc_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_uintListFunc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  vectoru const &arg1_defvalue = vectoru() ;
  vectoru *arg1 = (vectoru *) &arg1_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  simuPOP::uintListFunc *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    {
      std::vector< size_t,std::allocator< size_t > > *ptr = (std::vector< size_t,std::allocator< size_t > > *)0;
      res1 = swig::asptr(swig_obj[0], &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_uintListFunc" "', argument " "1"" of type '" "vectoru const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_uintListFunc" "', argument " "1"" of type '" "vectoru const &""'"); 
      }
      arg1 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::uintListFunc *)new simuPOP::uintListFunc((vectoru const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintListFunc, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_uintListFunc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ULONG arg1 ;
  unsigned long val1 ;
  int ecode1 = 0 ;
  simuPOP::uintListFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_long(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_uintListFunc" "', argument " "1"" of type '" "ULONG""'");
  } 
  arg1 = static_cast< ULONG >(val1);
  {
    try
    {
      result = (simuPOP::uintListFunc *)new simuPOP::uintListFunc(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintListFunc, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_uintListFunc__SWIG_2(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::uintListFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try
    {
      result = (simuPOP::uintListFunc *)new simuPOP::uintListFunc(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__uintListFunc, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_uintListFunc(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_uintListFunc",0,1,argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v = 0;
    if (argc > 0) {
      {
        int res = swig::asptr(argv[0], (std::vector< size_t,std::allocator< size_t > >**)(0));
        _v = SWIG_CheckState(res);
      }
      if (!_v) goto check_1;
    }
    return _wrap_new_uintListFunc__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    int _v = 0;
    {
      {
        int res = SWIG_AsVal_unsigned_SS_long(argv[0], NULL);
        _v = SWIG_CheckState(res);
      }
    }
    if (!_v) goto check_2;
    return _wrap_new_uintListFunc__SWIG_1(self, argc, argv);
  }
check_2:
  
  if (argc == 1) {
    return _wrap_new_uintListFunc__SWIG_2(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_uintListFunc'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::uintListFunc::uintListFunc(vectoru const &)\n"
    "    simuPOP::uintListFunc::uintListFunc(ULONG)\n"
    "    simuPOP::uintListFunc::uintListFunc(PyObject *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_uintListFunc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::uintListFunc *arg1 = (simuPOP::uintListFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__uintListFunc, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_uintListFunc" "', argument " "1"" of type '" "simuPOP::uintListFunc *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::uintListFunc * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *uintListFunc_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__uintListFunc, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *uintListFunc_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_floatListFunc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::floatListFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try
    {
      result = (simuPOP::floatListFunc *)new simuPOP::floatListFunc(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__floatListFunc, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_floatListFunc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  vectorf *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  simuPOP::floatListFunc *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res1 = swig::asptr(swig_obj[0], &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_floatListFunc" "', argument " "1"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_floatListFunc" "', argument " "1"" of type '" "vectorf const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      result = (simuPOP::floatListFunc *)new simuPOP::floatListFunc((vectorf const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__floatListFunc, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_floatListFunc(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_floatListFunc",0,1,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v = 0;
    {
      int res = swig::asptr(argv[0], (std::vector< double,std::allocator< double > >**)(0));
      _v = SWIG_CheckState(res);
    }
    if (!_v) goto check_1;
    return _wrap_new_floatListFunc__SWIG_1(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_floatListFunc__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_floatListFunc'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::floatListFunc::floatListFunc(PyObject *)\n"
    "    simuPOP::floatListFunc::floatListFunc(vectorf const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_floatListFunc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::floatListFunc *arg1 = (simuPOP::floatListFunc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__floatListFunc, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_floatListFunc" "', argument " "1"" of type '" "simuPOP::floatListFunc *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatListFunc * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *floatListFunc_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__floatListFunc, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *floatListFunc_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_PyObj_As_Bool(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  bool *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_Bool",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_bool,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_Bool" "', argument " "2"" of type '" "bool &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_Bool" "', argument " "2"" of type '" "bool &""'"); 
  }
  arg2 = reinterpret_cast< bool * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_Bool(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_Int(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  long *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_Int",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_long,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_Int" "', argument " "2"" of type '" "long &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_Int" "', argument " "2"" of type '" "long &""'"); 
  }
  arg2 = reinterpret_cast< long * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_Int(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_SizeT(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  size_t *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_SizeT",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_size_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_SizeT" "', argument " "2"" of type '" "size_t &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_SizeT" "', argument " "2"" of type '" "size_t &""'"); 
  }
  arg2 = reinterpret_cast< size_t * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_SizeT(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_Double(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  double *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_Double",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_Double" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_Double" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_Double(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_String(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  string *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_String",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_String" "', argument " "2"" of type '" "string &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_String" "', argument " "2"" of type '" "string &""'"); 
  }
  arg2 = reinterpret_cast< string * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_String(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_Array(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  vectorf *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_Array",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_Array" "', argument " "2"" of type '" "vectorf &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_Array" "', argument " "2"" of type '" "vectorf &""'"); 
  }
  arg2 = reinterpret_cast< vectorf * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_Array(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_IntArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  vectori *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_IntArray",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_long_std__allocatorT_long_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_IntArray" "', argument " "2"" of type '" "vectori &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_IntArray" "', argument " "2"" of type '" "vectori &""'"); 
  }
  arg2 = reinterpret_cast< vectori * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_IntArray(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyObj_As_SizeTArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  vectoru *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "obj",(char *) "val", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyObj_As_SizeTArray",kwnames,&obj0,&obj1)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_size_t_std__allocatorT_size_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyObj_As_SizeTArray" "', argument " "2"" of type '" "vectoru &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyObj_As_SizeTArray" "', argument " "2"" of type '" "vectoru &""'"); 
  }
  arg2 = reinterpret_cast< vectoru * >(argp2);
  {
    try
    {
      simuPOP::PyObj_As_SizeTArray(arg1,*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Allele_Vec_As_NumArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > arg1 ;
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Allele_Vec_As_NumArray",kwnames,&obj0,&obj1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Allele_Vec_As_NumArray" "', argument " "1"" of type '" "GenoIterator""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Allele_Vec_As_NumArray" "', argument " "1"" of type '" "GenoIterator""'");
    } else {
      GenoIterator * temp = reinterpret_cast< GenoIterator * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Allele_Vec_As_NumArray" "', argument " "2"" of type '" "GenoIterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Allele_Vec_As_NumArray" "', argument " "2"" of type '" "GenoIterator""'");
    } else {
      GenoIterator * temp = reinterpret_cast< GenoIterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try
    {
      result = (PyObject *)simuPOP::Allele_Vec_As_NumArray(arg1,arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Lineage_Vec_As_NumArray(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  LineageIterator arg1 ;
  LineageIterator arg2 ;
  swig::SwigPyIterator *iter1 = 0 ;
  int res1 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Lineage_Vec_As_NumArray",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, SWIG_as_voidptrptr(&iter1), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res1) || !iter1) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "Lineage_Vec_As_NumArray" "', argument " "1"" of type '" "LineageIterator""'");
  } else {
    swig::SwigPyIterator_T<LineageIterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<LineageIterator > *>(iter1);
    if (iter_t) {
      arg1 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "Lineage_Vec_As_NumArray" "', argument " "1"" of type '" "LineageIterator""'");
    }
  }
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "Lineage_Vec_As_NumArray" "', argument " "2"" of type '" "LineageIterator""'");
  } else {
    swig::SwigPyIterator_T<LineageIterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<LineageIterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "Lineage_Vec_As_NumArray" "', argument " "2"" of type '" "LineageIterator""'");
    }
  }
  {
    try
    {
      result = (PyObject *)simuPOP::Lineage_Vec_As_NumArray(arg1,arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_closeOutput(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "output", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:closeOutput",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "closeOutput" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "closeOutput" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  {
    try
    {
      simuPOP::closeOutput((std::string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RNG_func(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  gsl_rng *arg1 = (gsl_rng *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "rng", NULL 
  };
  simuPOP::RNG_func *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_RNG_func",kwnames,&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_gsl_rng, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RNG_func" "', argument " "1"" of type '" "gsl_rng *""'"); 
  }
  arg1 = reinterpret_cast< gsl_rng * >(argp1);
  {
    try
    {
      result = (simuPOP::RNG_func *)new simuPOP::RNG_func(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RNG_func, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_func___call__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG_func *arg1 = (simuPOP::RNG_func *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "N", NULL 
  };
  unsigned long result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_func___call__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG_func, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_func___call__" "', argument " "1"" of type '" "simuPOP::RNG_func const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG_func * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_func___call__" "', argument " "2"" of type '" "unsigned long""'");
  } 
  arg2 = static_cast< unsigned long >(val2);
  {
    try
    {
      result = (unsigned long)((simuPOP::RNG_func const *)arg1)->operator ()(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RNG_func(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG_func *arg1 = (simuPOP::RNG_func *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG_func, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RNG_func" "', argument " "1"" of type '" "simuPOP::RNG_func *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG_func * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RNG_func_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RNG_func, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RNG_func_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RNG(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) NULL ;
  unsigned long arg2 = (unsigned long) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "name",(char *) "seed", NULL 
  };
  simuPOP::RNG *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:new_RNG",kwnames,&obj0,&obj1)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RNG" "', argument " "1"" of type '" "char const *""'");
    }
    arg1 = reinterpret_cast< char * >(buf1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RNG" "', argument " "2"" of type '" "unsigned long""'");
    } 
    arg2 = static_cast< unsigned long >(val2);
  }
  {
    try
    {
      result = (simuPOP::RNG *)new simuPOP::RNG((char const *)arg1,arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RNG, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RNG(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RNG" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_set(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  char *arg2 = (char *) NULL ;
  unsigned long arg3 = (unsigned long) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  unsigned long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name",(char *) "seed", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:RNG_set",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_set" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  if (obj1) {
    res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RNG_set" "', argument " "2"" of type '" "char const *""'");
    }
    arg2 = reinterpret_cast< char * >(buf2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_unsigned_SS_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RNG_set" "', argument " "3"" of type '" "unsigned long""'");
    } 
    arg3 = static_cast< unsigned long >(val3);
  }
  {
    try
    {
      (arg1)->set((char const *)arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  char *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_name" "', argument " "1"" of type '" "simuPOP::RNG const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      result = (char *)((simuPOP::RNG const *)arg1)->name();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_seed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  unsigned long result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_seed" "', argument " "1"" of type '" "simuPOP::RNG const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      result = (unsigned long)((simuPOP::RNG const *)arg1)->seed();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_generateRandomSeed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned long result;
  
  if (!SWIG_Python_UnpackTuple(args,"RNG_generateRandomSeed",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (unsigned long)simuPOP::RNG::generateRandomSeed();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randUniform(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randUniform" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      result = (double)(arg1)->randUniform();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randBit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randBit" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      result = (bool)(arg1)->randBit();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randInt(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  unsigned long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  unsigned long result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randInt",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randInt" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randInt" "', argument " "2"" of type '" "unsigned long""'");
  } 
  arg2 = static_cast< unsigned long >(val2);
  {
    try
    {
      result = (unsigned long)(arg1)->randInt(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randNormal(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "mu",(char *) "sigma", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:RNG_randNormal",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randNormal" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randNormal" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RNG_randNormal" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try
    {
      result = (double)(arg1)->randNormal(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randExponential(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "mu", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randExponential",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randExponential" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randExponential" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (double)(arg1)->randExponential(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randGamma(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "a",(char *) "b", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:RNG_randGamma",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randGamma" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randGamma" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RNG_randGamma" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try
    {
      result = (double)(arg1)->randGamma(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randChisq(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "nu", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randChisq",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randChisq" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randChisq" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (double)(arg1)->randChisq(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randGeometric(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "p", NULL 
  };
  long result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randGeometric",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randGeometric" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randGeometric" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (long)(arg1)->randGeometric(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randBinomial(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  UINT arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n",(char *) "p", NULL 
  };
  ULONG result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:RNG_randBinomial",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randBinomial" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randBinomial" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RNG_randBinomial" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try
    {
      result = (ULONG)(arg1)->randBinomial(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randPoisson(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "mu", NULL 
  };
  ULONG result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randPoisson",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randPoisson" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randPoisson" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (ULONG)(arg1)->randPoisson(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randTruncatedPoisson(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "mu", NULL 
  };
  ULONG result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:RNG_randTruncatedPoisson",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randTruncatedPoisson" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randTruncatedPoisson" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (ULONG)(arg1)->randTruncatedPoisson(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randTruncatedBinomial(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  UINT arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n",(char *) "p", NULL 
  };
  ULONG result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:RNG_randTruncatedBinomial",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randTruncatedBinomial" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randTruncatedBinomial" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RNG_randTruncatedBinomial" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try
    {
      result = (ULONG)(arg1)->randTruncatedBinomial(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RNG_randMultinomial(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = (simuPOP::RNG *) 0 ;
  unsigned int arg2 ;
  vectorf *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "N",(char *) "p", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:RNG_randMultinomial",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNG_randMultinomial" "', argument " "1"" of type '" "simuPOP::RNG *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RNG_randMultinomial" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res3 = swig::asptr(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RNG_randMultinomial" "', argument " "3"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNG_randMultinomial" "', argument " "3"" of type '" "vectorf const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try
    {
      result = (arg1)->randMultinomial(arg2,(vectorf const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *RNG_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RNG, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RNG_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_getRNG(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RNG *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"getRNG",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (simuPOP::RNG *) &simuPOP::getRNG();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RNG, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_WeightedSampler(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  vectorf const &arg1_defvalue = vectorf() ;
  vectorf *arg1 = (vectorf *) &arg1_defvalue ;
  ULONG arg2 = (ULONG) 0 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "weights",(char *) "N", NULL 
  };
  simuPOP::WeightedSampler *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:new_WeightedSampler",kwnames,&obj0,&obj1)) SWIG_fail;
  if (obj0) {
    {
      std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
      res1 = swig::asptr(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WeightedSampler" "', argument " "1"" of type '" "vectorf const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WeightedSampler" "', argument " "1"" of type '" "vectorf const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_WeightedSampler" "', argument " "2"" of type '" "ULONG""'");
    } 
    arg2 = static_cast< ULONG >(val2);
  }
  {
    try
    {
      result = (simuPOP::WeightedSampler *)new simuPOP::WeightedSampler((vectorf const &)*arg1,arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__WeightedSampler, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_WeightedSampler(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::WeightedSampler *arg1 = (simuPOP::WeightedSampler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__WeightedSampler, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_WeightedSampler" "', argument " "1"" of type '" "simuPOP::WeightedSampler *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::WeightedSampler * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_WeightedSampler_draw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::WeightedSampler *arg1 = (simuPOP::WeightedSampler *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__WeightedSampler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WeightedSampler_draw" "', argument " "1"" of type '" "simuPOP::WeightedSampler *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::WeightedSampler * >(argp1);
  {
    try
    {
      result = (arg1)->draw();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_WeightedSampler_drawSamples(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::WeightedSampler *arg1 = (simuPOP::WeightedSampler *) 0 ;
  ULONG arg2 = (ULONG) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "n", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:WeightedSampler_drawSamples",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__WeightedSampler, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WeightedSampler_drawSamples" "', argument " "1"" of type '" "simuPOP::WeightedSampler *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::WeightedSampler * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "WeightedSampler_drawSamples" "', argument " "2"" of type '" "ULONG""'");
    } 
    arg2 = static_cast< ULONG >(val2);
  }
  {
    try
    {
      result = (arg1)->drawSamples(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *WeightedSampler_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__WeightedSampler, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *WeightedSampler_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Bernullitrials(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = 0 ;
  vectorf *arg2 = 0 ;
  ULONG arg3 = (ULONG) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "arg1",(char *) "prob",(char *) "trials", NULL 
  };
  simuPOP::Bernullitrials *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:new_Bernullitrials",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__RNG,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Bernullitrials" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Bernullitrials" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Bernullitrials" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Bernullitrials" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_unsigned_SS_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Bernullitrials" "', argument " "3"" of type '" "ULONG""'");
    } 
    arg3 = static_cast< ULONG >(val3);
  }
  {
    try
    {
      result = (simuPOP::Bernullitrials *)new simuPOP::Bernullitrials(*arg1,(vectorf const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Bernullitrials, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Bernullitrials(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Bernullitrials" "', argument " "1"" of type '" "simuPOP::Bernullitrials *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_probSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_probSize" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  {
    try
    {
      result = ((simuPOP::Bernullitrials const *)arg1)->probSize();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_doTrial(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_doTrial" "', argument " "1"" of type '" "simuPOP::Bernullitrials *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  {
    try
    {
      (arg1)->doTrial();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trial(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trial" "', argument " "1"" of type '" "simuPOP::Bernullitrials *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  {
    try
    {
      (arg1)->trial();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialSucc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trialSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_trialSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = (bool)((simuPOP::Bernullitrials const *)arg1)->trialSucc(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialSucc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  bool result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trialSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_trialSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Bernullitrials_trialSucc" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = (bool)((simuPOP::Bernullitrials const *)arg1)->trialSucc(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialSucc(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"Bernullitrials_trialSucc",0,3,argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    return _wrap_Bernullitrials_trialSucc__SWIG_0(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_Bernullitrials_trialSucc__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Bernullitrials_trialSucc'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::Bernullitrials::trialSucc(size_t) const\n"
    "    simuPOP::Bernullitrials::trialSucc(size_t,size_t) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialFirstSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Bernullitrials_trialFirstSucc",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trialFirstSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_trialFirstSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Bernullitrials const *)arg1)->trialFirstSucc(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialNextSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "pos", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Bernullitrials_trialNextSucc",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trialNextSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_trialNextSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Bernullitrials_trialNextSucc" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Bernullitrials const *)arg1)->trialNextSucc(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_setTrialSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  size_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "succ", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Bernullitrials_setTrialSucc",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_setTrialSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_setTrialSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Bernullitrials_setTrialSucc" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try
    {
      (arg1)->setTrialSucc(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_trialSuccRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  UINT arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "index", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Bernullitrials_trialSuccRate",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_trialSuccRate" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_trialSuccRate" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  {
    try
    {
      result = (double)((simuPOP::Bernullitrials const *)arg1)->trialSuccRate(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_probSuccRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials *arg1 = (simuPOP::Bernullitrials *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_probSuccRate" "', argument " "1"" of type '" "simuPOP::Bernullitrials const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials * >(argp1);
  {
    try
    {
      result = (double)((simuPOP::Bernullitrials const *)arg1)->probSuccRate();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Bernullitrials_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Bernullitrials, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Bernullitrials_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Bernullitrials_T__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  simuPOP::Bernullitrials_T *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_simuPOP__RNG,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Bernullitrials_T" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Bernullitrials_T" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    try
    {
      result = (simuPOP::Bernullitrials_T *)new simuPOP::Bernullitrials_T(*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Bernullitrials_T, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Bernullitrials_T__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::RNG *arg1 = 0 ;
  vectorf *arg2 = 0 ;
  size_t arg3 = (size_t) 1024 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  simuPOP::Bernullitrials_T *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_simuPOP__RNG,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Bernullitrials_T" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Bernullitrials_T" "', argument " "1"" of type '" "simuPOP::RNG &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RNG * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(swig_obj[1], &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Bernullitrials_T" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Bernullitrials_T" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_size_t(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Bernullitrials_T" "', argument " "3"" of type '" "size_t""'");
    } 
    arg3 = static_cast< size_t >(val3);
  }
  {
    try
    {
      result = (simuPOP::Bernullitrials_T *)new simuPOP::Bernullitrials_T(*arg1,(vectorf const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Bernullitrials_T, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Bernullitrials_T(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_Bernullitrials_T",0,3,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    return _wrap_new_Bernullitrials_T__SWIG_0(self, argc, argv);
  }
  if ((argc >= 2) && (argc <= 3)) {
    return _wrap_new_Bernullitrials_T__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_Bernullitrials_T'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::Bernullitrials_T::Bernullitrials_T(simuPOP::RNG &)\n"
    "    simuPOP::Bernullitrials_T::Bernullitrials_T(simuPOP::RNG &,vectorf const &,size_t)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Bernullitrials_T(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Bernullitrials_T" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_setParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  vectorf *arg2 = 0 ;
  size_t arg3 = (size_t) 1024 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "prob",(char *) "N", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Bernullitrials_T_setParameter",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_setParameter" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Bernullitrials_T_setParameter" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Bernullitrials_T_setParameter" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_size_t(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Bernullitrials_T_setParameter" "', argument " "3"" of type '" "size_t""'");
    } 
    arg3 = static_cast< size_t >(val3);
  }
  {
    try
    {
      (arg1)->setParameter((vectorf const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_doTrial(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_doTrial" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    try
    {
      (arg1)->doTrial();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_trial(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_trial" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    try
    {
      (arg1)->trial();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_trialSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Bernullitrials_T_trialSucc",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_trialSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_T_trialSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = (bool)((simuPOP::Bernullitrials_T const *)arg1)->trialSucc(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_probFirstSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_probFirstSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    try
    {
      result = ((simuPOP::Bernullitrials_T const *)arg1)->probFirstSucc();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_probNextSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pos", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Bernullitrials_T_probNextSucc",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_probNextSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_T_probNextSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Bernullitrials_T const *)arg1)->probNextSucc(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_setTrialSucc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  size_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "succ", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Bernullitrials_T_setTrialSucc",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_setTrialSucc" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_T_setTrialSucc" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Bernullitrials_T_setTrialSucc" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try
    {
      (arg1)->setTrialSucc(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_trialSuccRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  UINT arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "index", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Bernullitrials_T_trialSuccRate",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_trialSuccRate" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Bernullitrials_T_trialSuccRate" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  {
    try
    {
      result = (double)((simuPOP::Bernullitrials_T const *)arg1)->trialSuccRate(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Bernullitrials_T_probSuccRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Bernullitrials_T *arg1 = (simuPOP::Bernullitrials_T *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Bernullitrials_T, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Bernullitrials_T_probSuccRate" "', argument " "1"" of type '" "simuPOP::Bernullitrials_T const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Bernullitrials_T * >(argp1);
  {
    try
    {
      result = (double)((simuPOP::Bernullitrials_T const *)arg1)->probSuccRate();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Bernullitrials_T_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Bernullitrials_T, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Bernullitrials_T_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_moduleInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"moduleInfo",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (PyObject *)simuPOP::moduleInfo();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenoStruTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_GenoStruTrait",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (simuPOP::GenoStruTrait *)new simuPOP::GenoStruTrait();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__GenoStruTrait, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociDist(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus1",(char *) "locus2", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:GenoStruTrait_lociDist",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociDist" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_lociDist" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoStruTrait_lociDist" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = (double)((simuPOP::GenoStruTrait const *)arg1)->lociDist(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociLeft(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_lociLeft",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociLeft" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_lociLeft" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->lociLeft(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_distLeft(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_distLeft",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_distLeft" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_distLeft" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = (double)((simuPOP::GenoStruTrait const *)arg1)->distLeft(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociCovered(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus",(char *) "dist", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:GenoStruTrait_lociCovered",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociCovered" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_lociCovered" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoStruTrait_lociCovered" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->lociCovered(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_ploidy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  UINT result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_ploidy" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = (UINT)((simuPOP::GenoStruTrait const *)arg1)->ploidy();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_ploidyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_ploidyName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->ploidyName();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_numLoci__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_numLoci" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_numLoci" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->numLoci(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_numLoci__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  vectoru result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_numLoci" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->numLoci();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_numLoci(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"GenoStruTrait_numLoci",0,2,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    return _wrap_GenoStruTrait_numLoci__SWIG_1(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_GenoStruTrait_numLoci__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'GenoStruTrait_numLoci'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::GenoStruTrait::numLoci(size_t) const\n"
    "    simuPOP::GenoStruTrait::numLoci() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_sexChrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_sexChrom" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::GenoStruTrait const *)arg1)->sexChrom();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_isHaplodiploid(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_isHaplodiploid" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::GenoStruTrait const *)arg1)->isHaplodiploid();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_totNumLoci(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_totNumLoci" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->totNumLoci();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_genoSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_genoSize" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->genoSize();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_locusPos(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_locusPos",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_locusPos" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_locusPos" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = (double)((simuPOP::GenoStruTrait const *)arg1)->locusPos(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociPos(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectorf result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociPos" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->lociPos();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< double,std::allocator< double > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_numChrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_numChrom" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->numChrom();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromBegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromBegin",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromBegin" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_chromBegin" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromBegin(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromEnd",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromEnd" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_chromEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromEnd(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_absLocusIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  UINT arg2 ;
  UINT arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom",(char *) "locus", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:GenoStruTrait_absLocusIndex",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_absLocusIndex" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_absLocusIndex" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoStruTrait_absLocusIndex" "', argument " "3"" of type '" "UINT""'");
  } 
  arg3 = static_cast< UINT >(val3);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->absLocusIndex(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromLocusPair(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  pairu result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromLocusPair",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromLocusPair" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_chromLocusPair" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromLocusPair(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::pair< size_t,size_t > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_chromName" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromName(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectorstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromNames" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromNames();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromType(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromType",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromType" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_chromType" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromType(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectoru result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromTypes" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromTypes();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_chromByName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_chromByName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_chromByName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "GenoStruTrait_chromByName" "', argument " "2"" of type '" "string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->chromByName(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_alleleName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  ULONG arg2 ;
  size_t arg3 = (size_t) (size_t)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "allele",(char *) "locus", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:GenoStruTrait_alleleName",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_alleleName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_alleleName" "', argument " "2"" of type '" "ULONG""'");
  } 
  arg2 = static_cast< ULONG >(val2);
  if (obj2) {
    ecode3 = SWIG_AsVal_size_t(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoStruTrait_alleleName" "', argument " "3"" of type '" "size_t""'");
    } 
    arg3 = static_cast< size_t >(val3);
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->alleleName(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_alleleNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 = (size_t) (size_t)0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  vectorstr result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:GenoStruTrait_alleleNames",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_alleleNames" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_size_t(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_alleleNames" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->alleleNames(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_locusName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_locusName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_locusName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_locusName" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->locusName(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectorstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociNames" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->lociNames();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_locusByName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_locusByName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_locusByName" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "GenoStruTrait_locusByName" "', argument " "2"" of type '" "string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->locusByName(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_lociByNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  vectorstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "names", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_lociByNames",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_lociByNames" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoStruTrait_lociByNames" "', argument " "2"" of type '" "vectorstr const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoStruTrait_lociByNames" "', argument " "2"" of type '" "vectorstr const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->lociByNames((vectorstr const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_indexesOfLoci(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "loci", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:GenoStruTrait_indexesOfLoci",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_indexesOfLoci" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoStruTrait_indexesOfLoci" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoStruTrait_indexesOfLoci" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->indexesOfLoci((simuPOP::lociList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_hasInfoField(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_hasInfoField",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_hasInfoField" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoStruTrait_hasInfoField" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoStruTrait_hasInfoField" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = (bool)((simuPOP::GenoStruTrait const *)arg1)->hasInfoField((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_infoSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_infoSize" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->infoSize();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_infoFields(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectorstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_infoFields" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->infoFields();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_infoField(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_infoField",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_infoField" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GenoStruTrait_infoField" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->infoField(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoStruTrait_infoIdx(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:GenoStruTrait_infoIdx",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoStruTrait_infoIdx" "', argument " "1"" of type '" "simuPOP::GenoStruTrait const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoStruTrait_infoIdx" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoStruTrait_infoIdx" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = ((simuPOP::GenoStruTrait const *)arg1)->infoIdx((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GenoStruTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoStruTrait *arg1 = (simuPOP::GenoStruTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoStruTrait, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenoStruTrait" "', argument " "1"" of type '" "simuPOP::GenoStruTrait *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoStruTrait * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenoStruTrait_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__GenoStruTrait, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenoStruTrait_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_pyMutantIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > arg1 ;
  size_t arg2 ;
  size_t arg3 ;
  size_t arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "base",(char *) "begin",(char *) "end",(char *) "step", NULL 
  };
  simuPOP::pyMutantIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOO:new_pyMutantIterator",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_pyMutantIterator" "', argument " "1"" of type '" "GenoIterator""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyMutantIterator" "', argument " "1"" of type '" "GenoIterator""'");
    } else {
      GenoIterator * temp = reinterpret_cast< GenoIterator * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_pyMutantIterator" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_pyMutantIterator" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_pyMutantIterator" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    try
    {
      result = (simuPOP::pyMutantIterator *)new simuPOP::pyMutantIterator(arg1,arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_pyMutantIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyMutantIterator *arg1 = (simuPOP::pyMutantIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_pyMutantIterator" "', argument " "1"" of type '" "simuPOP::pyMutantIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyMutantIterator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyMutantIterator___iter__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyMutantIterator *arg1 = (simuPOP::pyMutantIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< simuPOP::pyMutantIterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyMutantIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyMutantIterator___iter__" "', argument " "1"" of type '" "simuPOP::pyMutantIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyMutantIterator * >(argp1);
  {
    try
    {
      result = (arg1)->__iter__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyMutantIterator(static_cast< const simuPOP::pyMutantIterator& >(result))), SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyMutantIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyMutantIterator *arg1 = (simuPOP::pyMutantIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  pairu result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyMutantIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyMutantIterator_next" "', argument " "1"" of type '" "simuPOP::pyMutantIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyMutantIterator * >(argp1);
  {
    try
    {
      result = (arg1)->next();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::pair< size_t,size_t > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyMutantIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyMutantIterator *arg1 = (simuPOP::pyMutantIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  pairu result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyMutantIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyMutantIterator___next__" "', argument " "1"" of type '" "simuPOP::pyMutantIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyMutantIterator * >(argp1);
  {
    try
    {
      result = (arg1)->__next__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::pair< size_t,size_t > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *pyMutantIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *pyMutantIterator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Individual(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Individual *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_Individual",0,0,0)) SWIG_fail;
  {
    try
    {
      result = (simuPOP::Individual *)new simuPOP::Individual();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Individual(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Individual, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Individual" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_allele(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  size_t arg2 ;
  ssize_t arg3 = (ssize_t) -1 ;
  ssize_t arg4 = (ssize_t) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "ploidy",(char *) "chrom", NULL 
  };
  ULONG result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Individual_allele",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_allele" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_allele" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  if (obj2) {
    ecode3 = SWIG_AsVal_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_allele" "', argument " "3"" of type '" "ssize_t""'");
    } 
    arg3 = static_cast< ssize_t >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_long(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Individual_allele" "', argument " "4"" of type '" "ssize_t""'");
    } 
    arg4 = static_cast< ssize_t >(val4);
  }
  {
    try
    {
      result = (ULONG)((simuPOP::Individual const *)arg1)->allele(arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_alleleChar(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  size_t arg2 ;
  ssize_t arg3 = (ssize_t) -1 ;
  ssize_t arg4 = (ssize_t) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "ploidy",(char *) "chrom", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Individual_alleleChar",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_alleleChar" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_alleleChar" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  if (obj2) {
    ecode3 = SWIG_AsVal_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_alleleChar" "', argument " "3"" of type '" "ssize_t""'");
    } 
    arg3 = static_cast< ssize_t >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_long(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Individual_alleleChar" "', argument " "4"" of type '" "ssize_t""'");
    } 
    arg4 = static_cast< ssize_t >(val4);
  }
  {
    try
    {
      result = ((simuPOP::Individual const *)arg1)->alleleChar(arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setAllele(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  ULONG arg2 ;
  size_t arg3 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "allele",(char *) "idx",(char *) "ploidy",(char *) "chrom", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|OO:Individual_setAllele",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setAllele" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_setAllele" "', argument " "2"" of type '" "ULONG""'");
  } 
  arg2 = static_cast< ULONG >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_setAllele" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Individual_setAllele" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Individual_setAllele" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  {
    try
    {
      (arg1)->setAllele(arg2,arg3,arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_alleleLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  size_t arg2 ;
  ssize_t arg3 = (ssize_t) -1 ;
  ssize_t arg4 = (ssize_t) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "ploidy",(char *) "chrom", NULL 
  };
  long result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Individual_alleleLineage",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_alleleLineage" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_alleleLineage" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  if (obj2) {
    ecode3 = SWIG_AsVal_long(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_alleleLineage" "', argument " "3"" of type '" "ssize_t""'");
    } 
    arg3 = static_cast< ssize_t >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_long(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Individual_alleleLineage" "', argument " "4"" of type '" "ssize_t""'");
    } 
    arg4 = static_cast< ssize_t >(val4);
  }
  {
    try
    {
      result = (long)((simuPOP::Individual const *)arg1)->alleleLineage(arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setAlleleLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  long arg2 ;
  size_t arg3 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "lineage",(char *) "idx",(char *) "ploidy",(char *) "chrom", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|OO:Individual_setAlleleLineage",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setAlleleLineage" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_setAlleleLineage" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_setAlleleLineage" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Individual_setAlleleLineage" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Individual_setAlleleLineage" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  {
    try
    {
      (arg1)->setAlleleLineage(arg2,arg3,arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_genotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ploidy",(char *) "chroms", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Individual_genotype",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_genotype" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_genotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_genotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_genotype" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_genotype" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  {
    try
    {
      result = (PyObject *)(arg1)->genotype((simuPOP::uintList const &)*arg2,(simuPOP::uintList const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_mutants(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ploidy",(char *) "chroms", NULL 
  };
  SwigValueWrapper< simuPOP::pyMutantIterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Individual_mutants",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_mutants" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_mutants" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_mutants" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_mutants" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_mutants" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  {
    try
    {
      result = (arg1)->mutants((simuPOP::uintList const &)*arg2,(simuPOP::uintList const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyMutantIterator(static_cast< const simuPOP::pyMutantIterator& >(result))), SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_lineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ploidy",(char *) "chroms", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Individual_lineage",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_lineage" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_lineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_lineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_lineage" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_lineage" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  {
    try
    {
      result = (PyObject *)(arg1)->lineage((simuPOP::uintList const &)*arg2,(simuPOP::uintList const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "geno",(char *) "ploidy",(char *) "chroms", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Individual_setGenotype",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setGenotype" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_setGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_setGenotype" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setGenotype" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Individual_setGenotype" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setGenotype" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  {
    try
    {
      (arg1)->setGenotype((simuPOP::uintList const &)*arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "lineage",(char *) "ploidy",(char *) "chroms", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Individual_setLineage",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setLineage" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_setLineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setLineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_setLineage" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setLineage" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Individual_setLineage" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setLineage" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  {
    try
    {
      (arg1)->setLineage((simuPOP::uintList const &)*arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_sex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Sex result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_sex" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  {
    try
    {
      result = (Sex)((simuPOP::Individual const *)arg1)->sex();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setSex(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  Sex arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "sex", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual_setSex",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setSex" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_setSex" "', argument " "2"" of type '" "Sex""'");
  } 
  arg2 = static_cast< Sex >(val2);
  {
    try
    {
      (arg1)->setSex(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_affected(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_affected" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::Individual const *)arg1)->affected();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setAffected(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "affected", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual_setAffected",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setAffected" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_setAffected" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try
    {
      (arg1)->setAffected(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::uintString *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "field", NULL 
  };
  double result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual_info",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_info" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintString,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual_info" "', argument " "2"" of type '" "simuPOP::uintString const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_info" "', argument " "2"" of type '" "simuPOP::uintString const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintString * >(argp2);
  {
    try
    {
      result = (double)((simuPOP::Individual const *)arg1)->info((simuPOP::uintString const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_double(static_cast< double >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_setInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  double arg2 ;
  simuPOP::uintString *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "value",(char *) "field", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Individual_setInfo",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_setInfo" "', argument " "1"" of type '" "simuPOP::Individual *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_setInfo" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintString,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Individual_setInfo" "', argument " "3"" of type '" "simuPOP::uintString const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual_setInfo" "', argument " "3"" of type '" "simuPOP::uintString const &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::uintString * >(argp3);
  {
    try
    {
      (arg1)->setInfo(arg2,(simuPOP::uintString const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual_genoEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "p",(char *) "chrom", NULL 
  };
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Individual_genoEnd",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual_genoEnd" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Individual_genoEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Individual_genoEnd" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Individual const *)arg1)->genoEnd(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new GenoIterator(static_cast< const GenoIterator& >(result))), SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual___eq__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual___eq__" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual___eq__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual___eq__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  {
    try
    {
      result = (bool)((simuPOP::Individual const *)arg1)->operator ==((simuPOP::Individual const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual___ne__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual___ne__" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual___ne__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual___ne__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  {
    try
    {
      result = (bool)((simuPOP::Individual const *)arg1)->operator !=((simuPOP::Individual const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Individual___cmp__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Individual *arg1 = (simuPOP::Individual *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  int result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Individual___cmp__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Individual___cmp__" "', argument " "1"" of type '" "simuPOP::Individual const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Individual * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Individual___cmp__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Individual___cmp__" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  {
    try
    {
      result = (int)((simuPOP::Individual const *)arg1)->__cmp__((simuPOP::Individual const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Individual_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Individual, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Individual_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_vspID__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::vspID *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try
    {
      result = (simuPOP::vspID *)new simuPOP::vspID(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__vspID, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_vspID__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  size_t arg1 = (size_t) InvalidValue ;
  size_t arg2 = (size_t) InvalidValue ;
  bool arg3 = (bool) false ;
  bool arg4 = (bool) false ;
  string const &arg5_defvalue = std::string() ;
  string *arg5 = (string *) &arg5_defvalue ;
  string const &arg6_defvalue = std::string() ;
  string *arg6 = (string *) &arg6_defvalue ;
  size_t val1 ;
  int ecode1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  int res6 = SWIG_OLDOBJ ;
  simuPOP::vspID *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 6)) SWIG_fail;
  if (swig_obj[0]) {
    ecode1 = SWIG_AsVal_size_t(swig_obj[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_vspID" "', argument " "1"" of type '" "size_t""'");
    } 
    arg1 = static_cast< size_t >(val1);
  }
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_vspID" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_bool(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_vspID" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  if (swig_obj[3]) {
    ecode4 = SWIG_AsVal_bool(swig_obj[3], &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_vspID" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
  }
  if (swig_obj[4]) {
    {
      std::string *ptr = (std::string *)0;
      res5 = SWIG_AsPtr_std_string(swig_obj[4], &ptr);
      if (!SWIG_IsOK(res5)) {
        SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_vspID" "', argument " "5"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vspID" "', argument " "5"" of type '" "string const &""'"); 
      }
      arg5 = ptr;
    }
  }
  if (swig_obj[5]) {
    {
      std::string *ptr = (std::string *)0;
      res6 = SWIG_AsPtr_std_string(swig_obj[5], &ptr);
      if (!SWIG_IsOK(res6)) {
        SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_vspID" "', argument " "6"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_vspID" "', argument " "6"" of type '" "string const &""'"); 
      }
      arg6 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::vspID *)new simuPOP::vspID(arg1,arg2,arg3,arg4,(string const &)*arg5,(string const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__vspID, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_vspID(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_vspID",0,6,argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 6)) {
    int _v = 0;
    if (argc > 0) {
      {
        {
          int res = SWIG_AsVal_size_t(argv[0], NULL);
          _v = SWIG_CheckState(res);
        }
      }
      if (!_v) goto check_1;
    }
    return _wrap_new_vspID__SWIG_1(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_vspID__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_vspID'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::vspID::vspID(PyObject *)\n"
    "    simuPOP::vspID::vspID(size_t,size_t,bool,bool,string const &,string const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_vspID(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::vspID *arg1 = (simuPOP::vspID *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__vspID, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_vspID" "', argument " "1"" of type '" "simuPOP::vspID *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::vspID * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vspID___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::vspID *arg1 = (simuPOP::vspID *) 0 ;
  simuPOP::vspID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:vspID___eq__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__vspID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vspID___eq__" "', argument " "1"" of type '" "simuPOP::vspID const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::vspID * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vspID___eq__" "', argument " "2"" of type '" "simuPOP::vspID const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vspID___eq__" "', argument " "2"" of type '" "simuPOP::vspID const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::vspID * >(argp2);
  {
    try
    {
      result = (bool)((simuPOP::vspID const *)arg1)->operator ==((simuPOP::vspID const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_vspID_resolve(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::vspID *arg1 = (simuPOP::vspID *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  simuPOP::vspID result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:vspID_resolve",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__vspID, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vspID_resolve" "', argument " "1"" of type '" "simuPOP::vspID const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::vspID * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "vspID_resolve" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "vspID_resolve" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = ((simuPOP::vspID const *)arg1)->resolve((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::vspID(static_cast< const simuPOP::vspID& >(result))), SWIGTYPE_p_simuPOP__vspID, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *vspID_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__vspID, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *vspID_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap___lshift__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  ostream *arg1 = 0 ;
  simuPOP::vspID *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "out",(char *) "vsp", NULL 
  };
  ostream *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:__lshift__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ostream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "__lshift__" "', argument " "1"" of type '" "ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "1"" of type '" "ostream &""'"); 
  }
  arg1 = reinterpret_cast< ostream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "__lshift__" "', argument " "2"" of type '" "simuPOP::vspID const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "__lshift__" "', argument " "2"" of type '" "simuPOP::vspID const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::vspID * >(argp2);
  {
    try
    {
      result = (ostream *) &simuPOP::operator <<(*arg1,(simuPOP::vspID const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ostream, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_subPopList(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "obj", NULL 
  };
  simuPOP::subPopList *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_subPopList",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  {
    try
    {
      result = (simuPOP::subPopList *)new simuPOP::subPopList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__subPopList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_subPopList___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__subPopList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subPopList___len__" "', argument " "1"" of type '" "simuPOP::subPopList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  {
    try
    {
      result = ((simuPOP::subPopList const *)arg1)->__len__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_subPopList_push_back(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  simuPOP::vspID arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:subPopList_push_back",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__subPopList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subPopList_push_back" "', argument " "1"" of type '" "simuPOP::subPopList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "subPopList_push_back" "', argument " "2"" of type '" "simuPOP::vspID const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "subPopList_push_back" "', argument " "2"" of type '" "simuPOP::vspID const""'");
    } else {
      simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try
    {
      (arg1)->push_back(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_subPopList_begin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::subPopList::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__subPopList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subPopList_begin" "', argument " "1"" of type '" "simuPOP::subPopList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  {
    try
    {
      result = (arg1)->begin();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const simuPOP::subPopList::iterator & >(result)),
    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_subPopList_end(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::subPopList::iterator result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__subPopList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subPopList_end" "', argument " "1"" of type '" "simuPOP::subPopList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  {
    try
    {
      result = (arg1)->end();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const simuPOP::subPopList::iterator & >(result)),
    swig::SwigPyIterator::descriptor(),SWIG_POINTER_OWN);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_subPopList_expandFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  simuPOP::subPopList result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:subPopList_expandFrom",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__subPopList, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "subPopList_expandFrom" "', argument " "1"" of type '" "simuPOP::subPopList const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "subPopList_expandFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "subPopList_expandFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = ((simuPOP::subPopList const *)arg1)->expandFrom((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::subPopList(static_cast< const simuPOP::subPopList& >(result))), SWIGTYPE_p_simuPOP__subPopList, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_subPopList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__subPopList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_subPopList" "', argument " "1"" of type '" "simuPOP::subPopList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *subPopList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__subPopList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *subPopList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_BaseVspSplitter_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseVspSplitter *arg1 = (simuPOP::BaseVspSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::BaseVspSplitter *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseVspSplitter_clone" "', argument " "1"" of type '" "simuPOP::BaseVspSplitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp1);
  {
    try
    {
      result = (simuPOP::BaseVspSplitter *)((simuPOP::BaseVspSplitter const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BaseVspSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseVspSplitter *arg1 = (simuPOP::BaseVspSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseVspSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BaseVspSplitter" "', argument " "1"" of type '" "simuPOP::BaseVspSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseVspSplitter_numVirtualSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseVspSplitter *arg1 = (simuPOP::BaseVspSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseVspSplitter_numVirtualSubPop" "', argument " "1"" of type '" "simuPOP::BaseVspSplitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp1);
  {
    try
    {
      result = ((simuPOP::BaseVspSplitter const *)arg1)->numVirtualSubPop();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseVspSplitter_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BaseVspSplitter *arg1 = (simuPOP::BaseVspSplitter *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "vsp", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:BaseVspSplitter_name",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseVspSplitter_name" "', argument " "1"" of type '" "simuPOP::BaseVspSplitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BaseVspSplitter_name" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::BaseVspSplitter const *)arg1)->name(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseVspSplitter_vspByName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BaseVspSplitter *arg1 = (simuPOP::BaseVspSplitter *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:BaseVspSplitter_vspByName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseVspSplitter_vspByName" "', argument " "1"" of type '" "simuPOP::BaseVspSplitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BaseVspSplitter_vspByName" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BaseVspSplitter_vspByName" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = ((simuPOP::BaseVspSplitter const *)arg1)->vspByName((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *BaseVspSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BaseVspSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CombinedSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::vectorsplitter const &arg1_defvalue = simuPOP::vectorsplitter() ;
  simuPOP::vectorsplitter *arg1 = (simuPOP::vectorsplitter *) &arg1_defvalue ;
  simuPOP::intMatrix const &arg2_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg2 = (simuPOP::intMatrix *) &arg2_defvalue ;
  simuPOP::stringList const &arg3_defvalue = vectorstr() ;
  simuPOP::stringList *arg3 = (simuPOP::stringList *) &arg3_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "splitters",(char *) "vspMap",(char *) "names", NULL 
  };
  simuPOP::CombinedSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOO:new_CombinedSplitter",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  if (obj0) {
    {
      std::vector< simuPOP::BaseVspSplitter*,std::allocator< simuPOP::BaseVspSplitter * > > *ptr = (std::vector< simuPOP::BaseVspSplitter*,std::allocator< simuPOP::BaseVspSplitter * > > *)0;
      res1 = swig::asptr(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CombinedSplitter" "', argument " "1"" of type '" "simuPOP::vectorsplitter const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CombinedSplitter" "', argument " "1"" of type '" "simuPOP::vectorsplitter const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CombinedSplitter" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CombinedSplitter" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::intMatrix * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_CombinedSplitter" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CombinedSplitter" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringList * >(argp3);
  }
  {
    try
    {
      result = (simuPOP::CombinedSplitter *)new simuPOP::CombinedSplitter((simuPOP::vectorsplitter const &)*arg1,(simuPOP::intMatrix const &)*arg2,(simuPOP::stringList const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__CombinedSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CombinedSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::CombinedSplitter *arg1 = (simuPOP::CombinedSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__CombinedSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CombinedSplitter" "', argument " "1"" of type '" "simuPOP::CombinedSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::CombinedSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CombinedSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__CombinedSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CombinedSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ProductSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::vectorsplitter const &arg1_defvalue = simuPOP::vectorsplitter() ;
  simuPOP::vectorsplitter *arg1 = (simuPOP::vectorsplitter *) &arg1_defvalue ;
  simuPOP::stringList const &arg2_defvalue = vectorstr() ;
  simuPOP::stringList *arg2 = (simuPOP::stringList *) &arg2_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "splitters",(char *) "names", NULL 
  };
  simuPOP::ProductSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:new_ProductSplitter",kwnames,&obj0,&obj1)) SWIG_fail;
  if (obj0) {
    {
      std::vector< simuPOP::BaseVspSplitter*,std::allocator< simuPOP::BaseVspSplitter * > > *ptr = (std::vector< simuPOP::BaseVspSplitter*,std::allocator< simuPOP::BaseVspSplitter * > > *)0;
      res1 = swig::asptr(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ProductSplitter" "', argument " "1"" of type '" "simuPOP::vectorsplitter const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ProductSplitter" "', argument " "1"" of type '" "simuPOP::vectorsplitter const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ProductSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ProductSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  }
  {
    try
    {
      result = (simuPOP::ProductSplitter *)new simuPOP::ProductSplitter((simuPOP::vectorsplitter const &)*arg1,(simuPOP::stringList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ProductSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ProductSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ProductSplitter *arg1 = (simuPOP::ProductSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ProductSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ProductSplitter" "', argument " "1"" of type '" "simuPOP::ProductSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ProductSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ProductSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ProductSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ProductSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SexSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringList const &arg1_defvalue = vectorstr() ;
  simuPOP::stringList *arg1 = (simuPOP::stringList *) &arg1_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "names", NULL 
  };
  simuPOP::SexSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_SexSplitter",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SexSplitter" "', argument " "1"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SexSplitter" "', argument " "1"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringList * >(argp1);
  }
  {
    try
    {
      result = (simuPOP::SexSplitter *)new simuPOP::SexSplitter((simuPOP::stringList const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SexSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SexSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SexSplitter *arg1 = (simuPOP::SexSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SexSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SexSplitter" "', argument " "1"" of type '" "simuPOP::SexSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SexSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SexSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SexSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SexSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_AffectionSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringList const &arg1_defvalue = vectorstr() ;
  simuPOP::stringList *arg1 = (simuPOP::stringList *) &arg1_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "names", NULL 
  };
  simuPOP::AffectionSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_AffectionSplitter",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AffectionSplitter" "', argument " "1"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AffectionSplitter" "', argument " "1"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringList * >(argp1);
  }
  {
    try
    {
      result = (simuPOP::AffectionSplitter *)new simuPOP::AffectionSplitter((simuPOP::stringList const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__AffectionSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AffectionSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::AffectionSplitter *arg1 = (simuPOP::AffectionSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__AffectionSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AffectionSplitter" "', argument " "1"" of type '" "simuPOP::AffectionSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::AffectionSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AffectionSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__AffectionSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *AffectionSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InfoSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 ;
  simuPOP::floatList const &arg2_defvalue = vectorf() ;
  simuPOP::floatList *arg2 = (simuPOP::floatList *) &arg2_defvalue ;
  simuPOP::floatList const &arg3_defvalue = vectorf() ;
  simuPOP::floatList *arg3 = (simuPOP::floatList *) &arg3_defvalue ;
  simuPOP::floatMatrix const &arg4_defvalue = simuPOP::floatMatrix() ;
  simuPOP::floatMatrix *arg4 = (simuPOP::floatMatrix *) &arg4_defvalue ;
  simuPOP::stringList const &arg5_defvalue = vectorstr() ;
  simuPOP::stringList *arg5 = (simuPOP::stringList *) &arg5_defvalue ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "field",(char *) "values",(char *) "cutoff",(char *) "ranges",(char *) "names", NULL 
  };
  simuPOP::InfoSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOO:new_InfoSplitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_InfoSplitter" "', argument " "1"" of type '" "string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_InfoSplitter" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoSplitter" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::floatList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InfoSplitter" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoSplitter" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__floatMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_InfoSplitter" "', argument " "4"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoSplitter" "', argument " "4"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::floatMatrix * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_InfoSplitter" "', argument " "5"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoSplitter" "', argument " "5"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringList * >(argp5);
  }
  {
    try
    {
      result = (simuPOP::InfoSplitter *)new simuPOP::InfoSplitter(arg1,(simuPOP::floatList const &)*arg2,(simuPOP::floatList const &)*arg3,(simuPOP::floatMatrix const &)*arg4,(simuPOP::stringList const &)*arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InfoSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InfoSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InfoSplitter *arg1 = (simuPOP::InfoSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InfoSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfoSplitter" "', argument " "1"" of type '" "simuPOP::InfoSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InfoSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InfoSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InfoSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InfoSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ProportionSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  vectorf const &arg1_defvalue = vectorf() ;
  vectorf *arg1 = (vectorf *) &arg1_defvalue ;
  simuPOP::stringList const &arg2_defvalue = vectorstr() ;
  simuPOP::stringList *arg2 = (simuPOP::stringList *) &arg2_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "proportions",(char *) "names", NULL 
  };
  simuPOP::ProportionSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:new_ProportionSplitter",kwnames,&obj0,&obj1)) SWIG_fail;
  if (obj0) {
    {
      std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
      res1 = swig::asptr(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ProportionSplitter" "', argument " "1"" of type '" "vectorf const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ProportionSplitter" "', argument " "1"" of type '" "vectorf const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ProportionSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ProportionSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  }
  {
    try
    {
      result = (simuPOP::ProportionSplitter *)new simuPOP::ProportionSplitter((vectorf const &)*arg1,(simuPOP::stringList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ProportionSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ProportionSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ProportionSplitter *arg1 = (simuPOP::ProportionSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ProportionSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ProportionSplitter" "', argument " "1"" of type '" "simuPOP::ProportionSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ProportionSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ProportionSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ProportionSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ProportionSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RangeSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::intMatrix *arg1 = 0 ;
  simuPOP::stringList const &arg2_defvalue = vectorstr() ;
  simuPOP::stringList *arg2 = (simuPOP::stringList *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "ranges",(char *) "names", NULL 
  };
  simuPOP::RangeSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:new_RangeSplitter",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RangeSplitter" "', argument " "1"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RangeSplitter" "', argument " "1"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::intMatrix * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RangeSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RangeSplitter" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  }
  {
    try
    {
      result = (simuPOP::RangeSplitter *)new simuPOP::RangeSplitter((simuPOP::intMatrix const &)*arg1,(simuPOP::stringList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RangeSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RangeSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RangeSplitter *arg1 = (simuPOP::RangeSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RangeSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RangeSplitter" "', argument " "1"" of type '" "simuPOP::RangeSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RangeSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RangeSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RangeSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RangeSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_GenotypeSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  simuPOP::intMatrix *arg2 = 0 ;
  bool arg3 = (bool) false ;
  simuPOP::stringList const &arg4_defvalue = vectorstr() ;
  simuPOP::stringList *arg4 = (simuPOP::stringList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "alleles",(char *) "phase",(char *) "names", NULL 
  };
  simuPOP::GenotypeSplitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:new_GenotypeSplitter",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenotypeSplitter" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenotypeSplitter" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_GenotypeSplitter" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenotypeSplitter" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::intMatrix * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_GenotypeSplitter" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_GenotypeSplitter" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenotypeSplitter" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringList * >(argp4);
  }
  {
    try
    {
      result = (simuPOP::GenotypeSplitter *)new simuPOP::GenotypeSplitter((simuPOP::lociList const &)*arg1,(simuPOP::intMatrix const &)*arg2,arg3,(simuPOP::stringList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__GenotypeSplitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GenotypeSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenotypeSplitter *arg1 = (simuPOP::GenotypeSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenotypeSplitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenotypeSplitter" "', argument " "1"" of type '" "simuPOP::GenotypeSplitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenotypeSplitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenotypeSplitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__GenotypeSplitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenotypeSplitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_pyIndIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  SwigValueWrapper< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > arg1 ;
  SwigValueWrapper< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > arg2 ;
  bool arg3 ;
  simuPOP::vspFunctor arg4 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end",(char *) "allInds",(char *) "func", NULL 
  };
  simuPOP::pyIndIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOO:new_pyIndIterator",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_pyIndIterator" "', argument " "1"" of type '" "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyIndIterator" "', argument " "1"" of type '" "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator const""'");
    } else {
      vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator * temp = reinterpret_cast< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_pyIndIterator" "', argument " "2"" of type '" "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyIndIterator" "', argument " "2"" of type '" "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator const""'");
    } else {
      vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator * temp = reinterpret_cast< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_pyIndIterator" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__vspFunctor,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_pyIndIterator" "', argument " "4"" of type '" "simuPOP::vspFunctor""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyIndIterator" "', argument " "4"" of type '" "simuPOP::vspFunctor""'");
    } else {
      simuPOP::vspFunctor * temp = reinterpret_cast< simuPOP::vspFunctor * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    try
    {
      result = (simuPOP::pyIndIterator *)new simuPOP::pyIndIterator(arg1,arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__pyIndIterator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_pyIndIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyIndIterator *arg1 = (simuPOP::pyIndIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyIndIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_pyIndIterator" "', argument " "1"" of type '" "simuPOP::pyIndIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyIndIterator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyIndIterator___iter__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyIndIterator *arg1 = (simuPOP::pyIndIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< simuPOP::pyIndIterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyIndIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyIndIterator___iter__" "', argument " "1"" of type '" "simuPOP::pyIndIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyIndIterator * >(argp1);
  {
    try
    {
      result = (arg1)->__iter__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyIndIterator(static_cast< const simuPOP::pyIndIterator& >(result))), SWIGTYPE_p_simuPOP__pyIndIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyIndIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyIndIterator *arg1 = (simuPOP::pyIndIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Individual *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyIndIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyIndIterator_next" "', argument " "1"" of type '" "simuPOP::pyIndIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyIndIterator * >(argp1);
  {
    try
    {
      result = (simuPOP::Individual *) &(arg1)->next();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyIndIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyIndIterator *arg1 = (simuPOP::pyIndIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Individual *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyIndIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyIndIterator___next__" "', argument " "1"" of type '" "simuPOP::pyIndIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyIndIterator * >(argp1);
  {
    try
    {
      result = (simuPOP::Individual *) &(arg1)->__next__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *pyIndIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__pyIndIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *pyIndIterator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Population(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::uintList const &arg1_defvalue = vectoru() ;
  simuPOP::uintList *arg1 = (simuPOP::uintList *) &arg1_defvalue ;
  float arg2 = (float) 2 ;
  simuPOP::uintList const &arg3_defvalue = vectoru() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = vectoru() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  simuPOP::floatList const &arg5_defvalue = vectorf() ;
  simuPOP::floatList *arg5 = (simuPOP::floatList *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  simuPOP::stringList const &arg7_defvalue = vectorstr() ;
  simuPOP::stringList *arg7 = (simuPOP::stringList *) &arg7_defvalue ;
  simuPOP::stringMatrix const &arg8_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg8 = (simuPOP::stringMatrix *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "size",(char *) "ploidy",(char *) "loci",(char *) "chromTypes",(char *) "lociPos",(char *) "ancGen",(char *) "chromNames",(char *) "alleleNames",(char *) "lociNames",(char *) "subPopNames",(char *) "infoFields", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_Population",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Population" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::uintList * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_float(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Population" "', argument " "2"" of type '" "float""'");
    } 
    arg2 = static_cast< float >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Population" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_Population" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Population" "', argument " "5"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "5"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::floatList * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Population" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Population" "', argument " "7"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "7"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_Population" "', argument " "8"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "8"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringMatrix * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_Population" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_Population" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_Population" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Population" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::Population *)new simuPOP::Population((simuPOP::uintList const &)*arg1,arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4,(simuPOP::floatList const &)*arg5,arg6,(simuPOP::stringList const &)*arg7,(simuPOP::stringMatrix const &)*arg8,(simuPOP::stringList const &)*arg9,(simuPOP::stringList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Population *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_clone" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = (simuPOP::Population *)((simuPOP::Population const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_swap",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_swap" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_swap" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_swap" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->swap(*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Population(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Population" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_virtualSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::BaseVspSplitter *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_virtualSplitter" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = (simuPOP::BaseVspSplitter *)((simuPOP::Population const *)arg1)->virtualSplitter();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setVirtualSplitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::BaseVspSplitter *arg2 = (simuPOP::BaseVspSplitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "splitter", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_setVirtualSplitter",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setVirtualSplitter" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_simuPOP__BaseVspSplitter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setVirtualSplitter" "', argument " "2"" of type '" "simuPOP::BaseVspSplitter *""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::BaseVspSplitter * >(argp2);
  {
    try
    {
      (arg1)->setVirtualSplitter(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_numVirtualSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_numVirtualSubPop" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->numVirtualSubPop();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_activateVirtualSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_activateVirtualSubPop",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_activateVirtualSubPop" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_activateVirtualSubPop" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_activateVirtualSubPop" "', argument " "2"" of type '" "simuPOP::vspID""'");
    } else {
      simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try
    {
      ((simuPOP::Population const *)arg1)->activateVirtualSubPop(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_deactivateVirtualSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_deactivateVirtualSubPop",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_deactivateVirtualSubPop" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_deactivateVirtualSubPop" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      ((simuPOP::Population const *)arg1)->deactivateVirtualSubPop(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population___cmp__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  int result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population___cmp__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population___cmp__" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population___cmp__" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population___cmp__" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = (int)((simuPOP::Population const *)arg1)->__cmp__((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_fitGenoStru(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "stru", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_fitGenoStru",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_fitGenoStru" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_fitGenoStru" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      (arg1)->fitGenoStru(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setSubPopStru(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  vectoru *arg2 = 0 ;
  vectorstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "newSubPopSizes",(char *) "newSubPopNames", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_setSubPopStru",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setSubPopStru" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    std::vector< size_t,std::allocator< size_t > > *ptr = (std::vector< size_t,std::allocator< size_t > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setSubPopStru" "', argument " "2"" of type '" "vectoru const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setSubPopStru" "', argument " "2"" of type '" "vectoru const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
    res3 = swig::asptr(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_setSubPopStru" "', argument " "3"" of type '" "vectorstr const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setSubPopStru" "', argument " "3"" of type '" "vectorstr const &""'"); 
    }
    arg3 = ptr;
  }
  {
    try
    {
      (arg1)->setSubPopStru((vectoru const &)*arg2,(vectorstr const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_numSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_numSubPop" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->numSubPop();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  int arg3 = (int) -1 ;
  SexChoice arg4 = (SexChoice) ANY_SEX ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop",(char *) "ancGen",(char *) "sex", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOO:Population_subPopSize",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopSize" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_subPopSize" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_subPopSize" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_subPopSize" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Population_subPopSize" "', argument " "4"" of type '" "SexChoice""'");
    } 
    arg4 = static_cast< SexChoice >(val4);
  }
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopSize(arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopByName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_subPopByName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopByName" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_subPopByName" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_subPopByName" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopByName((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_subPopName",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopName" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_subPopName" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_subPopName" "', argument " "2"" of type '" "simuPOP::vspID""'");
    } else {
      simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopName(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopNames(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  vectorstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopNames" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopNames();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setSubPopName(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string *arg2 = 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "name",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_setSubPopName",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setSubPopName" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setSubPopName" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setSubPopName" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_setSubPopName" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      (arg1)->setSubPopName((string const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopSizes(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  int arg2 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ancGen", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_subPopSizes",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopSizes" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_subPopSizes" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopSizes(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_popSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  int arg2 = (int) -1 ;
  SexChoice arg3 = (SexChoice) ANY_SEX ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ancGen",(char *) "sex", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Population_popSize",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_popSize" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_popSize" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_popSize" "', argument " "3"" of type '" "SexChoice""'");
    } 
    arg3 = static_cast< SexChoice >(val3);
  }
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->popSize(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_absIndIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "subPop", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_absIndIndex",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_absIndIndex" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_absIndIndex" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_absIndIndex" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->absIndIndex(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopIndPair(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx", NULL 
  };
  pairu result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_subPopIndPair",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopIndPair" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_subPopIndPair" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopIndPair(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::pair< size_t,size_t > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopBegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_subPopBegin",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopBegin" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_subPopBegin" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopBegin(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_subPopEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_subPopEnd",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_subPopEnd" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_subPopEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->subPopEnd(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_individual__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  simuPOP::Individual *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_individual" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_individual" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  if (swig_obj[2]) {
    {
      res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_individual" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_individual" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (simuPOP::Individual *) &((simuPOP::Population const *)arg1)->individual(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_individual__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  double arg2 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  simuPOP::Individual *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_individual" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_double(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_individual" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (swig_obj[2]) {
    {
      res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_individual" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_individual" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (simuPOP::Individual *) &(arg1)->individual(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_individual(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"Population_individual",0,3,argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v = 0;
    {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
    }
    if (!_v) goto check_1;
    return _wrap_Population_individual__SWIG_0(self, argc, argv);
  }
check_1:
  
  if ((argc >= 2) && (argc <= 3)) {
    int _v = 0;
    {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
    }
    if (!_v) goto check_2;
    return _wrap_Population_individual__SWIG_1(self, argc, argv);
  }
check_2:
  
  if ((argc >= 2) && (argc <= 3)) {
    int _v = 0;
    {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
    }
    if (!_v) goto check_3;
    return _wrap_Population_individual__SWIG_0(self, argc, argv);
  }
check_3:
  
  if ((argc >= 2) && (argc <= 3)) {
    return _wrap_Population_individual__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Population_individual'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::Population::individual(size_t,simuPOP::vspID) const\n"
    "    simuPOP::Population::individual(double,simuPOP::vspID)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Population_indByID(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  double arg2 ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  string const &arg4_defvalue = "ind_id" ;
  string *arg4 = (string *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "id",(char *) "ancGens",(char *) "idField", NULL 
  };
  simuPOP::Individual *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Population_indByID",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_indByID" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_indByID" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_indByID" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_indByID" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_indByID" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_indByID" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::Individual *) &(arg1)->indByID(arg2,(simuPOP::uintList const &)*arg3,(string const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_ancestor(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  double arg2 ;
  ssize_t arg3 ;
  simuPOP::vspID arg4 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "gen",(char *) "subPop", NULL 
  };
  simuPOP::Individual *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|O:Population_ancestor",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_ancestor" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_ancestor" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_ancestor" "', argument " "3"" of type '" "ssize_t""'");
  } 
  arg3 = static_cast< ssize_t >(val3);
  if (obj3) {
    {
      res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_ancestor" "', argument " "4"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_ancestor" "', argument " "4"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp4);
        arg4 = *temp;
        if (SWIG_IsNewObj(res4)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (simuPOP::Individual *) &(arg1)->ancestor(arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_individuals(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  SwigValueWrapper< simuPOP::pyIndIterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_individuals",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_individuals" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_individuals" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_individuals" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (arg1)->individuals(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyIndIterator(static_cast< const simuPOP::pyIndIterator& >(result))), SWIGTYPE_p_simuPOP__pyIndIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_indIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  SwigValueWrapper< simuPOP::IndividualIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_pointer,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_reference > > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_indIterator",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_indIterator" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_indIterator" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->indIterator(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::ConstIndIterator(static_cast< const simuPOP::ConstIndIterator& >(result))), SWIGTYPE_p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_rawIndEnd__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  SwigValueWrapper< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_rawIndEnd" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->rawIndEnd();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::ConstRawIndIterator(static_cast< const simuPOP::ConstRawIndIterator& >(result))), SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_rawIndBegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  SwigValueWrapper< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_rawIndBegin",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_rawIndBegin" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_rawIndBegin" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->rawIndBegin(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::ConstRawIndIterator(static_cast< const simuPOP::ConstRawIndIterator& >(result))), SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_rawIndEnd__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  SwigValueWrapper< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_rawIndEnd" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_rawIndEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->rawIndEnd(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::ConstRawIndIterator(static_cast< const simuPOP::ConstRawIndIterator& >(result))), SWIGTYPE_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_rawIndEnd(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"Population_rawIndEnd",0,2,argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    return _wrap_Population_rawIndEnd__SWIG_0(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_Population_rawIndEnd__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'Population_rawIndEnd'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::Population::rawIndEnd() const\n"
    "    simuPOP::Population::rawIndEnd(size_t) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Population_alleleIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "locus",(char *) "subPop", NULL 
  };
  SwigValueWrapper< simuPOP::CombinedAlleleIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,std::vector< unsigned long,std::allocator< unsigned long > >::const_iterator,unsigned long const & > > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_alleleIterator",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_alleleIterator" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_alleleIterator" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_alleleIterator" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->alleleIterator(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::ConstIndAlleleIterator(static_cast< const simuPOP::ConstIndAlleleIterator& >(result))), SWIGTYPE_p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_indGenoBegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ind",(char *) "subPop", NULL 
  };
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_indGenoBegin",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_indGenoBegin" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_indGenoBegin" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_indGenoBegin" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->indGenoBegin(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new GenoIterator(static_cast< const GenoIterator& >(result))), SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_indGenoEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ind",(char *) "subPop", NULL 
  };
  SwigValueWrapper< std::vector< unsigned long,std::allocator< unsigned long > >::iterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_indGenoEnd",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_indGenoEnd" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_indGenoEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_indGenoEnd" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->indGenoEnd(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new GenoIterator(static_cast< const GenoIterator& >(result))), SWIGTYPE_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_genotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_genotype",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_genotype" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_genotype" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_genotype" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (PyObject *)(arg1)->genotype(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_mutants(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  SwigValueWrapper< simuPOP::pyMutantIterator > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_mutants",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_mutants" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_mutants" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_mutants" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (arg1)->mutants(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyMutantIterator(static_cast< const simuPOP::pyMutantIterator& >(result))), SWIGTYPE_p_simuPOP__pyMutantIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_lineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_lineage",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_lineage" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_lineage" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_lineage" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (PyObject *)(arg1)->lineage(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "geno",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_setGenotype",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setGenotype" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    {
      res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_setGenotype" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setGenotype" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      (arg1)->setGenotype((simuPOP::uintList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "geno",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_setLineage",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setLineage" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setLineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setLineage" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    {
      res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_setLineage" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setLineage" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      (arg1)->setLineage((simuPOP::uintList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_sortIndividuals(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "infoFields",(char *) "reverse", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_sortIndividuals",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_sortIndividuals" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_sortIndividuals" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_sortIndividuals" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_sortIndividuals" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      (arg1)->sortIndividuals((simuPOP::stringList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setSubPopByIndInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "field", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_setSubPopByIndInfo",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setSubPopByIndInfo" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setSubPopByIndInfo" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setSubPopByIndInfo" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      (arg1)->setSubPopByIndInfo((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_splitSubPop(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  vectorf *arg3 = 0 ;
  vectorstr const &arg4_defvalue = vectorstr() ;
  vectorstr *arg4 = (vectorstr *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop",(char *) "sizes",(char *) "names", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|O:Population_splitSubPop",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_splitSubPop" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_splitSubPop" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res3 = swig::asptr(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_splitSubPop" "', argument " "3"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_splitSubPop" "', argument " "3"" of type '" "vectorf const &""'"); 
    }
    arg3 = ptr;
  }
  if (obj3) {
    {
      std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
      res4 = swig::asptr(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_splitSubPop" "', argument " "4"" of type '" "vectorstr const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_splitSubPop" "', argument " "4"" of type '" "vectorstr const &""'"); 
      }
      arg4 = ptr;
    }
  }
  {
    try
    {
      result = (arg1)->splitSubPop(arg2,(vectorf const &)*arg3,(vectorstr const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_removeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::subPopList *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPops", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_removeSubPops",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_removeSubPops" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_removeSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::subPopList * >(argp2);
  {
    try
    {
      (arg1)->removeSubPops((simuPOP::subPopList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_removeIndividuals(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList const &arg2_defvalue = vectoru() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::floatList const &arg3_defvalue = vectorf() ;
  simuPOP::floatList *arg3 = (simuPOP::floatList *) &arg3_defvalue ;
  string const &arg4_defvalue = "ind_id" ;
  string *arg4 = (string *) &arg4_defvalue ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "indexes",(char *) "IDs",(char *) "idField",(char *) "filter", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOO:Population_removeIndividuals",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_removeIndividuals" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_removeIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_removeIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatList * >(argp3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_removeIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    arg5 = obj4;
  }
  {
    try
    {
      (arg1)->removeIndividuals((simuPOP::uintList const &)*arg2,(simuPOP::floatList const &)*arg3,(string const &)*arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_mergeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  string const &arg3_defvalue = "" ;
  string *arg3 = (string *) &arg3_defvalue ;
  int arg4 = (int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPops",(char *) "name",(char *) "toSubPop", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOO:Population_mergeSubPops",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_mergeSubPops" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_mergeSubPops" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_mergeSubPops" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_mergeSubPops" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_mergeSubPops" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Population_mergeSubPops" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  {
    try
    {
      result = (arg1)->mergeSubPops((simuPOP::uintList const &)*arg2,(string const &)*arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addIndFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_addIndFrom",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addIndFrom" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addIndFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addIndFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->addIndFrom((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addChromFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_addChromFrom",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addChromFrom" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addChromFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addChromFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->addChromFrom((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addLociFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop",(char *) "byName", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_addLociFrom",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addLociFrom" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addLociFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addLociFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_addLociFrom" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      (arg1)->addLociFrom((simuPOP::Population const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addChrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::floatList *arg2 = 0 ;
  simuPOP::stringList const &arg3_defvalue = vectorstr() ;
  simuPOP::stringList *arg3 = (simuPOP::stringList *) &arg3_defvalue ;
  string const &arg4_defvalue = std::string() ;
  string *arg4 = (string *) &arg4_defvalue ;
  simuPOP::stringMatrix const &arg5_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg5 = (simuPOP::stringMatrix *) &arg5_defvalue ;
  size_t arg6 = (size_t) AUTOSOME ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "lociPos",(char *) "lociNames",(char *) "chromName",(char *) "alleleNames",(char *) "chromType", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOO:Population_addChrom",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addChrom" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addChrom" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addChrom" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::floatList * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_addChrom" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addChrom" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringList * >(argp3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_addChrom" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addChrom" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Population_addChrom" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addChrom" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringMatrix * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_size_t(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Population_addChrom" "', argument " "6"" of type '" "size_t""'");
    } 
    arg6 = static_cast< size_t >(val6);
  }
  {
    try
    {
      (arg1)->addChrom((simuPOP::floatList const &)*arg2,(simuPOP::stringList const &)*arg3,(string const &)*arg4,(simuPOP::stringMatrix const &)*arg5,arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addLoci(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  simuPOP::floatList *arg3 = 0 ;
  simuPOP::stringList const &arg4_defvalue = vectorstr() ;
  simuPOP::stringList *arg4 = (simuPOP::stringList *) &arg4_defvalue ;
  simuPOP::stringMatrix const &arg5_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg5 = (simuPOP::stringMatrix *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "chrom",(char *) "pos",(char *) "lociNames",(char *) "alleleNames", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|OO:Population_addLoci",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addLoci" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addLoci" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addLoci" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_addLoci" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addLoci" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::floatList * >(argp3);
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_addLoci" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addLoci" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Population_addLoci" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addLoci" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringMatrix * >(argp5);
  }
  {
    try
    {
      result = (arg1)->addLoci((simuPOP::uintList const &)*arg2,(simuPOP::floatList const &)*arg3,(simuPOP::stringList const &)*arg4,(simuPOP::stringMatrix const &)*arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_resize(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "sizes",(char *) "propagate", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_resize",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_resize" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_resize" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_resize" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_resize" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      (arg1)->resize((simuPOP::uintList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_extractSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::subPopList const &arg2_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg2 = (simuPOP::subPopList *) &arg2_defvalue ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPops",(char *) "rearrange", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Population_extractSubPops",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_extractSubPops" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_extractSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_extractSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::subPopList * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_extractSubPops" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      result = (simuPOP::Population *) &((simuPOP::Population const *)arg1)->extractSubPops((simuPOP::subPopList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_extractIndividuals(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintList const &arg2_defvalue = vectoru() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::floatList const &arg3_defvalue = vectorf() ;
  simuPOP::floatList *arg3 = (simuPOP::floatList *) &arg3_defvalue ;
  string const &arg4_defvalue = "ind_id" ;
  string *arg4 = (string *) &arg4_defvalue ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "indexes",(char *) "IDs",(char *) "idField",(char *) "filter", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOO:Population_extractIndividuals",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_extractIndividuals" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_extractIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_extractIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_extractIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_extractIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatList * >(argp3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_extractIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_extractIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    arg5 = obj4;
  }
  {
    try
    {
      result = (simuPOP::Population *) &((simuPOP::Population const *)arg1)->extractIndividuals((simuPOP::uintList const &)*arg2,(simuPOP::floatList const &)*arg3,(string const &)*arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_removeLoci(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList(NULL) ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList(NULL) ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "loci",(char *) "keep", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Population_removeLoci",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_removeLoci" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_removeLoci" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeLoci" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_removeLoci" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeLoci" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  {
    try
    {
      (arg1)->removeLoci((simuPOP::lociList const &)*arg2,(simuPOP::lociList const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_recodeAlleles(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintListFunc *arg2 = 0 ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::stringMatrix const &arg4_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg4 = (simuPOP::stringMatrix *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "alleles",(char *) "loci",(char *) "alleleNames", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Population_recodeAlleles",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_recodeAlleles" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_recodeAlleles" "', argument " "2"" of type '" "simuPOP::uintListFunc const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_recodeAlleles" "', argument " "2"" of type '" "simuPOP::uintListFunc const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintListFunc * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_recodeAlleles" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_recodeAlleles" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_recodeAlleles" "', argument " "4"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_recodeAlleles" "', argument " "4"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringMatrix * >(argp4);
  }
  {
    try
    {
      (arg1)->recodeAlleles((simuPOP::uintListFunc const &)*arg2,(simuPOP::lociList const &)*arg3,(simuPOP::stringMatrix const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_push(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_push",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_push" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_push" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_push" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->push(*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_curAncestralGen(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_curAncestralGen" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = ((simuPOP::Population const *)arg1)->curAncestralGen();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_ancestralGens(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_ancestralGens" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    try
    {
      result = (int)((simuPOP::Population const *)arg1)->ancestralGens();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setIndInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::floatList *arg2 = 0 ;
  simuPOP::uintString *arg3 = 0 ;
  simuPOP::vspID arg4 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "values",(char *) "field",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|O:Population_setIndInfo",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setIndInfo" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setIndInfo" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setIndInfo" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::floatList * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintString,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_setIndInfo" "', argument " "3"" of type '" "simuPOP::uintString const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setIndInfo" "', argument " "3"" of type '" "simuPOP::uintString const &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::uintString * >(argp3);
  if (obj3) {
    {
      res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_setIndInfo" "', argument " "4"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setIndInfo" "', argument " "4"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp4);
        arg4 = *temp;
        if (SWIG_IsNewObj(res4)) delete temp;
      }
    }
  }
  {
    try
    {
      (arg1)->setIndInfo((simuPOP::floatList const &)*arg2,(simuPOP::uintString const &)*arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_infoBegin(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  simuPOP::vspID arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "vsp", NULL 
  };
  SwigValueWrapper< simuPOP::InformationIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_infoBegin",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_infoBegin" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_infoBegin" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_infoBegin" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_infoBegin" "', argument " "3"" of type '" "simuPOP::vspID""'");
    } else {
      simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try
    {
      result = (arg1)->infoBegin(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::IndInfoIterator(static_cast< const simuPOP::IndInfoIterator& >(result))), SWIGTYPE_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_infoEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  size_t arg2 ;
  simuPOP::vspID arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx",(char *) "vsp", NULL 
  };
  SwigValueWrapper< simuPOP::InformationIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:Population_infoEnd",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_infoEnd" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_infoEnd" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_infoEnd" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_infoEnd" "', argument " "3"" of type '" "simuPOP::vspID""'");
    } else {
      simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  {
    try
    {
      result = (arg1)->infoEnd(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::IndInfoIterator(static_cast< const simuPOP::IndInfoIterator& >(result))), SWIGTYPE_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_indInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::uintString *arg2 = 0 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "field",(char *) "subPop", NULL 
  };
  vectorf result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_indInfo",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_indInfo" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintString,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_indInfo" "', argument " "2"" of type '" "simuPOP::uintString const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_indInfo" "', argument " "2"" of type '" "simuPOP::uintString const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintString * >(argp2);
  if (obj2) {
    {
      res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_indInfo" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_indInfo" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (arg1)->indInfo((simuPOP::uintString const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< double,std::allocator< double > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_addInfoFields(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  double arg3 = (double) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "fields",(char *) "init", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_addInfoFields",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_addInfoFields" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_addInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_addInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_double(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_addInfoFields" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = static_cast< double >(val3);
  }
  {
    try
    {
      (arg1)->addInfoFields((simuPOP::stringList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setInfoFields(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  double arg3 = (double) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "fields",(char *) "init", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Population_setInfoFields",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setInfoFields" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_setInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_setInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_double(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Population_setInfoFields" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = static_cast< double >(val3);
  }
  {
    try
    {
      (arg1)->setInfoFields((simuPOP::stringList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_removeInfoFields(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "fields", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_removeInfoFields",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_removeInfoFields" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_removeInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_removeInfoFields" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  {
    try
    {
      (arg1)->removeInfoFields((simuPOP::stringList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_updateInfoFieldsFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  simuPOP::Population *arg3 = 0 ;
  simuPOP::stringList const &arg4_defvalue = vectorstr() ;
  simuPOP::stringList *arg4 = (simuPOP::stringList *) &arg4_defvalue ;
  simuPOP::uintList const &arg5_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg5 = (simuPOP::uintList *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "fields",(char *) "pop",(char *) "fromFields",(char *) "ancGens", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|OO:Population_updateInfoFieldsFrom",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_updateInfoFieldsFrom" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_updateInfoFieldsFrom" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_updateInfoFieldsFrom" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_updateInfoFieldsFrom" "', argument " "3"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_updateInfoFieldsFrom" "', argument " "3"" of type '" "simuPOP::Population const &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::Population * >(argp3);
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Population_updateInfoFieldsFrom" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_updateInfoFieldsFrom" "', argument " "4"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Population_updateInfoFieldsFrom" "', argument " "5"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_updateInfoFieldsFrom" "', argument " "5"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::uintList * >(argp5);
  }
  {
    try
    {
      (arg1)->updateInfoFieldsFrom((simuPOP::stringList const &)*arg2,(simuPOP::Population const &)*arg3,(simuPOP::stringList const &)*arg4,(simuPOP::uintList const &)*arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_setAncestralDepth(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "depth", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_setAncestralDepth",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_setAncestralDepth" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_setAncestralDepth" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try
    {
      (arg1)->setAncestralDepth(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_useAncestralGen(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  ssize_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "idx", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_useAncestralGen",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_useAncestralGen" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Population_useAncestralGen" "', argument " "2"" of type '" "ssize_t""'");
  } 
  arg2 = static_cast< ssize_t >(val2);
  {
    try
    {
      (arg1)->useAncestralGen(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "filename", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Population_save",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_save" "', argument " "1"" of type '" "simuPOP::Population const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_save" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_save" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      ((simuPOP::Population const *)arg1)->save((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_vars(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  simuPOP::vspID arg2 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPop", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_vars",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_vars" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_vars" "', argument " "2"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_vars" "', argument " "2"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (PyObject *)(arg1)->vars(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_evaluate(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  string const &arg3_defvalue = std::string() ;
  string *arg3 = (string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "expr",(char *) "stmts", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Population_evaluate",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_evaluate" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_evaluate" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_evaluate" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Population_evaluate" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_evaluate" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  {
    try
    {
      result = (PyObject *)(arg1)->evaluate((string const &)*arg2,(string const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Population_execute(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = (simuPOP::Population *) 0 ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "stmts", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:Population_execute",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Population_execute" "', argument " "1"" of type '" "simuPOP::Population *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Population_execute" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Population_execute" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  {
    try
    {
      (arg1)->execute((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *Population_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Population, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Population_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_loadPopulation(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "file", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:loadPopulation",kwnames,&obj0)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "loadPopulation" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPopulation" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try
    {
      result = (simuPOP::Population *) &simuPOP::loadPopulation((std::string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_BaseOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc *arg1 = 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  simuPOP::intList *arg5 = 0 ;
  simuPOP::intList *arg6 = 0 ;
  simuPOP::subPopList *arg7 = 0 ;
  simuPOP::stringList *arg8 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::BaseOperator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOOOOOO:new_BaseOperator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BaseOperator" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseOperator" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BaseOperator" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_BaseOperator" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_BaseOperator" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_BaseOperator" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
  }
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseOperator" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
  }
  arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BaseOperator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseOperator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
  }
  arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_BaseOperator" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
  }
  if (!argp7) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseOperator" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
  }
  arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_BaseOperator" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp8) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseOperator" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  {
    try
    {
      result = (simuPOP::BaseOperator *)new simuPOP::BaseOperator((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseOperator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BaseOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseOperator *arg1 = (simuPOP::BaseOperator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseOperator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BaseOperator" "', argument " "1"" of type '" "simuPOP::BaseOperator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseOperator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseOperator_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseOperator *arg1 = (simuPOP::BaseOperator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::BaseOperator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseOperator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseOperator_clone" "', argument " "1"" of type '" "simuPOP::BaseOperator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseOperator * >(argp1);
  {
    try
    {
      result = (simuPOP::BaseOperator *)((simuPOP::BaseOperator const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseOperator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseOperator_apply(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BaseOperator *arg1 = (simuPOP::BaseOperator *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:BaseOperator_apply",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__BaseOperator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseOperator_apply" "', argument " "1"" of type '" "simuPOP::BaseOperator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseOperator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BaseOperator_apply" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BaseOperator_apply" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = (bool)((simuPOP::BaseOperator const *)arg1)->apply(*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BaseOperator_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BaseOperator *arg1 = (simuPOP::BaseOperator *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "format", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:BaseOperator_describe",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__BaseOperator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BaseOperator_describe" "', argument " "1"" of type '" "simuPOP::BaseOperator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseOperator * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BaseOperator_describe" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  {
    try
    {
      result = ((simuPOP::BaseOperator const *)arg1)->describe(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BaseOperator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BaseOperator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BaseOperator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_opList__SWIG_0(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  simuPOP::opList *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    arg1 = swig_obj[0];
  }
  {
    try
    {
      result = (simuPOP::opList *)new simuPOP::opList(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__opList, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_opList__SWIG_1(PyObject *SWIGUNUSEDPARM(self), int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  simuPOP::opList *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  simuPOP::opList *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_opList" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_opList" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  {
    try
    {
      result = (simuPOP::opList *)new simuPOP::opList((simuPOP::opList const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__opList, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_opList(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_opList",0,1,argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v = 0;
    if (argc > 0) {
      {
        _v = (argv[0] != 0);
      }
      if (!_v) goto check_1;
    }
    return _wrap_new_opList__SWIG_0(self, argc, argv);
  }
check_1:
  
  if (argc == 1) {
    return _wrap_new_opList__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_opList'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    simuPOP::opList::opList(PyObject *)\n"
    "    simuPOP::opList::opList(simuPOP::opList const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_opList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::opList *arg1 = (simuPOP::opList *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__opList, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_opList" "', argument " "1"" of type '" "simuPOP::opList *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *opList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__opList, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *opList_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Pause(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  char arg1 = (char) false ;
  bool arg2 = (bool) true ;
  simuPOP::stringFunc const &arg3_defvalue = ">" ;
  simuPOP::stringFunc *arg3 = (simuPOP::stringFunc *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  char val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "stopOnKeyStroke",(char *) "prompt",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::Pause *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOO:new_Pause",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_char(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Pause" "', argument " "1"" of type '" "char""'");
    } 
    arg1 = static_cast< char >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Pause" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Pause" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pause" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringFunc * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Pause" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Pause" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Pause" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Pause" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pause" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_Pause" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pause" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_Pause" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pause" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_Pause" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pause" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::Pause *)new simuPOP::Pause(arg1,arg2,(simuPOP::stringFunc const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Pause, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Pause(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Pause *arg1 = (simuPOP::Pause *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Pause, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pause" "', argument " "1"" of type '" "simuPOP::Pause *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pause * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Pause_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Pause, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Pause_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_NoneOp(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = ">" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::NoneOp *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_NoneOp",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_NoneOp" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NoneOp" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_NoneOp" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_NoneOp" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_NoneOp" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_NoneOp" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NoneOp" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_NoneOp" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NoneOp" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_NoneOp" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NoneOp" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_NoneOp" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NoneOp" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::NoneOp *)new simuPOP::NoneOp((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__NoneOp, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_NoneOp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::NoneOp *arg1 = (simuPOP::NoneOp *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__NoneOp, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NoneOp" "', argument " "1"" of type '" "simuPOP::NoneOp *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::NoneOp * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NoneOp_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__NoneOp, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *NoneOp_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_IfElse(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::opList const &arg2_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg2 = (simuPOP::opList *) &arg2_defvalue ;
  simuPOP::opList const &arg3_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg3 = (simuPOP::opList *) &arg3_defvalue ;
  simuPOP::stringFunc const &arg4_defvalue = ">" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "cond",(char *) "ifOps",(char *) "elseOps",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::IfElse *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOO:new_IfElse",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_IfElse" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::opList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_IfElse" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::opList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_IfElse" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_IfElse" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_IfElse" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_IfElse" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_IfElse" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_IfElse" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_IfElse" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_IfElse" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IfElse" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::IfElse *)new simuPOP::IfElse(arg1,(simuPOP::opList const &)*arg2,(simuPOP::opList const &)*arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__IfElse, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_IfElse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::IfElse *arg1 = (simuPOP::IfElse *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__IfElse, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IfElse" "', argument " "1"" of type '" "simuPOP::IfElse *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::IfElse * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *IfElse_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__IfElse, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *IfElse_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_TerminateIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string arg1 = (string) std::string() ;
  bool arg2 = (bool) false ;
  string arg3 = (string) std::string() ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "condition",(char *) "stopAll",(char *) "message",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::TerminateIf *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_TerminateIf",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      int res = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res) || !ptr) {
        SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_TerminateIf" "', argument " "1"" of type '" "string""'"); 
      }
      arg1 = *ptr;
      if (SWIG_IsNewObj(res)) delete ptr;
    }
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_TerminateIf" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      int res = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res) || !ptr) {
        SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "new_TerminateIf" "', argument " "3"" of type '" "string""'"); 
      }
      arg3 = *ptr;
      if (SWIG_IsNewObj(res)) delete ptr;
    }
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_TerminateIf" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TerminateIf" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_TerminateIf" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_TerminateIf" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_TerminateIf" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_TerminateIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TerminateIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_TerminateIf" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TerminateIf" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_TerminateIf" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TerminateIf" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_TerminateIf" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TerminateIf" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::TerminateIf *)new simuPOP::TerminateIf(arg1,arg2,arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__TerminateIf, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TerminateIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::TerminateIf *arg1 = (simuPOP::TerminateIf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__TerminateIf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TerminateIf" "', argument " "1"" of type '" "simuPOP::TerminateIf *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::TerminateIf * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TerminateIf_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__TerminateIf, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *TerminateIf_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RevertIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  simuPOP::opList const &arg3_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg3 = (simuPOP::opList *) &arg3_defvalue ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "cond",(char *) "fromPop",(char *) "ops",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::RevertIf *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOO:new_RevertIf",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RevertIf" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_RevertIf" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::opList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_RevertIf" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_RevertIf" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_RevertIf" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_RevertIf" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_RevertIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_RevertIf" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_RevertIf" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_RevertIf" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertIf" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::RevertIf *)new simuPOP::RevertIf(arg1,(string const &)*arg2,(simuPOP::opList const &)*arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RevertIf, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RevertIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RevertIf *arg1 = (simuPOP::RevertIf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RevertIf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RevertIf" "', argument " "1"" of type '" "simuPOP::RevertIf *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RevertIf * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RevertIf_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RevertIf, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RevertIf_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_DiscardIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  simuPOP::stringFunc const &arg3_defvalue = "" ;
  simuPOP::stringFunc *arg3 = (simuPOP::stringFunc *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "cond",(char *) "exposeInd",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::DiscardIf *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_DiscardIf",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_DiscardIf" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_DiscardIf" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringFunc * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_DiscardIf" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_DiscardIf" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_DiscardIf" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_DiscardIf" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_DiscardIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_DiscardIf" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_DiscardIf" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DiscardIf" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::DiscardIf *)new simuPOP::DiscardIf(arg1,(string const &)*arg2,(simuPOP::stringFunc const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__DiscardIf, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DiscardIf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::DiscardIf *arg1 = (simuPOP::DiscardIf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__DiscardIf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DiscardIf" "', argument " "1"" of type '" "simuPOP::DiscardIf *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::DiscardIf * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DiscardIf_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__DiscardIf, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DiscardIf_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_TicToc(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = ">" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  double arg2 = (double) (double)0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "stopAfter",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::TicToc *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_TicToc",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_TicToc" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TicToc" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_double(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_TicToc" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = static_cast< double >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_TicToc" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_TicToc" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_TicToc" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_TicToc" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TicToc" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_TicToc" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TicToc" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_TicToc" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TicToc" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_TicToc" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_TicToc" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::TicToc *)new simuPOP::TicToc((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__TicToc, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_TicToc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::TicToc *arg1 = (simuPOP::TicToc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__TicToc, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TicToc" "', argument " "1"" of type '" "simuPOP::TicToc *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::TicToc * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *TicToc_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__TicToc, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *TicToc_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "param",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyOperator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOO:new_PyOperator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PyOperator" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyOperator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyOperator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_PyOperator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOperator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyOperator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOperator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyOperator" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOperator" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyOperator" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOperator" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::PyOperator *)new simuPOP::PyOperator(arg1,arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyOperator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyOperator *arg1 = (simuPOP::PyOperator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyOperator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyOperator" "', argument " "1"" of type '" "simuPOP::PyOperator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyOperator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyOperator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyOperator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyOperator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_applyDuringMatingOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BaseOperator *arg1 = 0 ;
  simuPOP::Population *arg2 = (simuPOP::Population *) 0 ;
  simuPOP::Population *arg3 = (simuPOP::Population *) 0 ;
  ssize_t arg4 ;
  ssize_t arg5 ;
  pairu *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  long val4 ;
  int ecode4 = 0 ;
  long val5 ;
  int ecode5 = 0 ;
  int res6 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "op",(char *) "pop",(char *) "offPop",(char *) "dad",(char *) "mom",(char *) "off", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOOOO:applyDuringMatingOperator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__BaseOperator,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "applyDuringMatingOperator" "', argument " "1"" of type '" "simuPOP::BaseOperator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "applyDuringMatingOperator" "', argument " "1"" of type '" "simuPOP::BaseOperator const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseOperator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "applyDuringMatingOperator" "', argument " "2"" of type '" "simuPOP::Population *""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "applyDuringMatingOperator" "', argument " "3"" of type '" "simuPOP::Population *""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::Population * >(argp3);
  ecode4 = SWIG_AsVal_long(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "applyDuringMatingOperator" "', argument " "4"" of type '" "ssize_t""'");
  } 
  arg4 = static_cast< ssize_t >(val4);
  ecode5 = SWIG_AsVal_long(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "applyDuringMatingOperator" "', argument " "5"" of type '" "ssize_t""'");
  } 
  arg5 = static_cast< ssize_t >(val5);
  {
    std::pair< size_t,size_t > *ptr = (std::pair< size_t,size_t > *)0;
    res6 = swig::asptr(obj5, &ptr);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "applyDuringMatingOperator" "', argument " "6"" of type '" "pairu const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "applyDuringMatingOperator" "', argument " "6"" of type '" "pairu const &""'"); 
    }
    arg6 = ptr;
  }
  {
    try
    {
      simuPOP::applyDuringMatingOperator((simuPOP::BaseOperator const &)*arg1,arg2,arg3,arg4,arg5,(std::pair< size_t,size_t > const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OffspringGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::opList *arg1 = 0 ;
  simuPOP::floatListFunc const &arg2_defvalue = 1 ;
  simuPOP::floatListFunc *arg2 = (simuPOP::floatListFunc *) &arg2_defvalue ;
  simuPOP::floatListFunc const &arg3_defvalue = RANDOM_SEX ;
  simuPOP::floatListFunc *arg3 = (simuPOP::floatListFunc *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "ops",(char *) "numOffspring",(char *) "sexMode", NULL 
  };
  simuPOP::OffspringGenerator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:new_OffspringGenerator",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OffspringGenerator" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringGenerator" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_OffspringGenerator" "', argument " "2"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringGenerator" "', argument " "2"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::floatListFunc * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_OffspringGenerator" "', argument " "3"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringGenerator" "', argument " "3"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatListFunc * >(argp3);
  }
  {
    try
    {
      result = (simuPOP::OffspringGenerator *)new simuPOP::OffspringGenerator((simuPOP::opList const &)*arg1,(simuPOP::floatListFunc const &)*arg2,(simuPOP::floatListFunc const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__OffspringGenerator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OffspringGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::OffspringGenerator *arg1 = (simuPOP::OffspringGenerator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__OffspringGenerator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OffspringGenerator" "', argument " "1"" of type '" "simuPOP::OffspringGenerator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::OffspringGenerator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OffspringGenerator_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::OffspringGenerator *arg1 = (simuPOP::OffspringGenerator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::OffspringGenerator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__OffspringGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OffspringGenerator_clone" "', argument " "1"" of type '" "simuPOP::OffspringGenerator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::OffspringGenerator * >(argp1);
  {
    try
    {
      result = (simuPOP::OffspringGenerator *)((simuPOP::OffspringGenerator const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__OffspringGenerator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OffspringGenerator_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::OffspringGenerator *arg1 = (simuPOP::OffspringGenerator *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "format", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:OffspringGenerator_describe",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__OffspringGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OffspringGenerator_describe" "', argument " "1"" of type '" "simuPOP::OffspringGenerator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::OffspringGenerator * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OffspringGenerator_describe" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  {
    try
    {
      result = ((simuPOP::OffspringGenerator const *)arg1)->describe(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *OffspringGenerator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__OffspringGenerator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *OffspringGenerator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ControlledOffspringGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  simuPOP::uintList *arg2 = 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  simuPOP::opList const &arg4_defvalue = simuPOP::vectorop() ;
  simuPOP::opList *arg4 = (simuPOP::opList *) &arg4_defvalue ;
  simuPOP::floatListFunc const &arg5_defvalue = 1 ;
  simuPOP::floatListFunc *arg5 = (simuPOP::floatListFunc *) &arg5_defvalue ;
  simuPOP::floatListFunc const &arg6_defvalue = RANDOM_SEX ;
  simuPOP::floatListFunc *arg6 = (simuPOP::floatListFunc *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "alleles",(char *) "freqFunc",(char *) "ops",(char *) "numOffspring",(char *) "sexMode", NULL 
  };
  simuPOP::ControlledOffspringGenerator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO|OOO:new_ControlledOffspringGenerator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ControlledOffspringGenerator" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ControlledOffspringGenerator" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ControlledOffspringGenerator" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ControlledOffspringGenerator" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  arg3 = obj2;
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_ControlledOffspringGenerator" "', argument " "4"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ControlledOffspringGenerator" "', argument " "4"" of type '" "simuPOP::opList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::opList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_ControlledOffspringGenerator" "', argument " "5"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ControlledOffspringGenerator" "', argument " "5"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::floatListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_ControlledOffspringGenerator" "', argument " "6"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ControlledOffspringGenerator" "', argument " "6"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::floatListFunc * >(argp6);
  }
  {
    try
    {
      result = (simuPOP::ControlledOffspringGenerator *)new simuPOP::ControlledOffspringGenerator((simuPOP::lociList const &)*arg1,(simuPOP::uintList const &)*arg2,arg3,(simuPOP::opList const &)*arg4,(simuPOP::floatListFunc const &)*arg5,(simuPOP::floatListFunc const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ControlledOffspringGenerator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ControlledOffspringGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ControlledOffspringGenerator *arg1 = (simuPOP::ControlledOffspringGenerator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ControlledOffspringGenerator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ControlledOffspringGenerator" "', argument " "1"" of type '" "simuPOP::ControlledOffspringGenerator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ControlledOffspringGenerator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ControlledOffspringGenerator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ControlledOffspringGenerator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ControlledOffspringGenerator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "selectionField", NULL 
  };
  simuPOP::ParentChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_ParentChooser",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ParentChooser" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentChooser" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::ParentChooser *)new simuPOP::ParentChooser((string const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ParentChooser, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParentChooser_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = (simuPOP::ParentChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::ParentChooser *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ParentChooser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParentChooser_clone" "', argument " "1"" of type '" "simuPOP::ParentChooser const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  {
    try
    {
      result = (simuPOP::ParentChooser *)((simuPOP::ParentChooser const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ParentChooser, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParentChooser_initialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = (simuPOP::ParentChooser *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop",(char *) "subPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:ParentChooser_initialize",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__ParentChooser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParentChooser_initialize" "', argument " "1"" of type '" "simuPOP::ParentChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ParentChooser_initialize" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ParentChooser_initialize" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ParentChooser_initialize" "', argument " "3"" of type '" "size_t""'");
  } 
  arg3 = static_cast< size_t >(val3);
  {
    try
    {
      (arg1)->initialize(*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParentChooser_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = (simuPOP::ParentChooser *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "format", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:ParentChooser_describe",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__ParentChooser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParentChooser_describe" "', argument " "1"" of type '" "simuPOP::ParentChooser const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ParentChooser_describe" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  {
    try
    {
      result = ((simuPOP::ParentChooser const *)arg1)->describe(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ParentChooser_chooseParents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = (simuPOP::ParentChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::ParentChooser::IndividualPair result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ParentChooser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ParentChooser_chooseParents" "', argument " "1"" of type '" "simuPOP::ParentChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  {
    try
    {
      result = (arg1)->chooseParents();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::pair< simuPOP::Individual*,simuPOP::Individual* > >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = (simuPOP::ParentChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ParentChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParentChooser" "', argument " "1"" of type '" "simuPOP::ParentChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ParentChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ParentChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ParentChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SequentialParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  SexChoice arg1 = (SexChoice) ANY_SEX ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "sexChoice", NULL 
  };
  simuPOP::SequentialParentChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_SequentialParentChooser",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SequentialParentChooser" "', argument " "1"" of type '" "SexChoice""'");
    } 
    arg1 = static_cast< SexChoice >(val1);
  }
  {
    try
    {
      result = (simuPOP::SequentialParentChooser *)new simuPOP::SequentialParentChooser(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SequentialParentChooser, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SequentialParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SequentialParentChooser *arg1 = (simuPOP::SequentialParentChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SequentialParentChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SequentialParentChooser" "', argument " "1"" of type '" "simuPOP::SequentialParentChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SequentialParentChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SequentialParentChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SequentialParentChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SequentialParentChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RandomParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  bool arg1 = (bool) true ;
  string const &arg2_defvalue = "fitness" ;
  string *arg2 = (string *) &arg2_defvalue ;
  SexChoice arg3 = (SexChoice) ANY_SEX ;
  bool val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "replacement",(char *) "selectionField",(char *) "sexChoice", NULL 
  };
  simuPOP::RandomParentChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOO:new_RandomParentChooser",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_bool(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_RandomParentChooser" "', argument " "1"" of type '" "bool""'");
    } 
    arg1 = static_cast< bool >(val1);
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RandomParentChooser" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RandomParentChooser" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RandomParentChooser" "', argument " "3"" of type '" "SexChoice""'");
    } 
    arg3 = static_cast< SexChoice >(val3);
  }
  {
    try
    {
      result = (simuPOP::RandomParentChooser *)new simuPOP::RandomParentChooser(arg1,(string const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RandomParentChooser, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RandomParentChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RandomParentChooser *arg1 = (simuPOP::RandomParentChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RandomParentChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RandomParentChooser" "', argument " "1"" of type '" "simuPOP::RandomParentChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RandomParentChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RandomParentChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RandomParentChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RandomParentChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RandomParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  bool arg1 = (bool) true ;
  string const &arg2_defvalue = "fitness" ;
  string *arg2 = (string *) &arg2_defvalue ;
  bool val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "replacement",(char *) "selectionField", NULL 
  };
  simuPOP::RandomParentsChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:new_RandomParentsChooser",kwnames,&obj0,&obj1)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_bool(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_RandomParentsChooser" "', argument " "1"" of type '" "bool""'");
    } 
    arg1 = static_cast< bool >(val1);
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RandomParentsChooser" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RandomParentsChooser" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::RandomParentsChooser *)new simuPOP::RandomParentsChooser(arg1,(string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RandomParentsChooser, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RandomParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RandomParentsChooser *arg1 = (simuPOP::RandomParentsChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RandomParentsChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RandomParentsChooser" "', argument " "1"" of type '" "simuPOP::RandomParentsChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RandomParentsChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RandomParentsChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RandomParentsChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RandomParentsChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PolyParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  Sex arg1 = (Sex) MALE ;
  UINT arg2 = (UINT) 1 ;
  string const &arg3_defvalue = "fitness" ;
  string *arg3 = (string *) &arg3_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "polySex",(char *) "polyNum",(char *) "selectionField", NULL 
  };
  simuPOP::PolyParentsChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOO:new_PolyParentsChooser",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PolyParentsChooser" "', argument " "1"" of type '" "Sex""'");
    } 
    arg1 = static_cast< Sex >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PolyParentsChooser" "', argument " "2"" of type '" "UINT""'");
    } 
    arg2 = static_cast< UINT >(val2);
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PolyParentsChooser" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PolyParentsChooser" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::PolyParentsChooser *)new simuPOP::PolyParentsChooser(arg1,arg2,(string const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PolyParentsChooser, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PolyParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PolyParentsChooser *arg1 = (simuPOP::PolyParentsChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PolyParentsChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PolyParentsChooser" "', argument " "1"" of type '" "simuPOP::PolyParentsChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PolyParentsChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PolyParentsChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PolyParentsChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PolyParentsChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_CombinedParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = 0 ;
  simuPOP::ParentChooser *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "fatherChooser",(char *) "motherChooser",(char *) "allowSelfing", NULL 
  };
  simuPOP::CombinedParentsChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:new_CombinedParentsChooser",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__ParentChooser,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CombinedParentsChooser" "', argument " "1"" of type '" "simuPOP::ParentChooser const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CombinedParentsChooser" "', argument " "1"" of type '" "simuPOP::ParentChooser const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__ParentChooser,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CombinedParentsChooser" "', argument " "2"" of type '" "simuPOP::ParentChooser const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CombinedParentsChooser" "', argument " "2"" of type '" "simuPOP::ParentChooser const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::ParentChooser * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CombinedParentsChooser" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      result = (simuPOP::CombinedParentsChooser *)new simuPOP::CombinedParentsChooser((simuPOP::ParentChooser const &)*arg1,(simuPOP::ParentChooser const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__CombinedParentsChooser, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CombinedParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::CombinedParentsChooser *arg1 = (simuPOP::CombinedParentsChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__CombinedParentsChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CombinedParentsChooser" "', argument " "1"" of type '" "simuPOP::CombinedParentsChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::CombinedParentsChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CombinedParentsChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__CombinedParentsChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CombinedParentsChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "generator", NULL 
  };
  simuPOP::PyParentsChooser *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O:new_PyParentsChooser",kwnames,&obj0)) SWIG_fail;
  arg1 = obj0;
  {
    try
    {
      result = (simuPOP::PyParentsChooser *)new simuPOP::PyParentsChooser(arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyParentsChooser, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyParentsChooser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyParentsChooser *arg1 = (simuPOP::PyParentsChooser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyParentsChooser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyParentsChooser" "', argument " "1"" of type '" "simuPOP::PyParentsChooser *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyParentsChooser * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyParentsChooser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyParentsChooser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyParentsChooser_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MatingScheme(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::uintListFunc const &arg1_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg1 = (simuPOP::uintListFunc *) &arg1_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *  kwnames[] = {
    (char *) "subPopSize", NULL 
  };
  simuPOP::MatingScheme *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:new_MatingScheme",kwnames,&obj0)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MatingScheme" "', argument " "1"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatingScheme" "', argument " "1"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::uintListFunc * >(argp1);
  }
  {
    try
    {
      result = (simuPOP::MatingScheme *)new simuPOP::MatingScheme((simuPOP::uintListFunc const &)*arg1);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MatingScheme, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MatingScheme(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MatingScheme *arg1 = (simuPOP::MatingScheme *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MatingScheme, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MatingScheme" "', argument " "1"" of type '" "simuPOP::MatingScheme *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MatingScheme * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MatingScheme_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MatingScheme *arg1 = (simuPOP::MatingScheme *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::MatingScheme *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MatingScheme, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatingScheme_clone" "', argument " "1"" of type '" "simuPOP::MatingScheme const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MatingScheme * >(argp1);
  {
    try
    {
      result = (simuPOP::MatingScheme *)((simuPOP::MatingScheme const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MatingScheme, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MatingScheme_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::MatingScheme *arg1 = (simuPOP::MatingScheme *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "format", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:MatingScheme_describe",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__MatingScheme, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatingScheme_describe" "', argument " "1"" of type '" "simuPOP::MatingScheme const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MatingScheme * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatingScheme_describe" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  {
    try
    {
      result = ((simuPOP::MatingScheme const *)arg1)->describe(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MatingScheme_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MatingScheme, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MatingScheme_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_HomoMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::ParentChooser *arg1 = 0 ;
  simuPOP::OffspringGenerator *arg2 = 0 ;
  simuPOP::uintListFunc const &arg3_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg3 = (simuPOP::uintListFunc *) &arg3_defvalue ;
  simuPOP::subPopList arg4 = (simuPOP::subPopList) simuPOP::subPopList() ;
  double arg5 = (double) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  double val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "chooser",(char *) "generator",(char *) "subPopSize",(char *) "subPops",(char *) "weight", NULL 
  };
  simuPOP::HomoMating *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOO:new_HomoMating",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__ParentChooser,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_HomoMating" "', argument " "1"" of type '" "simuPOP::ParentChooser &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HomoMating" "', argument " "1"" of type '" "simuPOP::ParentChooser &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentChooser * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__OffspringGenerator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_HomoMating" "', argument " "2"" of type '" "simuPOP::OffspringGenerator &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HomoMating" "', argument " "2"" of type '" "simuPOP::OffspringGenerator &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::OffspringGenerator * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_HomoMating" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HomoMating" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintListFunc * >(argp3);
  }
  if (obj3) {
    {
      res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_HomoMating" "', argument " "4"" of type '" "simuPOP::subPopList""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HomoMating" "', argument " "4"" of type '" "simuPOP::subPopList""'");
      } else {
        simuPOP::subPopList * temp = reinterpret_cast< simuPOP::subPopList * >(argp4);
        arg4 = *temp;
        if (SWIG_IsNewObj(res4)) delete temp;
      }
    }
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_double(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_HomoMating" "', argument " "5"" of type '" "double""'");
    } 
    arg5 = static_cast< double >(val5);
  }
  {
    try
    {
      result = (simuPOP::HomoMating *)new simuPOP::HomoMating(*arg1,*arg2,(simuPOP::uintListFunc const &)*arg3,arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__HomoMating, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_HomoMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::HomoMating *arg1 = (simuPOP::HomoMating *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__HomoMating, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_HomoMating" "', argument " "1"" of type '" "simuPOP::HomoMating *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::HomoMating * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *HomoMating_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__HomoMating, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *HomoMating_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PedigreeMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = 0 ;
  simuPOP::opList *arg2 = 0 ;
  string const &arg3_defvalue = "ind_id" ;
  string *arg3 = (string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "ped",(char *) "ops",(char *) "idField", NULL 
  };
  simuPOP::PedigreeMating *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:new_PedigreeMating",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__Pedigree,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PedigreeMating" "', argument " "1"" of type '" "simuPOP::Pedigree const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeMating" "', argument " "1"" of type '" "simuPOP::Pedigree const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PedigreeMating" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeMating" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::opList * >(argp2);
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PedigreeMating" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeMating" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  {
    try
    {
      result = (simuPOP::PedigreeMating *)new simuPOP::PedigreeMating((simuPOP::Pedigree const &)*arg1,(simuPOP::opList const &)*arg2,(string const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PedigreeMating, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PedigreeMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PedigreeMating *arg1 = (simuPOP::PedigreeMating *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PedigreeMating, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PedigreeMating" "', argument " "1"" of type '" "simuPOP::PedigreeMating *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PedigreeMating * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PedigreeMating_parallelizable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PedigreeMating *arg1 = (simuPOP::PedigreeMating *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PedigreeMating, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PedigreeMating_parallelizable" "', argument " "1"" of type '" "simuPOP::PedigreeMating const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PedigreeMating * >(argp1);
  {
    try
    {
      result = (bool)((simuPOP::PedigreeMating const *)arg1)->parallelizable();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PedigreeMating_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PedigreeMating, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PedigreeMating_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_HeteroMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::vectormating *arg1 = 0 ;
  simuPOP::uintListFunc const &arg2_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg2 = (simuPOP::uintListFunc *) &arg2_defvalue ;
  bool arg3 = (bool) true ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "matingSchemes",(char *) "subPopSize",(char *) "shuffleOffspring", NULL 
  };
  simuPOP::HeteroMating *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:new_HeteroMating",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::vector< simuPOP::HomoMating*,std::allocator< simuPOP::HomoMating * > > *ptr = (std::vector< simuPOP::HomoMating*,std::allocator< simuPOP::HomoMating * > > *)0;
    res1 = swig::asptr(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_HeteroMating" "', argument " "1"" of type '" "simuPOP::vectormating const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HeteroMating" "', argument " "1"" of type '" "simuPOP::vectormating const &""'"); 
    }
    arg1 = ptr;
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_HeteroMating" "', argument " "2"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HeteroMating" "', argument " "2"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintListFunc * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_HeteroMating" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      result = (simuPOP::HeteroMating *)new simuPOP::HeteroMating((simuPOP::vectormating const &)*arg1,(simuPOP::uintListFunc const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__HeteroMating, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_HeteroMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::HeteroMating *arg1 = (simuPOP::HeteroMating *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__HeteroMating, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_HeteroMating" "', argument " "1"" of type '" "simuPOP::HeteroMating *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::HeteroMating * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *HeteroMating_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__HeteroMating, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *HeteroMating_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ConditionalMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::MatingScheme *arg2 = 0 ;
  simuPOP::MatingScheme *arg3 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "cond",(char *) "ifMatingScheme",(char *) "elseMatingScheme", NULL 
  };
  simuPOP::ConditionalMating *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOO:new_ConditionalMating",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  arg1 = obj0;
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__MatingScheme,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ConditionalMating" "', argument " "2"" of type '" "simuPOP::MatingScheme const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ConditionalMating" "', argument " "2"" of type '" "simuPOP::MatingScheme const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::MatingScheme * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__MatingScheme,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_ConditionalMating" "', argument " "3"" of type '" "simuPOP::MatingScheme const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ConditionalMating" "', argument " "3"" of type '" "simuPOP::MatingScheme const &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::MatingScheme * >(argp3);
  {
    try
    {
      result = (simuPOP::ConditionalMating *)new simuPOP::ConditionalMating(arg1,(simuPOP::MatingScheme const &)*arg2,(simuPOP::MatingScheme const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ConditionalMating, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ConditionalMating(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ConditionalMating *arg1 = (simuPOP::ConditionalMating *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ConditionalMating, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ConditionalMating" "', argument " "1"" of type '" "simuPOP::ConditionalMating *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ConditionalMating * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ConditionalMating_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ConditionalMating, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ConditionalMating_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_pyPopIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  SwigValueWrapper< vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator > arg1 ;
  SwigValueWrapper< vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator > arg2 ;
  void *argp1 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end", NULL 
  };
  simuPOP::pyPopIterator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:new_pyPopIterator",kwnames,&obj0,&obj1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_pyPopIterator" "', argument " "1"" of type '" "vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyPopIterator" "', argument " "1"" of type '" "vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator const""'");
    } else {
      vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator * temp = reinterpret_cast< vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_pyPopIterator" "', argument " "2"" of type '" "vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_pyPopIterator" "', argument " "2"" of type '" "vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator const""'");
    } else {
      vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator * temp = reinterpret_cast< vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    try
    {
      result = (simuPOP::pyPopIterator *)new simuPOP::pyPopIterator(arg1,arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__pyPopIterator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_pyPopIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyPopIterator *arg1 = (simuPOP::pyPopIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyPopIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_pyPopIterator" "', argument " "1"" of type '" "simuPOP::pyPopIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyPopIterator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyPopIterator___iter__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyPopIterator *arg1 = (simuPOP::pyPopIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< simuPOP::pyPopIterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyPopIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyPopIterator___iter__" "', argument " "1"" of type '" "simuPOP::pyPopIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyPopIterator * >(argp1);
  {
    try
    {
      result = (arg1)->__iter__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyPopIterator(static_cast< const simuPOP::pyPopIterator& >(result))), SWIGTYPE_p_simuPOP__pyPopIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyPopIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyPopIterator *arg1 = (simuPOP::pyPopIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Population *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyPopIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyPopIterator_next" "', argument " "1"" of type '" "simuPOP::pyPopIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyPopIterator * >(argp1);
  {
    try
    {
      result = (simuPOP::Population *) &(arg1)->next();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pyPopIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::pyPopIterator *arg1 = (simuPOP::pyPopIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Population *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__pyPopIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pyPopIterator___next__" "', argument " "1"" of type '" "simuPOP::pyPopIterator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::pyPopIterator * >(argp1);
  {
    try
    {
      result = (simuPOP::Population *) &(arg1)->__next__();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *pyPopIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__pyPopIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *pyPopIterator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Simulator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  UINT arg2 = (UINT) 1 ;
  bool arg3 = (bool) true ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "pops",(char *) "rep",(char *) "stealPops", NULL 
  };
  simuPOP::Simulator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:new_Simulator",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Simulator" "', argument " "2"" of type '" "UINT""'");
    } 
    arg2 = static_cast< UINT >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Simulator" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      result = (simuPOP::Simulator *)new simuPOP::Simulator(arg1,arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Simulator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Simulator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Simulator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Simulator" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Simulator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_clone" "', argument " "1"" of type '" "simuPOP::Simulator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  {
    try
    {
      result = (simuPOP::Simulator *)((simuPOP::Simulator const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Simulator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_numRep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_numRep" "', argument " "1"" of type '" "simuPOP::Simulator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  {
    try
    {
      result = ((simuPOP::Simulator const *)arg1)->numRep();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_population(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rep", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Simulator_population",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_population" "', argument " "1"" of type '" "simuPOP::Simulator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Simulator_population" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    try
    {
      result = (simuPOP::Population *) &((simuPOP::Simulator const *)arg1)->population(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop",(char *) "stealPop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Simulator_add",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_add" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Simulator_add" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_add" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Simulator_add" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      (arg1)->add((simuPOP::Population const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_extract(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  UINT arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rep", NULL 
  };
  simuPOP::Population *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Simulator_extract",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_extract" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Simulator_extract" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  {
    try
    {
      result = (simuPOP::Population *) &(arg1)->extract(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Population, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_populations(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< simuPOP::pyPopIterator > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_populations" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  {
    try
    {
      result = (arg1)->populations();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::pyPopIterator(static_cast< const simuPOP::pyPopIterator& >(result))), SWIGTYPE_p_simuPOP__pyPopIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_evolve(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  simuPOP::opList const &arg2_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg2 = (simuPOP::opList *) &arg2_defvalue ;
  simuPOP::opList const &arg3_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg3 = (simuPOP::opList *) &arg3_defvalue ;
  simuPOP::MatingScheme const &arg4_defvalue = simuPOP::MatingScheme() ;
  simuPOP::MatingScheme *arg4 = (simuPOP::MatingScheme *) &arg4_defvalue ;
  simuPOP::opList const &arg5_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg5 = (simuPOP::opList *) &arg5_defvalue ;
  simuPOP::opList const &arg6_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg6 = (simuPOP::opList *) &arg6_defvalue ;
  int arg7 = (int) -1 ;
  bool arg8 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "initOps",(char *) "preOps",(char *) "matingScheme",(char *) "postOps",(char *) "finalOps",(char *) "gen",(char *) "dryrun", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOO:Simulator_evolve",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_evolve" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Simulator_evolve" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_evolve" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::opList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Simulator_evolve" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_evolve" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::opList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__MatingScheme,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Simulator_evolve" "', argument " "4"" of type '" "simuPOP::MatingScheme const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_evolve" "', argument " "4"" of type '" "simuPOP::MatingScheme const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::MatingScheme * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Simulator_evolve" "', argument " "5"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_evolve" "', argument " "5"" of type '" "simuPOP::opList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::opList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Simulator_evolve" "', argument " "6"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_evolve" "', argument " "6"" of type '" "simuPOP::opList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::opList * >(argp6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "Simulator_evolve" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_bool(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "Simulator_evolve" "', argument " "8"" of type '" "bool""'");
    } 
    arg8 = static_cast< bool >(val8);
  }
  {
    try
    {
      result = (arg1)->evolve((simuPOP::opList const &)*arg2,(simuPOP::opList const &)*arg3,(simuPOP::MatingScheme const &)*arg4,(simuPOP::opList const &)*arg5,(simuPOP::opList const &)*arg6,arg7,arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator_vars(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  UINT arg2 ;
  simuPOP::vspID arg3 = (simuPOP::vspID) simuPOP::vspID() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rep",(char *) "subPop", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Simulator_vars",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator_vars" "', argument " "1"" of type '" "simuPOP::Simulator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Simulator_vars" "', argument " "2"" of type '" "UINT""'");
  } 
  arg2 = static_cast< UINT >(val2);
  if (obj2) {
    {
      res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__vspID,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Simulator_vars" "', argument " "3"" of type '" "simuPOP::vspID""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator_vars" "', argument " "3"" of type '" "simuPOP::vspID""'");
      } else {
        simuPOP::vspID * temp = reinterpret_cast< simuPOP::vspID * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  {
    try
    {
      result = (PyObject *)(arg1)->vars(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Simulator___cmp__(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Simulator *arg1 = (simuPOP::Simulator *) 0 ;
  simuPOP::Simulator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "rhs", NULL 
  };
  int result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Simulator___cmp__",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Simulator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Simulator___cmp__" "', argument " "1"" of type '" "simuPOP::Simulator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Simulator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Simulator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Simulator___cmp__" "', argument " "2"" of type '" "simuPOP::Simulator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Simulator___cmp__" "', argument " "2"" of type '" "simuPOP::Simulator const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Simulator * >(argp2);
  {
    try
    {
      result = (int)((simuPOP::Simulator const *)arg1)->__cmp__((simuPOP::Simulator const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Simulator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Simulator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Simulator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_describeEvolProcess(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::opList const &arg1_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg1 = (simuPOP::opList *) &arg1_defvalue ;
  simuPOP::opList const &arg2_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg2 = (simuPOP::opList *) &arg2_defvalue ;
  simuPOP::MatingScheme const &arg3_defvalue = simuPOP::MatingScheme() ;
  simuPOP::MatingScheme *arg3 = (simuPOP::MatingScheme *) &arg3_defvalue ;
  simuPOP::opList const &arg4_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg4 = (simuPOP::opList *) &arg4_defvalue ;
  simuPOP::opList const &arg5_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg5 = (simuPOP::opList *) &arg5_defvalue ;
  int arg6 = (int) -1 ;
  size_t arg7 = (size_t) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  size_t val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  char *  kwnames[] = {
    (char *) "initOps",(char *) "preOps",(char *) "matingScheme",(char *) "postOps",(char *) "finalOps",(char *) "gen",(char *) "numRep", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOO:describeEvolProcess",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "describeEvolProcess" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "describeEvolProcess" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "describeEvolProcess" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "describeEvolProcess" "', argument " "2"" of type '" "simuPOP::opList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::opList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__MatingScheme,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "describeEvolProcess" "', argument " "3"" of type '" "simuPOP::MatingScheme const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "describeEvolProcess" "', argument " "3"" of type '" "simuPOP::MatingScheme const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::MatingScheme * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "describeEvolProcess" "', argument " "4"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "describeEvolProcess" "', argument " "4"" of type '" "simuPOP::opList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::opList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "describeEvolProcess" "', argument " "5"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "describeEvolProcess" "', argument " "5"" of type '" "simuPOP::opList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::opList * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "describeEvolProcess" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_size_t(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "describeEvolProcess" "', argument " "7"" of type '" "size_t""'");
    } 
    arg7 = static_cast< size_t >(val7);
  }
  {
    try
    {
      result = simuPOP::describeEvolProcess((simuPOP::opList const &)*arg1,(simuPOP::opList const &)*arg2,(simuPOP::MatingScheme const &)*arg3,(simuPOP::opList const &)*arg4,(simuPOP::opList const &)*arg5,arg6,arg7);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_PyEval(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  string const &arg3_defvalue = std::string() ;
  string *arg3 = (string *) &arg3_defvalue ;
  simuPOP::stringFunc const &arg4_defvalue = ">" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = Py_False ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "expr",(char *) "stmts",(char *) "exposePop",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyEval *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_PyEval",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PyEval" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyEval" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyEval" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_PyEval" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyEval" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyEval" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PyEval" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyEval" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyEval" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyEval" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PyEval" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyEval" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::PyEval *)new simuPOP::PyEval((string const &)*arg1,(string const &)*arg2,(string const &)*arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyEval, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyEval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyEval *arg1 = (simuPOP::PyEval *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyEval, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyEval" "', argument " "1"" of type '" "simuPOP::PyEval *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyEval * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PyEval_evaluate(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::PyEval *arg1 = (simuPOP::PyEval *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  string result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:PyEval_evaluate",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__PyEval, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PyEval_evaluate" "', argument " "1"" of type '" "simuPOP::PyEval const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyEval * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PyEval_evaluate" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PyEval_evaluate" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      result = ((simuPOP::PyEval const *)arg1)->evaluate(*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_std_string(static_cast< std::string >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyEval_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyEval, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyEval_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyExec(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  simuPOP::stringFunc const &arg3_defvalue = ">" ;
  simuPOP::stringFunc *arg3 = (simuPOP::stringFunc *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = Py_False ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "stmts",(char *) "exposePop",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyExec *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOO:new_PyExec",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PyExec" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyExec" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyExec" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringFunc * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyExec" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyExec" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyExec" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyExec" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyExec" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyExec" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyExec" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyExec" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::PyExec *)new simuPOP::PyExec((string const &)*arg1,(string const &)*arg2,(simuPOP::stringFunc const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyExec, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyExec(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyExec *arg1 = (simuPOP::PyExec *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyExec, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyExec" "', argument " "1"" of type '" "simuPOP::PyExec *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyExec * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyExec_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyExec, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyExec_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InfoEval(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  bool arg3 = (bool) false ;
  string const &arg4_defvalue = std::string() ;
  string *arg4 = (string *) &arg4_defvalue ;
  simuPOP::stringFunc const &arg5_defvalue = ">" ;
  simuPOP::stringFunc *arg5 = (simuPOP::stringFunc *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::subPopList const &arg11_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg11 = (simuPOP::subPopList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr() ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  char *  kwnames[] = {
    (char *) "expr",(char *) "stmts",(char *) "usePopVars",(char *) "exposeInd",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InfoEval *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOO:new_InfoEval",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoEval" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_InfoEval" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InfoEval" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_InfoEval" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_InfoEval" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringFunc * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_InfoEval" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_InfoEval" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_InfoEval" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_InfoEval" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_InfoEval" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_InfoEval" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::subPopList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_InfoEval" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoEval" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  {
    try
    {
      result = (simuPOP::InfoEval *)new simuPOP::InfoEval((string const &)*arg1,(string const &)*arg2,arg3,(string const &)*arg4,(simuPOP::stringFunc const &)*arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::subPopList const &)*arg11,(simuPOP::stringList const &)*arg12);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InfoEval, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InfoEval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InfoEval *arg1 = (simuPOP::InfoEval *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InfoEval, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfoEval" "', argument " "1"" of type '" "simuPOP::InfoEval *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InfoEval * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InfoEval_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InfoEval, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InfoEval_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InfoExec(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  bool arg2 = (bool) false ;
  string const &arg3_defvalue = std::string() ;
  string *arg3 = (string *) &arg3_defvalue ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  bool val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "stmts",(char *) "usePopVars",(char *) "exposeInd",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InfoExec *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_InfoExec",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InfoExec" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InfoExec" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InfoExec" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_InfoExec" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_InfoExec" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_InfoExec" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_InfoExec" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_InfoExec" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_InfoExec" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_InfoExec" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_InfoExec" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InfoExec" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::InfoExec *)new simuPOP::InfoExec((string const &)*arg1,arg2,(string const &)*arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InfoExec, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InfoExec(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InfoExec *arg1 = (simuPOP::InfoExec *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InfoExec, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InfoExec" "', argument " "1"" of type '" "simuPOP::InfoExec *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InfoExec * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InfoExec_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InfoExec, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InfoExec_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Stat(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  bool arg1 = (bool) false ;
  bool arg2 = (bool) false ;
  bool arg3 = (bool) false ;
  simuPOP::lociList const &arg4_defvalue = vectoru() ;
  simuPOP::lociList *arg4 = (simuPOP::lociList *) &arg4_defvalue ;
  simuPOP::lociList const &arg5_defvalue = vectoru() ;
  simuPOP::lociList *arg5 = (simuPOP::lociList *) &arg5_defvalue ;
  simuPOP::lociList const &arg6_defvalue = vectoru() ;
  simuPOP::lociList *arg6 = (simuPOP::lociList *) &arg6_defvalue ;
  simuPOP::lociList const &arg7_defvalue = vectoru() ;
  simuPOP::lociList *arg7 = (simuPOP::lociList *) &arg7_defvalue ;
  simuPOP::lociList const &arg8_defvalue = vectoru() ;
  simuPOP::lociList *arg8 = (simuPOP::lociList *) &arg8_defvalue ;
  simuPOP::lociList const &arg9_defvalue = vectoru() ;
  simuPOP::lociList *arg9 = (simuPOP::lociList *) &arg9_defvalue ;
  simuPOP::intMatrix const &arg10_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg10 = (simuPOP::intMatrix *) &arg10_defvalue ;
  simuPOP::intMatrix const &arg11_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg11 = (simuPOP::intMatrix *) &arg11_defvalue ;
  simuPOP::intMatrix const &arg12_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg12 = (simuPOP::intMatrix *) &arg12_defvalue ;
  simuPOP::stringList const &arg13_defvalue = vectorstr() ;
  simuPOP::stringList *arg13 = (simuPOP::stringList *) &arg13_defvalue ;
  simuPOP::stringList const &arg14_defvalue = vectorstr() ;
  simuPOP::stringList *arg14 = (simuPOP::stringList *) &arg14_defvalue ;
  simuPOP::stringList const &arg15_defvalue = vectorstr() ;
  simuPOP::stringList *arg15 = (simuPOP::stringList *) &arg15_defvalue ;
  simuPOP::stringList const &arg16_defvalue = vectorstr() ;
  simuPOP::stringList *arg16 = (simuPOP::stringList *) &arg16_defvalue ;
  simuPOP::stringList const &arg17_defvalue = vectorstr() ;
  simuPOP::stringList *arg17 = (simuPOP::stringList *) &arg17_defvalue ;
  simuPOP::intMatrix const &arg18_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg18 = (simuPOP::intMatrix *) &arg18_defvalue ;
  simuPOP::lociList const &arg19_defvalue = vectoru() ;
  simuPOP::lociList *arg19 = (simuPOP::lociList *) &arg19_defvalue ;
  simuPOP::lociList const &arg20_defvalue = vectoru() ;
  simuPOP::lociList *arg20 = (simuPOP::lociList *) &arg20_defvalue ;
  simuPOP::lociList const &arg21_defvalue = vectoru() ;
  simuPOP::lociList *arg21 = (simuPOP::lociList *) &arg21_defvalue ;
  simuPOP::lociList const &arg22_defvalue = vectoru() ;
  simuPOP::lociList *arg22 = (simuPOP::lociList *) &arg22_defvalue ;
  simuPOP::lociList const &arg23_defvalue = vectoru() ;
  simuPOP::lociList *arg23 = (simuPOP::lociList *) &arg23_defvalue ;
  simuPOP::lociList const &arg24_defvalue = vectoru() ;
  simuPOP::lociList *arg24 = (simuPOP::lociList *) &arg24_defvalue ;
  simuPOP::stringList const &arg25_defvalue = simuPOP::stringList() ;
  simuPOP::stringList *arg25 = (simuPOP::stringList *) &arg25_defvalue ;
  string const &arg26_defvalue = std::string() ;
  string *arg26 = (string *) &arg26_defvalue ;
  simuPOP::stringFunc const &arg27_defvalue = "" ;
  simuPOP::stringFunc *arg27 = (simuPOP::stringFunc *) &arg27_defvalue ;
  int arg28 = (int) 0 ;
  int arg29 = (int) -1 ;
  int arg30 = (int) 1 ;
  simuPOP::intList const &arg31_defvalue = vectori() ;
  simuPOP::intList *arg31 = (simuPOP::intList *) &arg31_defvalue ;
  simuPOP::intList const &arg32_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg32 = (simuPOP::intList *) &arg32_defvalue ;
  simuPOP::subPopList const &arg33_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg33 = (simuPOP::subPopList *) &arg33_defvalue ;
  simuPOP::stringList const &arg34_defvalue = vectorstr() ;
  simuPOP::stringList *arg34 = (simuPOP::stringList *) &arg34_defvalue ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  void *argp15 = 0 ;
  int res15 = 0 ;
  void *argp16 = 0 ;
  int res16 = 0 ;
  void *argp17 = 0 ;
  int res17 = 0 ;
  void *argp18 = 0 ;
  int res18 = 0 ;
  void *argp19 = 0 ;
  int res19 = 0 ;
  void *argp20 = 0 ;
  int res20 = 0 ;
  void *argp21 = 0 ;
  int res21 = 0 ;
  void *argp22 = 0 ;
  int res22 = 0 ;
  void *argp23 = 0 ;
  int res23 = 0 ;
  void *argp24 = 0 ;
  int res24 = 0 ;
  void *argp25 = 0 ;
  int res25 = 0 ;
  int res26 = SWIG_OLDOBJ ;
  void *argp27 = 0 ;
  int res27 = 0 ;
  int val28 ;
  int ecode28 = 0 ;
  int val29 ;
  int ecode29 = 0 ;
  int val30 ;
  int ecode30 = 0 ;
  void *argp31 = 0 ;
  int res31 = 0 ;
  void *argp32 = 0 ;
  int res32 = 0 ;
  void *argp33 = 0 ;
  int res33 = 0 ;
  void *argp34 = 0 ;
  int res34 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  PyObject * obj15 = 0 ;
  PyObject * obj16 = 0 ;
  PyObject * obj17 = 0 ;
  PyObject * obj18 = 0 ;
  PyObject * obj19 = 0 ;
  PyObject * obj20 = 0 ;
  PyObject * obj21 = 0 ;
  PyObject * obj22 = 0 ;
  PyObject * obj23 = 0 ;
  PyObject * obj24 = 0 ;
  PyObject * obj25 = 0 ;
  PyObject * obj26 = 0 ;
  PyObject * obj27 = 0 ;
  PyObject * obj28 = 0 ;
  PyObject * obj29 = 0 ;
  PyObject * obj30 = 0 ;
  PyObject * obj31 = 0 ;
  PyObject * obj32 = 0 ;
  PyObject * obj33 = 0 ;
  char *  kwnames[] = {
    (char *) "popSize",(char *) "numOfMales",(char *) "numOfAffected",(char *) "numOfSegSites",(char *) "numOfMutants",(char *) "alleleFreq",(char *) "heteroFreq",(char *) "homoFreq",(char *) "genoFreq",(char *) "haploFreq",(char *) "haploHeteroFreq",(char *) "haploHomoFreq",(char *) "sumOfInfo",(char *) "meanOfInfo",(char *) "varOfInfo",(char *) "maxOfInfo",(char *) "minOfInfo",(char *) "LD",(char *) "association",(char *) "neutrality",(char *) "structure",(char *) "HWE",(char *) "inbreeding",(char *) "effectiveSize",(char *) "vars",(char *) "suffix",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::Stat *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO:new_Stat",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15,&obj16,&obj17,&obj18,&obj19,&obj20,&obj21,&obj22,&obj23,&obj24,&obj25,&obj26,&obj27,&obj28,&obj29,&obj30,&obj31,&obj32,&obj33)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_bool(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Stat" "', argument " "1"" of type '" "bool""'");
    } 
    arg1 = static_cast< bool >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Stat" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Stat" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_Stat" "', argument " "4"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "4"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::lociList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Stat" "', argument " "5"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "5"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::lociList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_Stat" "', argument " "6"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "6"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::lociList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Stat" "', argument " "7"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "7"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::lociList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_Stat" "', argument " "8"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "8"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::lociList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_Stat" "', argument " "9"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "9"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::lociList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_Stat" "', argument " "10"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "10"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intMatrix * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_Stat" "', argument " "11"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "11"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intMatrix * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_Stat" "', argument " "12"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "12"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intMatrix * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_Stat" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::stringList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_Stat" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::stringList * >(argp14);
  }
  if (obj14) {
    res15 = SWIG_ConvertPtr(obj14, &argp15, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res15)) {
      SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "new_Stat" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp15) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg15 = reinterpret_cast< simuPOP::stringList * >(argp15);
  }
  if (obj15) {
    res16 = SWIG_ConvertPtr(obj15, &argp16, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res16)) {
      SWIG_exception_fail(SWIG_ArgError(res16), "in method '" "new_Stat" "', argument " "16"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp16) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "16"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg16 = reinterpret_cast< simuPOP::stringList * >(argp16);
  }
  if (obj16) {
    res17 = SWIG_ConvertPtr(obj16, &argp17, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res17)) {
      SWIG_exception_fail(SWIG_ArgError(res17), "in method '" "new_Stat" "', argument " "17"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp17) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "17"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg17 = reinterpret_cast< simuPOP::stringList * >(argp17);
  }
  if (obj17) {
    res18 = SWIG_ConvertPtr(obj17, &argp18, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res18)) {
      SWIG_exception_fail(SWIG_ArgError(res18), "in method '" "new_Stat" "', argument " "18"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp18) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "18"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg18 = reinterpret_cast< simuPOP::intMatrix * >(argp18);
  }
  if (obj18) {
    res19 = SWIG_ConvertPtr(obj18, &argp19, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res19)) {
      SWIG_exception_fail(SWIG_ArgError(res19), "in method '" "new_Stat" "', argument " "19"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp19) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "19"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg19 = reinterpret_cast< simuPOP::lociList * >(argp19);
  }
  if (obj19) {
    res20 = SWIG_ConvertPtr(obj19, &argp20, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res20)) {
      SWIG_exception_fail(SWIG_ArgError(res20), "in method '" "new_Stat" "', argument " "20"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp20) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "20"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg20 = reinterpret_cast< simuPOP::lociList * >(argp20);
  }
  if (obj20) {
    res21 = SWIG_ConvertPtr(obj20, &argp21, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res21)) {
      SWIG_exception_fail(SWIG_ArgError(res21), "in method '" "new_Stat" "', argument " "21"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp21) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "21"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg21 = reinterpret_cast< simuPOP::lociList * >(argp21);
  }
  if (obj21) {
    res22 = SWIG_ConvertPtr(obj21, &argp22, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res22)) {
      SWIG_exception_fail(SWIG_ArgError(res22), "in method '" "new_Stat" "', argument " "22"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp22) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "22"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg22 = reinterpret_cast< simuPOP::lociList * >(argp22);
  }
  if (obj22) {
    res23 = SWIG_ConvertPtr(obj22, &argp23, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res23)) {
      SWIG_exception_fail(SWIG_ArgError(res23), "in method '" "new_Stat" "', argument " "23"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp23) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "23"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg23 = reinterpret_cast< simuPOP::lociList * >(argp23);
  }
  if (obj23) {
    res24 = SWIG_ConvertPtr(obj23, &argp24, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res24)) {
      SWIG_exception_fail(SWIG_ArgError(res24), "in method '" "new_Stat" "', argument " "24"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp24) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "24"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg24 = reinterpret_cast< simuPOP::lociList * >(argp24);
  }
  if (obj24) {
    res25 = SWIG_ConvertPtr(obj24, &argp25, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res25)) {
      SWIG_exception_fail(SWIG_ArgError(res25), "in method '" "new_Stat" "', argument " "25"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp25) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "25"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg25 = reinterpret_cast< simuPOP::stringList * >(argp25);
  }
  if (obj25) {
    {
      std::string *ptr = (std::string *)0;
      res26 = SWIG_AsPtr_std_string(obj25, &ptr);
      if (!SWIG_IsOK(res26)) {
        SWIG_exception_fail(SWIG_ArgError(res26), "in method '" "new_Stat" "', argument " "26"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "26"" of type '" "string const &""'"); 
      }
      arg26 = ptr;
    }
  }
  if (obj26) {
    res27 = SWIG_ConvertPtr(obj26, &argp27, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res27)) {
      SWIG_exception_fail(SWIG_ArgError(res27), "in method '" "new_Stat" "', argument " "27"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp27) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "27"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg27 = reinterpret_cast< simuPOP::stringFunc * >(argp27);
  }
  if (obj27) {
    ecode28 = SWIG_AsVal_int(obj27, &val28);
    if (!SWIG_IsOK(ecode28)) {
      SWIG_exception_fail(SWIG_ArgError(ecode28), "in method '" "new_Stat" "', argument " "28"" of type '" "int""'");
    } 
    arg28 = static_cast< int >(val28);
  }
  if (obj28) {
    ecode29 = SWIG_AsVal_int(obj28, &val29);
    if (!SWIG_IsOK(ecode29)) {
      SWIG_exception_fail(SWIG_ArgError(ecode29), "in method '" "new_Stat" "', argument " "29"" of type '" "int""'");
    } 
    arg29 = static_cast< int >(val29);
  }
  if (obj29) {
    ecode30 = SWIG_AsVal_int(obj29, &val30);
    if (!SWIG_IsOK(ecode30)) {
      SWIG_exception_fail(SWIG_ArgError(ecode30), "in method '" "new_Stat" "', argument " "30"" of type '" "int""'");
    } 
    arg30 = static_cast< int >(val30);
  }
  if (obj30) {
    res31 = SWIG_ConvertPtr(obj30, &argp31, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res31)) {
      SWIG_exception_fail(SWIG_ArgError(res31), "in method '" "new_Stat" "', argument " "31"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp31) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "31"" of type '" "simuPOP::intList const &""'"); 
    }
    arg31 = reinterpret_cast< simuPOP::intList * >(argp31);
  }
  if (obj31) {
    res32 = SWIG_ConvertPtr(obj31, &argp32, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res32)) {
      SWIG_exception_fail(SWIG_ArgError(res32), "in method '" "new_Stat" "', argument " "32"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp32) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "32"" of type '" "simuPOP::intList const &""'"); 
    }
    arg32 = reinterpret_cast< simuPOP::intList * >(argp32);
  }
  if (obj32) {
    res33 = SWIG_ConvertPtr(obj32, &argp33, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res33)) {
      SWIG_exception_fail(SWIG_ArgError(res33), "in method '" "new_Stat" "', argument " "33"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp33) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "33"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg33 = reinterpret_cast< simuPOP::subPopList * >(argp33);
  }
  if (obj33) {
    res34 = SWIG_ConvertPtr(obj33, &argp34, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res34)) {
      SWIG_exception_fail(SWIG_ArgError(res34), "in method '" "new_Stat" "', argument " "34"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp34) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Stat" "', argument " "34"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg34 = reinterpret_cast< simuPOP::stringList * >(argp34);
  }
  {
    try
    {
      result = (simuPOP::Stat *)new simuPOP::Stat(arg1,arg2,arg3,(simuPOP::lociList const &)*arg4,(simuPOP::lociList const &)*arg5,(simuPOP::lociList const &)*arg6,(simuPOP::lociList const &)*arg7,(simuPOP::lociList const &)*arg8,(simuPOP::lociList const &)*arg9,(simuPOP::intMatrix const &)*arg10,(simuPOP::intMatrix const &)*arg11,(simuPOP::intMatrix const &)*arg12,(simuPOP::stringList const &)*arg13,(simuPOP::stringList const &)*arg14,(simuPOP::stringList const &)*arg15,(simuPOP::stringList const &)*arg16,(simuPOP::stringList const &)*arg17,(simuPOP::intMatrix const &)*arg18,(simuPOP::lociList const &)*arg19,(simuPOP::lociList const &)*arg20,(simuPOP::lociList const &)*arg21,(simuPOP::lociList const &)*arg22,(simuPOP::lociList const &)*arg23,(simuPOP::lociList const &)*arg24,(simuPOP::stringList const &)*arg25,(string const &)*arg26,(simuPOP::stringFunc const &)*arg27,arg28,arg29,arg30,(simuPOP::intList const &)*arg31,(simuPOP::intList const &)*arg32,(simuPOP::subPopList const &)*arg33,(simuPOP::stringList const &)*arg34);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Stat, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  if (SWIG_IsNewObj(res16)) delete arg16;
  if (SWIG_IsNewObj(res17)) delete arg17;
  if (SWIG_IsNewObj(res18)) delete arg18;
  if (SWIG_IsNewObj(res19)) delete arg19;
  if (SWIG_IsNewObj(res20)) delete arg20;
  if (SWIG_IsNewObj(res21)) delete arg21;
  if (SWIG_IsNewObj(res22)) delete arg22;
  if (SWIG_IsNewObj(res23)) delete arg23;
  if (SWIG_IsNewObj(res24)) delete arg24;
  if (SWIG_IsNewObj(res25)) delete arg25;
  if (SWIG_IsNewObj(res26)) delete arg26;
  if (SWIG_IsNewObj(res27)) delete arg27;
  if (SWIG_IsNewObj(res31)) delete arg31;
  if (SWIG_IsNewObj(res32)) delete arg32;
  if (SWIG_IsNewObj(res33)) delete arg33;
  if (SWIG_IsNewObj(res34)) delete arg34;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  if (SWIG_IsNewObj(res16)) delete arg16;
  if (SWIG_IsNewObj(res17)) delete arg17;
  if (SWIG_IsNewObj(res18)) delete arg18;
  if (SWIG_IsNewObj(res19)) delete arg19;
  if (SWIG_IsNewObj(res20)) delete arg20;
  if (SWIG_IsNewObj(res21)) delete arg21;
  if (SWIG_IsNewObj(res22)) delete arg22;
  if (SWIG_IsNewObj(res23)) delete arg23;
  if (SWIG_IsNewObj(res24)) delete arg24;
  if (SWIG_IsNewObj(res25)) delete arg25;
  if (SWIG_IsNewObj(res26)) delete arg26;
  if (SWIG_IsNewObj(res27)) delete arg27;
  if (SWIG_IsNewObj(res31)) delete arg31;
  if (SWIG_IsNewObj(res32)) delete arg32;
  if (SWIG_IsNewObj(res33)) delete arg33;
  if (SWIG_IsNewObj(res34)) delete arg34;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Stat(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Stat *arg1 = (simuPOP::Stat *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Stat, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Stat" "', argument " "1"" of type '" "simuPOP::Stat *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Stat * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Stat_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Stat, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Stat_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyOutput(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = std::string() ;
  string *arg1 = (string *) &arg1_defvalue ;
  simuPOP::stringFunc const &arg2_defvalue = ">" ;
  simuPOP::stringFunc *arg2 = (simuPOP::stringFunc *) &arg2_defvalue ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "msg",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyOutput *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_PyOutput",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PyOutput" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyOutput" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringFunc * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PyOutput" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyOutput" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyOutput" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_PyOutput" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyOutput" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyOutput" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyOutput" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyOutput" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::PyOutput *)new simuPOP::PyOutput((string const &)*arg1,(simuPOP::stringFunc const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyOutput, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyOutput(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyOutput *arg1 = (simuPOP::PyOutput *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyOutput, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyOutput" "', argument " "1"" of type '" "simuPOP::PyOutput *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyOutput * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyOutput_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyOutput, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyOutput_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Dumper(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  bool arg1 = (bool) true ;
  bool arg2 = (bool) true ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 1 ;
  UINT arg5 = (UINT) 100 ;
  simuPOP::uintList const &arg6_defvalue = vectoru() ;
  simuPOP::uintList *arg6 = (simuPOP::uintList *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = ">" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  int arg8 = (int) 0 ;
  int arg9 = (int) -1 ;
  int arg10 = (int) 1 ;
  simuPOP::intList const &arg11_defvalue = vectori() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::intList const &arg12_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::subPopList const &arg13_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg13 = (simuPOP::subPopList *) &arg13_defvalue ;
  simuPOP::stringList const &arg14_defvalue = simuPOP::stringList() ;
  simuPOP::stringList *arg14 = (simuPOP::stringList *) &arg14_defvalue ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  char *  kwnames[] = {
    (char *) "genotype",(char *) "structure",(char *) "ancGens",(char *) "width",(char *) "max",(char *) "loci",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::Dumper *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOO:new_Dumper",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_bool(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Dumper" "', argument " "1"" of type '" "bool""'");
    } 
    arg1 = static_cast< bool >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_bool(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Dumper" "', argument " "2"" of type '" "bool""'");
    } 
    arg2 = static_cast< bool >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Dumper" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Dumper" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Dumper" "', argument " "5"" of type '" "UINT""'");
    } 
    arg5 = static_cast< UINT >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_Dumper" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Dumper" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Dumper" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_Dumper" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_Dumper" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_Dumper" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_Dumper" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_Dumper" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::subPopList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_Dumper" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Dumper" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::stringList * >(argp14);
  }
  {
    try
    {
      result = (simuPOP::Dumper *)new simuPOP::Dumper(arg1,arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,(simuPOP::uintList const &)*arg6,(simuPOP::stringFunc const &)*arg7,arg8,arg9,arg10,(simuPOP::intList const &)*arg11,(simuPOP::intList const &)*arg12,(simuPOP::subPopList const &)*arg13,(simuPOP::stringList const &)*arg14);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Dumper, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Dumper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Dumper *arg1 = (simuPOP::Dumper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Dumper, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Dumper" "', argument " "1"" of type '" "simuPOP::Dumper *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Dumper * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Dumper_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Dumper, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Dumper_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SavePopulation(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::SavePopulation *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_SavePopulation",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SavePopulation" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SavePopulation" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SavePopulation" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SavePopulation" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_SavePopulation" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_SavePopulation" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SavePopulation" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_SavePopulation" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SavePopulation" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_SavePopulation" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SavePopulation" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_SavePopulation" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SavePopulation" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::SavePopulation *)new simuPOP::SavePopulation((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SavePopulation, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SavePopulation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SavePopulation *arg1 = (simuPOP::SavePopulation *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SavePopulation, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SavePopulation" "', argument " "1"" of type '" "simuPOP::SavePopulation *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SavePopulation * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SavePopulation_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SavePopulation, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SavePopulation_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InitSex(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  double arg1 = (double) 0.5 ;
  double arg2 = (double) -1 ;
  simuPOP::intList const &arg3_defvalue = vectori() ;
  simuPOP::intList *arg3 = (simuPOP::intList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  double val1 ;
  int ecode1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "maleFreq",(char *) "maleProp",(char *) "sex",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InitSex *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOO:new_InitSex",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_double(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_InitSex" "', argument " "1"" of type '" "double""'");
    } 
    arg1 = static_cast< double >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_double(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InitSex" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = static_cast< double >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InitSex" "', argument " "3"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitSex" "', argument " "3"" of type '" "simuPOP::intList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::intList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InitSex" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_InitSex" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_InitSex" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_InitSex" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitSex" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_InitSex" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitSex" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_InitSex" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitSex" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_InitSex" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitSex" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::InitSex *)new simuPOP::InitSex(arg1,arg2,(simuPOP::intList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InitSex, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitSex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InitSex *arg1 = (simuPOP::InitSex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InitSex, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitSex" "', argument " "1"" of type '" "simuPOP::InitSex *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InitSex * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitSex_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InitSex, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InitSex_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InitInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatListFunc *arg1 = 0 ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "values",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InitInfo *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOO:new_InitInfo",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitInfo" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitInfo" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatListFunc * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InitInfo" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InitInfo" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InitInfo" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_InitInfo" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitInfo" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_InitInfo" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitInfo" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_InitInfo" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitInfo" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_InitInfo" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitInfo" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::InitInfo *)new simuPOP::InitInfo((simuPOP::floatListFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InitInfo, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InitInfo *arg1 = (simuPOP::InitInfo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InitInfo, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitInfo" "', argument " "1"" of type '" "simuPOP::InitInfo *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InitInfo * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitInfo_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InitInfo, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InitInfo_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InitGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatListFunc const &arg1_defvalue = vectorf() ;
  simuPOP::floatListFunc *arg1 = (simuPOP::floatListFunc *) &arg1_defvalue ;
  simuPOP::uintList const &arg2_defvalue = vectoru() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::floatListFunc const &arg3_defvalue = vectorf() ;
  simuPOP::floatListFunc *arg3 = (simuPOP::floatListFunc *) &arg3_defvalue ;
  simuPOP::intMatrix const &arg4_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg4 = (simuPOP::intMatrix *) &arg4_defvalue ;
  simuPOP::intMatrix const &arg5_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg5 = (simuPOP::intMatrix *) &arg5_defvalue ;
  simuPOP::lociList const &arg6_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg6 = (simuPOP::lociList *) &arg6_defvalue ;
  simuPOP::uintList const &arg7_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg7 = (simuPOP::uintList *) &arg7_defvalue ;
  int arg8 = (int) 0 ;
  int arg9 = (int) 1 ;
  int arg10 = (int) 1 ;
  simuPOP::intList const &arg11_defvalue = vectori() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::intList const &arg12_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::subPopList const &arg13_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg13 = (simuPOP::subPopList *) &arg13_defvalue ;
  simuPOP::stringList const &arg14_defvalue = vectorstr() ;
  simuPOP::stringList *arg14 = (simuPOP::stringList *) &arg14_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  char *  kwnames[] = {
    (char *) "freq",(char *) "genotype",(char *) "prop",(char *) "haplotypes",(char *) "genotypes",(char *) "loci",(char *) "ploidy",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InitGenotype *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOO:new_InitGenotype",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitGenotype" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatListFunc * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_InitGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InitGenotype" "', argument " "3"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "3"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatListFunc * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_InitGenotype" "', argument " "4"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "4"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::intMatrix * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_InitGenotype" "', argument " "5"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "5"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intMatrix * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_InitGenotype" "', argument " "6"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "6"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::lociList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_InitGenotype" "', argument " "7"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "7"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::uintList * >(argp7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_InitGenotype" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_InitGenotype" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_InitGenotype" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_InitGenotype" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_InitGenotype" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_InitGenotype" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::subPopList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_InitGenotype" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitGenotype" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::stringList * >(argp14);
  }
  {
    try
    {
      result = (simuPOP::InitGenotype *)new simuPOP::InitGenotype((simuPOP::floatListFunc const &)*arg1,(simuPOP::uintList const &)*arg2,(simuPOP::floatListFunc const &)*arg3,(simuPOP::intMatrix const &)*arg4,(simuPOP::intMatrix const &)*arg5,(simuPOP::lociList const &)*arg6,(simuPOP::uintList const &)*arg7,arg8,arg9,arg10,(simuPOP::intList const &)*arg11,(simuPOP::intList const &)*arg12,(simuPOP::subPopList const &)*arg13,(simuPOP::stringList const &)*arg14);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InitGenotype, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InitGenotype *arg1 = (simuPOP::InitGenotype *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InitGenotype, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitGenotype" "', argument " "1"" of type '" "simuPOP::InitGenotype *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InitGenotype * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitGenotype_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InitGenotype, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InitGenotype_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InitLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::intList const &arg1_defvalue = vectori() ;
  simuPOP::intList *arg1 = (simuPOP::intList *) &arg1_defvalue ;
  int arg2 = (int) PER_ALLELE ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) 1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "lineage",(char *) "mode",(char *) "loci",(char *) "ploidy",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::InitLineage *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_InitLineage",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitLineage" "', argument " "1"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "1"" of type '" "simuPOP::intList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::intList * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InitLineage" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_InitLineage" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_InitLineage" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_InitLineage" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_InitLineage" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_InitLineage" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_InitLineage" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_InitLineage" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_InitLineage" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_InitLineage" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitLineage" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::InitLineage *)new simuPOP::InitLineage((simuPOP::intList const &)*arg1,arg2,(simuPOP::lociList const &)*arg3,(simuPOP::uintList const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InitLineage, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitLineage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InitLineage *arg1 = (simuPOP::InitLineage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InitLineage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitLineage" "', argument " "1"" of type '" "simuPOP::InitLineage *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InitLineage * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitLineage_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InitLineage, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InitLineage_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_IdTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  int arg1 = (int) 0 ;
  int arg2 = (int) -1 ;
  int arg3 = (int) 1 ;
  simuPOP::intList const &arg4_defvalue = vectori() ;
  simuPOP::intList *arg4 = (simuPOP::intList *) &arg4_defvalue ;
  simuPOP::intList const &arg5_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::subPopList const &arg6_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg6 = (simuPOP::subPopList *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = "" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::IdTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_IdTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_IdTagger" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = static_cast< int >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_IdTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_IdTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_IdTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IdTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::intList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_IdTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IdTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_IdTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IdTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::subPopList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_IdTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IdTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_IdTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IdTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::IdTagger *)new simuPOP::IdTagger(arg1,arg2,arg3,(simuPOP::intList const &)*arg4,(simuPOP::intList const &)*arg5,(simuPOP::subPopList const &)*arg6,(simuPOP::stringFunc const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__IdTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_IdTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::IdTagger *arg1 = (simuPOP::IdTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__IdTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IdTagger" "', argument " "1"" of type '" "simuPOP::IdTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::IdTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IdTagger_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::IdTagger *arg1 = (simuPOP::IdTagger *) 0 ;
  ULONG arg2 = (ULONG) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "startID", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|O:IdTagger_reset",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__IdTagger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IdTagger_reset" "', argument " "1"" of type '" "simuPOP::IdTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::IdTagger * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IdTagger_reset" "', argument " "2"" of type '" "ULONG""'");
    } 
    arg2 = static_cast< ULONG >(val2);
  }
  {
    try
    {
      (arg1)->reset(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *IdTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__IdTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *IdTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_InheritTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  InheritanceType arg1 = (InheritanceType) PATERNAL ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "mode",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::InheritTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_InheritTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_InheritTagger" "', argument " "1"" of type '" "InheritanceType""'");
    } 
    arg1 = static_cast< InheritanceType >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InheritTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_InheritTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_InheritTagger" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_InheritTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InheritTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_InheritTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InheritTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_InheritTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InheritTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_InheritTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InheritTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_InheritTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InheritTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::InheritTagger *)new simuPOP::InheritTagger(arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringFunc const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__InheritTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InheritTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::InheritTagger *arg1 = (simuPOP::InheritTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__InheritTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InheritTagger" "', argument " "1"" of type '" "simuPOP::InheritTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::InheritTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InheritTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__InheritTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *InheritTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SummaryTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  InheritanceType arg1 = (InheritanceType) MEAN ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "mode",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::SummaryTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_SummaryTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SummaryTagger" "', argument " "1"" of type '" "InheritanceType""'");
    } 
    arg1 = static_cast< InheritanceType >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SummaryTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SummaryTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_SummaryTagger" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_SummaryTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SummaryTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_SummaryTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SummaryTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_SummaryTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SummaryTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_SummaryTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SummaryTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_SummaryTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SummaryTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::SummaryTagger *)new simuPOP::SummaryTagger(arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringFunc const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SummaryTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SummaryTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SummaryTagger *arg1 = (simuPOP::SummaryTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SummaryTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SummaryTagger" "', argument " "1"" of type '" "simuPOP::SummaryTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SummaryTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SummaryTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SummaryTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SummaryTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ParentsTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  int arg1 = (int) 0 ;
  int arg2 = (int) -1 ;
  int arg3 = (int) 1 ;
  simuPOP::intList const &arg4_defvalue = vectori() ;
  simuPOP::intList *arg4 = (simuPOP::intList *) &arg4_defvalue ;
  simuPOP::intList const &arg5_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::subPopList const &arg6_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg6 = (simuPOP::subPopList *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = "" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = simuPOP::stringList("father_idx", "mother_idx") ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::ParentsTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_ParentsTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ParentsTagger" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = static_cast< int >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ParentsTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_ParentsTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_ParentsTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentsTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::intList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_ParentsTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentsTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_ParentsTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentsTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::subPopList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_ParentsTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentsTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_ParentsTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ParentsTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::ParentsTagger *)new simuPOP::ParentsTagger(arg1,arg2,arg3,(simuPOP::intList const &)*arg4,(simuPOP::intList const &)*arg5,(simuPOP::subPopList const &)*arg6,(simuPOP::stringFunc const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ParentsTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ParentsTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ParentsTagger *arg1 = (simuPOP::ParentsTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ParentsTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ParentsTagger" "', argument " "1"" of type '" "simuPOP::ParentsTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ParentsTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ParentsTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ParentsTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ParentsTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_OffspringTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  int arg1 = (int) 0 ;
  int arg2 = (int) -1 ;
  int arg3 = (int) 1 ;
  simuPOP::intList const &arg4_defvalue = vectori() ;
  simuPOP::intList *arg4 = (simuPOP::intList *) &arg4_defvalue ;
  simuPOP::intList const &arg5_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::subPopList const &arg6_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg6 = (simuPOP::subPopList *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = "" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = simuPOP::stringList("offspring_idx") ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::OffspringTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_OffspringTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    ecode1 = SWIG_AsVal_int(obj0, &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_OffspringTagger" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = static_cast< int >(val1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_OffspringTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_OffspringTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_OffspringTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringTagger" "', argument " "4"" of type '" "simuPOP::intList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::intList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_OffspringTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_OffspringTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringTagger" "', argument " "6"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::subPopList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_OffspringTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringTagger" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_OffspringTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OffspringTagger" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::OffspringTagger *)new simuPOP::OffspringTagger(arg1,arg2,arg3,(simuPOP::intList const &)*arg4,(simuPOP::intList const &)*arg5,(simuPOP::subPopList const &)*arg6,(simuPOP::stringFunc const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__OffspringTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OffspringTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::OffspringTagger *arg1 = (simuPOP::OffspringTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__OffspringTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OffspringTagger" "', argument " "1"" of type '" "simuPOP::OffspringTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::OffspringTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *OffspringTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__OffspringTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *OffspringTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PedigreeTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string const &arg1_defvalue = "ind_id" ;
  string *arg1 = (string *) &arg1_defvalue ;
  simuPOP::stringFunc const &arg2_defvalue = "" ;
  simuPOP::stringFunc *arg2 = (simuPOP::stringFunc *) &arg2_defvalue ;
  simuPOP::stringList const &arg3_defvalue = vectorstr() ;
  simuPOP::stringList *arg3 = (simuPOP::stringList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = vectoru() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = simuPOP::stringList("father_id", "mother_id") ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "idField",(char *) "output",(char *) "outputFields",(char *) "outputLoci",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PedigreeTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_PedigreeTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    {
      std::string *ptr = (std::string *)0;
      res1 = SWIG_AsPtr_std_string(obj0, &ptr);
      if (!SWIG_IsOK(res1)) {
        SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PedigreeTagger" "', argument " "1"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "1"" of type '" "string const &""'"); 
      }
      arg1 = ptr;
    }
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PedigreeTagger" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringFunc * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PedigreeTagger" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_PedigreeTagger" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PedigreeTagger" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PedigreeTagger" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PedigreeTagger" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PedigreeTagger" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PedigreeTagger" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PedigreeTagger" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PedigreeTagger" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PedigreeTagger" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::PedigreeTagger *)new simuPOP::PedigreeTagger((string const &)*arg1,(simuPOP::stringFunc const &)*arg2,(simuPOP::stringList const &)*arg3,(simuPOP::uintList const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PedigreeTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PedigreeTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PedigreeTagger *arg1 = (simuPOP::PedigreeTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PedigreeTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PedigreeTagger" "', argument " "1"" of type '" "simuPOP::PedigreeTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PedigreeTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PedigreeTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PedigreeTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PedigreeTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) NULL ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "output",(char *) "infoFields", NULL 
  };
  simuPOP::PyTagger *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_PyTagger",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    arg1 = obj0;
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PyTagger" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PyTagger" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyTagger" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_PyTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyTagger" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_PyTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyTagger" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyTagger" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyTagger" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyTagger" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::PyTagger *)new simuPOP::PyTagger(arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringFunc const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyTagger, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyTagger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyTagger *arg1 = (simuPOP::PyTagger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyTagger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyTagger" "', argument " "1"" of type '" "simuPOP::PyTagger *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyTagger * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyTagger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyTagger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyTagger_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Migrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatMatrix const &arg1_defvalue = simuPOP::floatMatrix() ;
  simuPOP::floatMatrix *arg1 = (simuPOP::floatMatrix *) &arg1_defvalue ;
  int arg2 = (int) BY_PROBABILITY ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr(1, "migrate_to") ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "mode",(char *) "toSubPops",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::Migrator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOO:new_Migrator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Migrator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatMatrix * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Migrator" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Migrator" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Migrator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Migrator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Migrator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Migrator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_Migrator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_Migrator" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_Migrator" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Migrator" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::Migrator *)new simuPOP::Migrator((simuPOP::floatMatrix const &)*arg1,arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Migrator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Migrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Migrator *arg1 = (simuPOP::Migrator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Migrator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Migrator" "', argument " "1"" of type '" "simuPOP::Migrator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Migrator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Migrator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Migrator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Migrator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_BackwardMigrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatMatrix const &arg1_defvalue = simuPOP::floatMatrix() ;
  simuPOP::floatMatrix *arg1 = (simuPOP::floatMatrix *) &arg1_defvalue ;
  int arg2 = (int) BY_PROBABILITY ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr(1, "migrate_to") ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "mode",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::BackwardMigrator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_BackwardMigrator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BackwardMigrator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BackwardMigrator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatMatrix * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BackwardMigrator" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_BackwardMigrator" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_BackwardMigrator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_BackwardMigrator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BackwardMigrator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BackwardMigrator" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_BackwardMigrator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BackwardMigrator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_BackwardMigrator" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BackwardMigrator" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_BackwardMigrator" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BackwardMigrator" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::BackwardMigrator *)new simuPOP::BackwardMigrator((simuPOP::floatMatrix const &)*arg1,arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BackwardMigrator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BackwardMigrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BackwardMigrator *arg1 = (simuPOP::BackwardMigrator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BackwardMigrator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BackwardMigrator" "', argument " "1"" of type '" "simuPOP::BackwardMigrator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BackwardMigrator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BackwardMigrator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BackwardMigrator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BackwardMigrator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SplitSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::subPopList const &arg1_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) &arg1_defvalue ;
  vectoru const &arg2_defvalue = vectoru() ;
  vectoru *arg2 = (vectoru *) &arg2_defvalue ;
  vectorf const &arg3_defvalue = vectorf() ;
  vectorf *arg3 = (vectorf *) &arg3_defvalue ;
  simuPOP::stringList arg4 = (simuPOP::stringList) (simuPOP::stringList)vectorstr() ;
  bool arg5 = (bool) true ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  void *argp4 ;
  int res4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "subPops",(char *) "sizes",(char *) "proportions",(char *) "names",(char *) "randomize",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "infoFields", NULL 
  };
  simuPOP::SplitSubPops *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOO:new_SplitSubPops",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SplitSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  }
  if (obj1) {
    {
      std::vector< size_t,std::allocator< size_t > > *ptr = (std::vector< size_t,std::allocator< size_t > > *)0;
      res2 = swig::asptr(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SplitSubPops" "', argument " "2"" of type '" "vectoru const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "2"" of type '" "vectoru const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    {
      std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
      res3 = swig::asptr(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_SplitSubPops" "', argument " "3"" of type '" "vectorf const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "3"" of type '" "vectorf const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    {
      res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SplitSubPops" "', argument " "4"" of type '" "simuPOP::stringList const""'"); 
      }  
      if (!argp4) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "4"" of type '" "simuPOP::stringList const""'");
      } else {
        simuPOP::stringList * temp = reinterpret_cast< simuPOP::stringList * >(argp4);
        arg4 = *temp;
        if (SWIG_IsNewObj(res4)) delete temp;
      }
    }
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_bool(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SplitSubPops" "', argument " "5"" of type '" "bool""'");
    } 
    arg5 = static_cast< bool >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SplitSubPops" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_SplitSubPops" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_SplitSubPops" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_SplitSubPops" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_SplitSubPops" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_SplitSubPops" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SplitSubPops" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::SplitSubPops *)new simuPOP::SplitSubPops((simuPOP::subPopList const &)*arg1,(vectoru const &)*arg2,(vectorf const &)*arg3,arg4,arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SplitSubPops, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SplitSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SplitSubPops *arg1 = (simuPOP::SplitSubPops *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SplitSubPops, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SplitSubPops" "', argument " "1"" of type '" "simuPOP::SplitSubPops *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SplitSubPops * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SplitSubPops_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SplitSubPops, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SplitSubPops_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MergeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::subPopList const &arg1_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) &arg1_defvalue ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "subPops",(char *) "name",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "infoFields", NULL 
  };
  simuPOP::MergeSubPops *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_MergeSubPops",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MergeSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MergeSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MergeSubPops" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MergeSubPops" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MergeSubPops" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MergeSubPops" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MergeSubPops" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MergeSubPops" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MergeSubPops" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MergeSubPops" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MergeSubPops" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MergeSubPops" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MergeSubPops" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::MergeSubPops *)new simuPOP::MergeSubPops((simuPOP::subPopList const &)*arg1,(string const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MergeSubPops, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MergeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MergeSubPops *arg1 = (simuPOP::MergeSubPops *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MergeSubPops, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MergeSubPops" "', argument " "1"" of type '" "simuPOP::MergeSubPops *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MergeSubPops * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MergeSubPops_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MergeSubPops, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MergeSubPops_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ResizeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::subPopList const &arg1_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg1 = (simuPOP::subPopList *) &arg1_defvalue ;
  vectoru const &arg2_defvalue = vectoru() ;
  vectoru *arg2 = (vectoru *) &arg2_defvalue ;
  vectorf const &arg3_defvalue = vectorf() ;
  vectorf *arg3 = (vectorf *) &arg3_defvalue ;
  bool arg4 = (bool) true ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  bool val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "subPops",(char *) "sizes",(char *) "proportions",(char *) "propagate",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "infoFields", NULL 
  };
  simuPOP::ResizeSubPops *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOO:new_ResizeSubPops",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ResizeSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "1"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::subPopList * >(argp1);
  }
  if (obj1) {
    {
      std::vector< size_t,std::allocator< size_t > > *ptr = (std::vector< size_t,std::allocator< size_t > > *)0;
      res2 = swig::asptr(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ResizeSubPops" "', argument " "2"" of type '" "vectoru const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "2"" of type '" "vectoru const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    {
      std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
      res3 = swig::asptr(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_ResizeSubPops" "', argument " "3"" of type '" "vectorf const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "3"" of type '" "vectorf const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_bool(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_ResizeSubPops" "', argument " "4"" of type '" "bool""'");
    } 
    arg4 = static_cast< bool >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_ResizeSubPops" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_ResizeSubPops" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_ResizeSubPops" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_ResizeSubPops" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_ResizeSubPops" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_ResizeSubPops" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ResizeSubPops" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::ResizeSubPops *)new simuPOP::ResizeSubPops((simuPOP::subPopList const &)*arg1,(vectoru const &)*arg2,(vectorf const &)*arg3,arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ResizeSubPops, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ResizeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ResizeSubPops *arg1 = (simuPOP::ResizeSubPops *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ResizeSubPops, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ResizeSubPops" "', argument " "1"" of type '" "simuPOP::ResizeSubPops *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ResizeSubPops * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ResizeSubPops_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ResizeSubPops, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ResizeSubPops_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_BaseMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::uintListFunc const &arg3_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg3 = (simuPOP::uintListFunc *) &arg3_defvalue ;
  simuPOP::uintListFunc const &arg4_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg4 = (simuPOP::uintListFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  simuPOP::stringFunc const &arg6_defvalue = "" ;
  simuPOP::stringFunc *arg6 = (simuPOP::stringFunc *) &arg6_defvalue ;
  int arg7 = (int) 0 ;
  int arg8 = (int) -1 ;
  int arg9 = (int) 1 ;
  simuPOP::intList const &arg10_defvalue = vectori() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::intList const &arg11_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::subPopList const &arg12_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg12 = (simuPOP::subPopList *) &arg12_defvalue ;
  simuPOP::stringList const &arg13_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg13 = (simuPOP::stringList *) &arg13_defvalue ;
  int arg14 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "loci",(char *) "mapIn",(char *) "mapOut",(char *) "context",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::BaseMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOO:new_BaseMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BaseMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_BaseMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_BaseMutator" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintListFunc * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_BaseMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintListFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_BaseMutator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BaseMutator" "', argument " "6"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "6"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::stringFunc * >(argp6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_BaseMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_BaseMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_BaseMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_BaseMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_BaseMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_BaseMutator" "', argument " "12"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "12"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::subPopList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_BaseMutator" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseMutator" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::stringList * >(argp13);
  }
  if (obj13) {
    ecode14 = SWIG_AsVal_int(obj13, &val14);
    if (!SWIG_IsOK(ecode14)) {
      SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "new_BaseMutator" "', argument " "14"" of type '" "int""'");
    } 
    arg14 = static_cast< int >(val14);
  }
  {
    try
    {
      result = (simuPOP::BaseMutator *)new simuPOP::BaseMutator((simuPOP::floatList const &)*arg1,(simuPOP::lociList const &)*arg2,(simuPOP::uintListFunc const &)*arg3,(simuPOP::uintListFunc const &)*arg4,arg5,(simuPOP::stringFunc const &)*arg6,arg7,arg8,arg9,(simuPOP::intList const &)*arg10,(simuPOP::intList const &)*arg11,(simuPOP::subPopList const &)*arg12,(simuPOP::stringList const &)*arg13,arg14);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BaseMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseMutator *arg1 = (simuPOP::BaseMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BaseMutator" "', argument " "1"" of type '" "simuPOP::BaseMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BaseMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BaseMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BaseMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MatrixMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatMatrix *arg1 = 0 ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::uintListFunc const &arg3_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg3 = (simuPOP::uintListFunc *) &arg3_defvalue ;
  simuPOP::uintListFunc const &arg4_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg4 = (simuPOP::uintListFunc *) &arg4_defvalue ;
  simuPOP::stringFunc const &arg5_defvalue = "" ;
  simuPOP::stringFunc *arg5 = (simuPOP::stringFunc *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::subPopList const &arg11_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg11 = (simuPOP::subPopList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  int arg13 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "loci",(char *) "mapIn",(char *) "mapOut",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::MatrixMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOOOO:new_MatrixMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MatrixMutator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "1"" of type '" "simuPOP::floatMatrix const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatMatrix * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MatrixMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MatrixMutator" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "3"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintListFunc * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_MatrixMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintListFunc * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_MatrixMutator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringFunc * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MatrixMutator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_MatrixMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_MatrixMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MatrixMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MatrixMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_MatrixMutator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::subPopList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_MatrixMutator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixMutator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  if (obj12) {
    ecode13 = SWIG_AsVal_int(obj12, &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "new_MatrixMutator" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = static_cast< int >(val13);
  }
  {
    try
    {
      result = (simuPOP::MatrixMutator *)new simuPOP::MatrixMutator((simuPOP::floatMatrix const &)*arg1,(simuPOP::lociList const &)*arg2,(simuPOP::uintListFunc const &)*arg3,(simuPOP::uintListFunc const &)*arg4,(simuPOP::stringFunc const &)*arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::subPopList const &)*arg11,(simuPOP::stringList const &)*arg12,arg13);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MatrixMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MatrixMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MatrixMutator *arg1 = (simuPOP::MatrixMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MatrixMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MatrixMutator" "', argument " "1"" of type '" "simuPOP::MatrixMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MatrixMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MatrixMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MatrixMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MatrixMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_KAlleleMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  UINT arg1 ;
  simuPOP::floatList const &arg2_defvalue = vectorf() ;
  simuPOP::floatList *arg2 = (simuPOP::floatList *) &arg2_defvalue ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::uintListFunc const &arg4_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg4 = (simuPOP::uintListFunc *) &arg4_defvalue ;
  simuPOP::uintListFunc const &arg5_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg5 = (simuPOP::uintListFunc *) &arg5_defvalue ;
  simuPOP::stringFunc const &arg6_defvalue = "" ;
  simuPOP::stringFunc *arg6 = (simuPOP::stringFunc *) &arg6_defvalue ;
  int arg7 = (int) 0 ;
  int arg8 = (int) -1 ;
  int arg9 = (int) 1 ;
  simuPOP::intList const &arg10_defvalue = vectori() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::intList const &arg11_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::subPopList const &arg12_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg12 = (simuPOP::subPopList *) &arg12_defvalue ;
  simuPOP::stringList const &arg13_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg13 = (simuPOP::stringList *) &arg13_defvalue ;
  int arg14 = (int) FROM_INFO ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  int val14 ;
  int ecode14 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  char *  kwnames[] = {
    (char *) "k",(char *) "rates",(char *) "loci",(char *) "mapIn",(char *) "mapOut",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::KAlleleMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOOOOO:new_KAlleleMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_KAlleleMutator" "', argument " "1"" of type '" "UINT""'");
  } 
  arg1 = static_cast< UINT >(val1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_KAlleleMutator" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "2"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::floatList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_KAlleleMutator" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_KAlleleMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "4"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintListFunc * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_KAlleleMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::uintListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_KAlleleMutator" "', argument " "6"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "6"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::stringFunc * >(argp6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_KAlleleMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_KAlleleMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_KAlleleMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_KAlleleMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_KAlleleMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_KAlleleMutator" "', argument " "12"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "12"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::subPopList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_KAlleleMutator" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KAlleleMutator" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::stringList * >(argp13);
  }
  if (obj13) {
    ecode14 = SWIG_AsVal_int(obj13, &val14);
    if (!SWIG_IsOK(ecode14)) {
      SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "new_KAlleleMutator" "', argument " "14"" of type '" "int""'");
    } 
    arg14 = static_cast< int >(val14);
  }
  {
    try
    {
      result = (simuPOP::KAlleleMutator *)new simuPOP::KAlleleMutator(arg1,(simuPOP::floatList const &)*arg2,(simuPOP::lociList const &)*arg3,(simuPOP::uintListFunc const &)*arg4,(simuPOP::uintListFunc const &)*arg5,(simuPOP::stringFunc const &)*arg6,arg7,arg8,arg9,(simuPOP::intList const &)*arg10,(simuPOP::intList const &)*arg11,(simuPOP::subPopList const &)*arg12,(simuPOP::stringList const &)*arg13,arg14);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__KAlleleMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_KAlleleMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::KAlleleMutator *arg1 = (simuPOP::KAlleleMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__KAlleleMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_KAlleleMutator" "', argument " "1"" of type '" "simuPOP::KAlleleMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::KAlleleMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *KAlleleMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__KAlleleMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *KAlleleMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_StepwiseMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  double arg3 = (double) 0.5 ;
  UINT arg4 = (UINT) 0 ;
  simuPOP::floatListFunc const &arg5_defvalue = simuPOP::floatListFunc(1.0) ;
  simuPOP::floatListFunc *arg5 = (simuPOP::floatListFunc *) &arg5_defvalue ;
  simuPOP::uintListFunc const &arg6_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg6 = (simuPOP::uintListFunc *) &arg6_defvalue ;
  simuPOP::uintListFunc const &arg7_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg7 = (simuPOP::uintListFunc *) &arg7_defvalue ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  int arg9 = (int) 0 ;
  int arg10 = (int) -1 ;
  int arg11 = (int) 1 ;
  simuPOP::intList const &arg12_defvalue = vectori() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::intList const &arg13_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg13 = (simuPOP::intList *) &arg13_defvalue ;
  simuPOP::subPopList const &arg14_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg14 = (simuPOP::subPopList *) &arg14_defvalue ;
  simuPOP::stringList const &arg15_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg15 = (simuPOP::stringList *) &arg15_defvalue ;
  int arg16 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  void *argp15 = 0 ;
  int res15 = 0 ;
  int val16 ;
  int ecode16 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  PyObject * obj15 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "loci",(char *) "incProb",(char *) "maxAllele",(char *) "mutStep",(char *) "mapIn",(char *) "mapOut",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::StepwiseMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOOOO:new_StepwiseMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StepwiseMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_StepwiseMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_double(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_StepwiseMutator" "', argument " "3"" of type '" "double""'");
    } 
    arg3 = static_cast< double >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_StepwiseMutator" "', argument " "4"" of type '" "UINT""'");
    } 
    arg4 = static_cast< UINT >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_StepwiseMutator" "', argument " "5"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "5"" of type '" "simuPOP::floatListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::floatListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_StepwiseMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintListFunc * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_StepwiseMutator" "', argument " "7"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "7"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::uintListFunc * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_StepwiseMutator" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_StepwiseMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_StepwiseMutator" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    ecode11 = SWIG_AsVal_int(obj10, &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "new_StepwiseMutator" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = static_cast< int >(val11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_StepwiseMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_StepwiseMutator" "', argument " "13"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "13"" of type '" "simuPOP::intList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::intList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_StepwiseMutator" "', argument " "14"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "14"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::subPopList * >(argp14);
  }
  if (obj14) {
    res15 = SWIG_ConvertPtr(obj14, &argp15, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res15)) {
      SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "new_StepwiseMutator" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp15) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StepwiseMutator" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg15 = reinterpret_cast< simuPOP::stringList * >(argp15);
  }
  if (obj15) {
    ecode16 = SWIG_AsVal_int(obj15, &val16);
    if (!SWIG_IsOK(ecode16)) {
      SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "new_StepwiseMutator" "', argument " "16"" of type '" "int""'");
    } 
    arg16 = static_cast< int >(val16);
  }
  {
    try
    {
      result = (simuPOP::StepwiseMutator *)new simuPOP::StepwiseMutator((simuPOP::floatList const &)*arg1,(simuPOP::lociList const &)*arg2,arg3,arg4,(simuPOP::floatListFunc const &)*arg5,(simuPOP::uintListFunc const &)*arg6,(simuPOP::uintListFunc const &)*arg7,(simuPOP::stringFunc const &)*arg8,arg9,arg10,arg11,(simuPOP::intList const &)*arg12,(simuPOP::intList const &)*arg13,(simuPOP::subPopList const &)*arg14,(simuPOP::stringList const &)*arg15,arg16);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__StepwiseMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StepwiseMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::StepwiseMutator *arg1 = (simuPOP::StepwiseMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__StepwiseMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StepwiseMutator" "', argument " "1"" of type '" "simuPOP::StepwiseMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::StepwiseMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StepwiseMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__StepwiseMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *StepwiseMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  PyObject *arg3 = (PyObject *) NULL ;
  int arg4 = (int) 0 ;
  simuPOP::uintListFunc const &arg5_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg5 = (simuPOP::uintListFunc *) &arg5_defvalue ;
  simuPOP::uintListFunc const &arg6_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg6 = (simuPOP::uintListFunc *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = "" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  int arg8 = (int) 0 ;
  int arg9 = (int) -1 ;
  int arg10 = (int) 1 ;
  simuPOP::intList const &arg11_defvalue = vectori() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::intList const &arg12_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::subPopList const &arg13_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg13 = (simuPOP::subPopList *) &arg13_defvalue ;
  simuPOP::stringList const &arg14_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg14 = (simuPOP::stringList *) &arg14_defvalue ;
  int arg15 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  int val15 ;
  int ecode15 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "loci",(char *) "func",(char *) "context",(char *) "mapIn",(char *) "mapOut",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::PyMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOOO:new_PyMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PyMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyMutator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_PyMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::uintListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_PyMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintListFunc * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyMutator" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_PyMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_PyMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_PyMutator" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PyMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_PyMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_PyMutator" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::subPopList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_PyMutator" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMutator" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::stringList * >(argp14);
  }
  if (obj14) {
    ecode15 = SWIG_AsVal_int(obj14, &val15);
    if (!SWIG_IsOK(ecode15)) {
      SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "new_PyMutator" "', argument " "15"" of type '" "int""'");
    } 
    arg15 = static_cast< int >(val15);
  }
  {
    try
    {
      result = (simuPOP::PyMutator *)new simuPOP::PyMutator((simuPOP::floatList const &)*arg1,(simuPOP::lociList const &)*arg2,arg3,arg4,(simuPOP::uintListFunc const &)*arg5,(simuPOP::uintListFunc const &)*arg6,(simuPOP::stringFunc const &)*arg7,arg8,arg9,arg10,(simuPOP::intList const &)*arg11,(simuPOP::intList const &)*arg12,(simuPOP::subPopList const &)*arg13,(simuPOP::stringList const &)*arg14,arg15);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyMutator *arg1 = (simuPOP::PyMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyMutator" "', argument " "1"" of type '" "simuPOP::PyMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MixedMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::opList const &arg3_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg3 = (simuPOP::opList *) &arg3_defvalue ;
  vectorf const &arg4_defvalue = vectorf() ;
  vectorf *arg4 = (vectorf *) &arg4_defvalue ;
  simuPOP::uintListFunc const &arg5_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg5 = (simuPOP::uintListFunc *) &arg5_defvalue ;
  simuPOP::uintListFunc const &arg6_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg6 = (simuPOP::uintListFunc *) &arg6_defvalue ;
  int arg7 = (int) 0 ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  int arg9 = (int) 0 ;
  int arg10 = (int) -1 ;
  int arg11 = (int) 1 ;
  simuPOP::intList const &arg12_defvalue = vectori() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::intList const &arg13_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg13 = (simuPOP::intList *) &arg13_defvalue ;
  simuPOP::subPopList const &arg14_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg14 = (simuPOP::subPopList *) &arg14_defvalue ;
  simuPOP::stringList const &arg15_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg15 = (simuPOP::stringList *) &arg15_defvalue ;
  int arg16 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  int val11 ;
  int ecode11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  void *argp15 = 0 ;
  int res15 = 0 ;
  int val16 ;
  int ecode16 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  PyObject * obj15 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "loci",(char *) "mutators",(char *) "prob",(char *) "mapIn",(char *) "mapOut",(char *) "context",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::MixedMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOOOO:new_MixedMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14,&obj15)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MixedMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MixedMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MixedMutator" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::opList * >(argp3);
  }
  if (obj3) {
    {
      std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
      res4 = swig::asptr(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_MixedMutator" "', argument " "4"" of type '" "vectorf const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "4"" of type '" "vectorf const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_MixedMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::uintListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MixedMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintListFunc * >(argp6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_MixedMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MixedMutator" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_MixedMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_MixedMutator" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    ecode11 = SWIG_AsVal_int(obj10, &val11);
    if (!SWIG_IsOK(ecode11)) {
      SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "new_MixedMutator" "', argument " "11"" of type '" "int""'");
    } 
    arg11 = static_cast< int >(val11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_MixedMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_MixedMutator" "', argument " "13"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "13"" of type '" "simuPOP::intList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::intList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_MixedMutator" "', argument " "14"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "14"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::subPopList * >(argp14);
  }
  if (obj14) {
    res15 = SWIG_ConvertPtr(obj14, &argp15, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res15)) {
      SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "new_MixedMutator" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp15) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MixedMutator" "', argument " "15"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg15 = reinterpret_cast< simuPOP::stringList * >(argp15);
  }
  if (obj15) {
    ecode16 = SWIG_AsVal_int(obj15, &val16);
    if (!SWIG_IsOK(ecode16)) {
      SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "new_MixedMutator" "', argument " "16"" of type '" "int""'");
    } 
    arg16 = static_cast< int >(val16);
  }
  {
    try
    {
      result = (simuPOP::MixedMutator *)new simuPOP::MixedMutator((simuPOP::floatList const &)*arg1,(simuPOP::lociList const &)*arg2,(simuPOP::opList const &)*arg3,(vectorf const &)*arg4,(simuPOP::uintListFunc const &)*arg5,(simuPOP::uintListFunc const &)*arg6,arg7,(simuPOP::stringFunc const &)*arg8,arg9,arg10,arg11,(simuPOP::intList const &)*arg12,(simuPOP::intList const &)*arg13,(simuPOP::subPopList const &)*arg14,(simuPOP::stringList const &)*arg15,arg16);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MixedMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  if (SWIG_IsNewObj(res15)) delete arg15;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MixedMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MixedMutator *arg1 = (simuPOP::MixedMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MixedMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MixedMutator" "', argument " "1"" of type '" "simuPOP::MixedMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MixedMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MixedMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MixedMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MixedMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_ContextMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  simuPOP::lociList const &arg2_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::opList const &arg3_defvalue = simuPOP::opList() ;
  simuPOP::opList *arg3 = (simuPOP::opList *) &arg3_defvalue ;
  simuPOP::intMatrix const &arg4_defvalue = simuPOP::intMatrix() ;
  simuPOP::intMatrix *arg4 = (simuPOP::intMatrix *) &arg4_defvalue ;
  simuPOP::uintListFunc const &arg5_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg5 = (simuPOP::uintListFunc *) &arg5_defvalue ;
  simuPOP::uintListFunc const &arg6_defvalue = simuPOP::uintListFunc() ;
  simuPOP::uintListFunc *arg6 = (simuPOP::uintListFunc *) &arg6_defvalue ;
  simuPOP::stringFunc const &arg7_defvalue = "" ;
  simuPOP::stringFunc *arg7 = (simuPOP::stringFunc *) &arg7_defvalue ;
  int arg8 = (int) 0 ;
  int arg9 = (int) -1 ;
  int arg10 = (int) 1 ;
  simuPOP::intList const &arg11_defvalue = vectori() ;
  simuPOP::intList *arg11 = (simuPOP::intList *) &arg11_defvalue ;
  simuPOP::intList const &arg12_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg12 = (simuPOP::intList *) &arg12_defvalue ;
  simuPOP::subPopList const &arg13_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg13 = (simuPOP::subPopList *) &arg13_defvalue ;
  simuPOP::stringList const &arg14_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg14 = (simuPOP::stringList *) &arg14_defvalue ;
  int arg15 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  int val10 ;
  int ecode10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  void *argp14 = 0 ;
  int res14 = 0 ;
  int val15 ;
  int ecode15 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  PyObject * obj13 = 0 ;
  PyObject * obj14 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "loci",(char *) "mutators",(char *) "contexts",(char *) "mapIn",(char *) "mapOut",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::ContextMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOOOOO:new_ContextMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12,&obj13,&obj14)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ContextMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_ContextMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_ContextMutator" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "3"" of type '" "simuPOP::opList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::opList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_ContextMutator" "', argument " "4"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "4"" of type '" "simuPOP::intMatrix const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::intMatrix * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_ContextMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "5"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::uintListFunc * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_ContextMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "6"" of type '" "simuPOP::uintListFunc const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintListFunc * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_ContextMutator" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "7"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::stringFunc * >(argp7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_ContextMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    ecode9 = SWIG_AsVal_int(obj8, &val9);
    if (!SWIG_IsOK(ecode9)) {
      SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_ContextMutator" "', argument " "9"" of type '" "int""'");
    } 
    arg9 = static_cast< int >(val9);
  }
  if (obj9) {
    ecode10 = SWIG_AsVal_int(obj9, &val10);
    if (!SWIG_IsOK(ecode10)) {
      SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "new_ContextMutator" "', argument " "10"" of type '" "int""'");
    } 
    arg10 = static_cast< int >(val10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_ContextMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "11"" of type '" "simuPOP::intList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::intList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_ContextMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "12"" of type '" "simuPOP::intList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::intList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "new_ContextMutator" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "13"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::subPopList * >(argp13);
  }
  if (obj13) {
    res14 = SWIG_ConvertPtr(obj13, &argp14, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res14)) {
      SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "new_ContextMutator" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp14) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ContextMutator" "', argument " "14"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg14 = reinterpret_cast< simuPOP::stringList * >(argp14);
  }
  if (obj14) {
    ecode15 = SWIG_AsVal_int(obj14, &val15);
    if (!SWIG_IsOK(ecode15)) {
      SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "new_ContextMutator" "', argument " "15"" of type '" "int""'");
    } 
    arg15 = static_cast< int >(val15);
  }
  {
    try
    {
      result = (simuPOP::ContextMutator *)new simuPOP::ContextMutator((simuPOP::floatList const &)*arg1,(simuPOP::lociList const &)*arg2,(simuPOP::opList const &)*arg3,(simuPOP::intMatrix const &)*arg4,(simuPOP::uintListFunc const &)*arg5,(simuPOP::uintListFunc const &)*arg6,(simuPOP::stringFunc const &)*arg7,arg8,arg9,arg10,(simuPOP::intList const &)*arg11,(simuPOP::intList const &)*arg12,(simuPOP::subPopList const &)*arg13,(simuPOP::stringList const &)*arg14,arg15);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__ContextMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  if (SWIG_IsNewObj(res14)) delete arg14;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ContextMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::ContextMutator *arg1 = (simuPOP::ContextMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__ContextMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ContextMutator" "', argument " "1"" of type '" "simuPOP::ContextMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::ContextMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ContextMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__ContextMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *ContextMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PointMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  Allele arg2 ;
  simuPOP::uintList const &arg3_defvalue = vectoru(1, 0) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = vectoru() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  simuPOP::stringFunc const &arg5_defvalue = "" ;
  simuPOP::stringFunc *arg5 = (simuPOP::stringFunc *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::subPopList const &arg11_defvalue = 0 ;
  simuPOP::subPopList *arg11 = (simuPOP::subPopList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  int arg13 = (int) FROM_INFO ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  int val13 ;
  int ecode13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "allele",(char *) "ploidy",(char *) "inds",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::PointMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOOOOO:new_PointMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PointMutator" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PointMutator" "', argument " "2"" of type '" "Allele""'");
  } 
  arg2 = static_cast< Allele >(val2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PointMutator" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_PointMutator" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_PointMutator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringFunc * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PointMutator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PointMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_PointMutator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PointMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PointMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PointMutator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::subPopList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_PointMutator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PointMutator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  if (obj12) {
    ecode13 = SWIG_AsVal_int(obj12, &val13);
    if (!SWIG_IsOK(ecode13)) {
      SWIG_exception_fail(SWIG_ArgError(ecode13), "in method '" "new_PointMutator" "', argument " "13"" of type '" "int""'");
    } 
    arg13 = static_cast< int >(val13);
  }
  {
    try
    {
      result = (simuPOP::PointMutator *)new simuPOP::PointMutator((simuPOP::lociList const &)*arg1,arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4,(simuPOP::stringFunc const &)*arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::subPopList const &)*arg11,(simuPOP::stringList const &)*arg12,arg13);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PointMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PointMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PointMutator *arg1 = (simuPOP::PointMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PointMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PointMutator" "', argument " "1"" of type '" "simuPOP::PointMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PointMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PointMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PointMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PointMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_RevertFixedSites(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList const &arg1_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg1 = (simuPOP::lociList *) &arg1_defvalue ;
  simuPOP::stringFunc const &arg2_defvalue = "" ;
  simuPOP::stringFunc *arg2 = (simuPOP::stringFunc *) &arg2_defvalue ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::RevertFixedSites *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_RevertFixedSites",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RevertFixedSites" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_RevertFixedSites" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "2"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::stringFunc * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RevertFixedSites" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_RevertFixedSites" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_RevertFixedSites" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_RevertFixedSites" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_RevertFixedSites" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_RevertFixedSites" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_RevertFixedSites" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RevertFixedSites" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::RevertFixedSites *)new simuPOP::RevertFixedSites((simuPOP::lociList const &)*arg1,(simuPOP::stringFunc const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__RevertFixedSites, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RevertFixedSites(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::RevertFixedSites *arg1 = (simuPOP::RevertFixedSites *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__RevertFixedSites, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RevertFixedSites" "', argument " "1"" of type '" "simuPOP::RevertFixedSites *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::RevertFixedSites * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RevertFixedSites_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__RevertFixedSites, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *RevertFixedSites_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_FiniteSitesMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  double arg1 ;
  simuPOP::intMatrix *arg2 = 0 ;
  int arg3 = (int) 1 ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr(1, "ind_id") ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int arg12 = (int) FROM_INFO ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  int val12 ;
  int ecode12 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "ranges",(char *) "model",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields",(char *) "lineageMode", NULL 
  };
  simuPOP::FiniteSitesMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOOOO:new_FiniteSitesMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_FiniteSitesMutator" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_FiniteSitesMutator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::intMatrix * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_FiniteSitesMutator" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_FiniteSitesMutator" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_FiniteSitesMutator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_FiniteSitesMutator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_FiniteSitesMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_FiniteSitesMutator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_FiniteSitesMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_FiniteSitesMutator" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_FiniteSitesMutator" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FiniteSitesMutator" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  if (obj11) {
    ecode12 = SWIG_AsVal_int(obj11, &val12);
    if (!SWIG_IsOK(ecode12)) {
      SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "new_FiniteSitesMutator" "', argument " "12"" of type '" "int""'");
    } 
    arg12 = static_cast< int >(val12);
  }
  {
    try
    {
      result = (simuPOP::FiniteSitesMutator *)new simuPOP::FiniteSitesMutator(arg1,(simuPOP::intMatrix const &)*arg2,arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11,arg12);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__FiniteSitesMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_FiniteSitesMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::FiniteSitesMutator *arg1 = (simuPOP::FiniteSitesMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__FiniteSitesMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FiniteSitesMutator" "', argument " "1"" of type '" "simuPOP::FiniteSitesMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::FiniteSitesMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FiniteSitesMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__FiniteSitesMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *FiniteSitesMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MutSpaceRevertFixedSites(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MutSpaceRevertFixedSites *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_MutSpaceRevertFixedSites",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRevertFixedSites" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRevertFixedSites" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRevertFixedSites" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRevertFixedSites" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MutSpaceRevertFixedSites" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRevertFixedSites" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::MutSpaceRevertFixedSites *)new simuPOP::MutSpaceRevertFixedSites((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MutSpaceRevertFixedSites, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MutSpaceRevertFixedSites(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MutSpaceRevertFixedSites *arg1 = (simuPOP::MutSpaceRevertFixedSites *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MutSpaceRevertFixedSites, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MutSpaceRevertFixedSites" "', argument " "1"" of type '" "simuPOP::MutSpaceRevertFixedSites *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MutSpaceRevertFixedSites * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MutSpaceRevertFixedSites_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MutSpaceRevertFixedSites, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MutSpaceRevertFixedSites_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MutSpaceMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  double arg1 ;
  simuPOP::intMatrix *arg2 = 0 ;
  int arg3 = (int) 1 ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "ranges",(char *) "model",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MutSpaceMutator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOOO:new_MutSpaceMutator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MutSpaceMutator" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MutSpaceMutator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::intMatrix * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MutSpaceMutator" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_MutSpaceMutator" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MutSpaceMutator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MutSpaceMutator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_MutSpaceMutator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MutSpaceMutator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MutSpaceMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MutSpaceMutator" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_MutSpaceMutator" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceMutator" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::MutSpaceMutator *)new simuPOP::MutSpaceMutator(arg1,(simuPOP::intMatrix const &)*arg2,arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MutSpaceMutator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MutSpaceMutator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MutSpaceMutator *arg1 = (simuPOP::MutSpaceMutator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MutSpaceMutator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MutSpaceMutator" "', argument " "1"" of type '" "simuPOP::MutSpaceMutator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MutSpaceMutator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MutSpaceMutator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MutSpaceMutator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MutSpaceMutator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_GenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::GenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_GenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_GenoTransmitter" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_GenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_GenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_GenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_GenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_GenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_GenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::GenoTransmitter *)new simuPOP::GenoTransmitter((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__GenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoTransmitter_clearChromosome(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoTransmitter *arg1 = (simuPOP::GenoTransmitter *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  int arg3 ;
  size_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ind",(char *) "ploidy",(char *) "chrom", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOO:GenoTransmitter_clearChromosome",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoTransmitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoTransmitter_clearChromosome" "', argument " "1"" of type '" "simuPOP::GenoTransmitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoTransmitter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoTransmitter_clearChromosome" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoTransmitter_clearChromosome" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoTransmitter_clearChromosome" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "GenoTransmitter_clearChromosome" "', argument " "4"" of type '" "size_t""'");
  } 
  arg4 = static_cast< size_t >(val4);
  {
    try
    {
      ((simuPOP::GenoTransmitter const *)arg1)->clearChromosome((simuPOP::Individual const &)*arg2,arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoTransmitter_copyChromosome(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoTransmitter *arg1 = (simuPOP::GenoTransmitter *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  int arg3 ;
  simuPOP::Individual *arg4 = 0 ;
  int arg5 ;
  size_t arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "parent",(char *) "parPloidy",(char *) "offspring",(char *) "ploidy",(char *) "chrom", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOOOO:GenoTransmitter_copyChromosome",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoTransmitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoTransmitter_copyChromosome" "', argument " "1"" of type '" "simuPOP::GenoTransmitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoTransmitter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoTransmitter_copyChromosome" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoTransmitter_copyChromosome" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoTransmitter_copyChromosome" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__Individual,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GenoTransmitter_copyChromosome" "', argument " "4"" of type '" "simuPOP::Individual &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoTransmitter_copyChromosome" "', argument " "4"" of type '" "simuPOP::Individual &""'"); 
  }
  arg4 = reinterpret_cast< simuPOP::Individual * >(argp4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GenoTransmitter_copyChromosome" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_size_t(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "GenoTransmitter_copyChromosome" "', argument " "6"" of type '" "size_t""'");
  } 
  arg6 = static_cast< size_t >(val6);
  {
    try
    {
      ((simuPOP::GenoTransmitter const *)arg1)->copyChromosome((simuPOP::Individual const &)*arg2,arg3,*arg4,arg5,arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenoTransmitter_copyChromosomes(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::GenoTransmitter *arg1 = (simuPOP::GenoTransmitter *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  int arg3 ;
  simuPOP::Individual *arg4 = 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "parent",(char *) "parPloidy",(char *) "offspring",(char *) "ploidy", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOOO:GenoTransmitter_copyChromosomes",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__GenoTransmitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenoTransmitter_copyChromosomes" "', argument " "1"" of type '" "simuPOP::GenoTransmitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoTransmitter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenoTransmitter_copyChromosomes" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoTransmitter_copyChromosomes" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "GenoTransmitter_copyChromosomes" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__Individual,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "GenoTransmitter_copyChromosomes" "', argument " "4"" of type '" "simuPOP::Individual &""'"); 
  }
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenoTransmitter_copyChromosomes" "', argument " "4"" of type '" "simuPOP::Individual &""'"); 
  }
  arg4 = reinterpret_cast< simuPOP::Individual * >(argp4);
  ecode5 = SWIG_AsVal_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "GenoTransmitter_copyChromosomes" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try
    {
      ((simuPOP::GenoTransmitter const *)arg1)->copyChromosomes((simuPOP::Individual const &)*arg2,arg3,*arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::GenoTransmitter *arg1 = (simuPOP::GenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__GenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenoTransmitter" "', argument " "1"" of type '" "simuPOP::GenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::GenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__GenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_CloneGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = simuPOP::stringList() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "chroms",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::CloneGenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_CloneGenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CloneGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_CloneGenoTransmitter" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_CloneGenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_CloneGenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_CloneGenoTransmitter" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_CloneGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_CloneGenoTransmitter" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_CloneGenoTransmitter" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_CloneGenoTransmitter" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CloneGenoTransmitter" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::CloneGenoTransmitter *)new simuPOP::CloneGenoTransmitter((simuPOP::stringFunc const &)*arg1,(simuPOP::uintList const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__CloneGenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CloneGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::CloneGenoTransmitter *arg1 = (simuPOP::CloneGenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__CloneGenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CloneGenoTransmitter" "', argument " "1"" of type '" "simuPOP::CloneGenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::CloneGenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CloneGenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__CloneGenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CloneGenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MendelianGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MendelianGenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_MendelianGenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MendelianGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MendelianGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_MendelianGenoTransmitter" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MendelianGenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MendelianGenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_MendelianGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MendelianGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MendelianGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MendelianGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MendelianGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MendelianGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MendelianGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MendelianGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::MendelianGenoTransmitter *)new simuPOP::MendelianGenoTransmitter((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MendelianGenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_MendelianGenoTransmitter_transmitGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::MendelianGenoTransmitter *arg1 = (simuPOP::MendelianGenoTransmitter *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  simuPOP::Individual *arg3 = 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "parent",(char *) "offspring",(char *) "ploidy", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOO:MendelianGenoTransmitter_transmitGenotype",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__MendelianGenoTransmitter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "1"" of type '" "simuPOP::MendelianGenoTransmitter const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MendelianGenoTransmitter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__Individual,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "3"" of type '" "simuPOP::Individual &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "3"" of type '" "simuPOP::Individual &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::Individual * >(argp3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MendelianGenoTransmitter_transmitGenotype" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  {
    try
    {
      ((simuPOP::MendelianGenoTransmitter const *)arg1)->transmitGenotype((simuPOP::Individual const &)*arg2,*arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MendelianGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MendelianGenoTransmitter *arg1 = (simuPOP::MendelianGenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MendelianGenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MendelianGenoTransmitter" "', argument " "1"" of type '" "simuPOP::MendelianGenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MendelianGenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MendelianGenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MendelianGenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MendelianGenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SelfingGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::SelfingGenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_SelfingGenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SelfingGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SelfingGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SelfingGenoTransmitter" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SelfingGenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_SelfingGenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_SelfingGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SelfingGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_SelfingGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SelfingGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_SelfingGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SelfingGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_SelfingGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SelfingGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::SelfingGenoTransmitter *)new simuPOP::SelfingGenoTransmitter((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__SelfingGenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SelfingGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::SelfingGenoTransmitter *arg1 = (simuPOP::SelfingGenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__SelfingGenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SelfingGenoTransmitter" "', argument " "1"" of type '" "simuPOP::SelfingGenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::SelfingGenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SelfingGenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__SelfingGenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SelfingGenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_HaplodiploidGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::HaplodiploidGenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_HaplodiploidGenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_HaplodiploidGenoTransmitter" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::HaplodiploidGenoTransmitter *)new simuPOP::HaplodiploidGenoTransmitter((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__HaplodiploidGenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_HaplodiploidGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::HaplodiploidGenoTransmitter *arg1 = (simuPOP::HaplodiploidGenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__HaplodiploidGenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_HaplodiploidGenoTransmitter" "', argument " "1"" of type '" "simuPOP::HaplodiploidGenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::HaplodiploidGenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *HaplodiploidGenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__HaplodiploidGenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *HaplodiploidGenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MitochondrialGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "chroms",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MitochondrialGenoTransmitter *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOO:new_MitochondrialGenoTransmitter",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MitochondrialGenoTransmitter" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MitochondrialGenoTransmitter" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::MitochondrialGenoTransmitter *)new simuPOP::MitochondrialGenoTransmitter((simuPOP::stringFunc const &)*arg1,(simuPOP::uintList const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MitochondrialGenoTransmitter, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MitochondrialGenoTransmitter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MitochondrialGenoTransmitter *arg1 = (simuPOP::MitochondrialGenoTransmitter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MitochondrialGenoTransmitter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MitochondrialGenoTransmitter" "', argument " "1"" of type '" "simuPOP::MitochondrialGenoTransmitter *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MitochondrialGenoTransmitter * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MitochondrialGenoTransmitter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MitochondrialGenoTransmitter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MitochondrialGenoTransmitter_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Recombinator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatList const &arg1_defvalue = vectorf() ;
  simuPOP::floatList *arg1 = (simuPOP::floatList *) &arg1_defvalue ;
  double arg2 = (double) -1 ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::floatList const &arg4_defvalue = NO_CONVERSION ;
  simuPOP::floatList *arg4 = (simuPOP::floatList *) &arg4_defvalue ;
  simuPOP::stringFunc const &arg5_defvalue = "" ;
  simuPOP::stringFunc *arg5 = (simuPOP::stringFunc *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::subPopList const &arg11_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg11 = (simuPOP::subPopList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr() ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  char *  kwnames[] = {
    (char *) "rates",(char *) "intensity",(char *) "loci",(char *) "convMode",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::Recombinator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOOOOOO:new_Recombinator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Recombinator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "1"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::floatList * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_double(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Recombinator" "', argument " "2"" of type '" "double""'");
    } 
    arg2 = static_cast< double >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Recombinator" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_Recombinator" "', argument " "4"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "4"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::floatList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Recombinator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringFunc * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Recombinator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Recombinator" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Recombinator" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_Recombinator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_Recombinator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_Recombinator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::subPopList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_Recombinator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Recombinator" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  {
    try
    {
      result = (simuPOP::Recombinator *)new simuPOP::Recombinator((simuPOP::floatList const &)*arg1,arg2,(simuPOP::lociList const &)*arg3,(simuPOP::floatList const &)*arg4,(simuPOP::stringFunc const &)*arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::subPopList const &)*arg11,(simuPOP::stringList const &)*arg12);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Recombinator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Recombinator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Recombinator *arg1 = (simuPOP::Recombinator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Recombinator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Recombinator" "', argument " "1"" of type '" "simuPOP::Recombinator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Recombinator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Recombinator_transmitGenotype(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Recombinator *arg1 = (simuPOP::Recombinator *) 0 ;
  simuPOP::Individual *arg2 = 0 ;
  simuPOP::Individual *arg3 = 0 ;
  int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "parent",(char *) "offspring",(char *) "ploidy", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OOOO:Recombinator_transmitGenotype",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Recombinator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Recombinator_transmitGenotype" "', argument " "1"" of type '" "simuPOP::Recombinator const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Recombinator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Individual,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Recombinator_transmitGenotype" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Recombinator_transmitGenotype" "', argument " "2"" of type '" "simuPOP::Individual const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__Individual,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Recombinator_transmitGenotype" "', argument " "3"" of type '" "simuPOP::Individual &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Recombinator_transmitGenotype" "', argument " "3"" of type '" "simuPOP::Individual &""'"); 
  }
  arg3 = reinterpret_cast< simuPOP::Individual * >(argp3);
  ecode4 = SWIG_AsVal_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Recombinator_transmitGenotype" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  {
    try
    {
      ((simuPOP::Recombinator const *)arg1)->transmitGenotype((simuPOP::Individual const &)*arg2,*arg3,arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Recombinator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Recombinator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Recombinator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MutSpaceRecombinator(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  double arg1 ;
  simuPOP::intMatrix *arg2 = 0 ;
  simuPOP::stringFunc const &arg3_defvalue = "" ;
  simuPOP::stringFunc *arg3 = (simuPOP::stringFunc *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  double val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "rate",(char *) "ranges",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MutSpaceRecombinator *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOO:new_MutSpaceRecombinator",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  ecode1 = SWIG_AsVal_double(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MutSpaceRecombinator" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__intMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MutSpaceRecombinator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "2"" of type '" "simuPOP::intMatrix const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::intMatrix * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MutSpaceRecombinator" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringFunc * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MutSpaceRecombinator" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MutSpaceRecombinator" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MutSpaceRecombinator" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MutSpaceRecombinator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MutSpaceRecombinator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MutSpaceRecombinator" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MutSpaceRecombinator" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceRecombinator" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::MutSpaceRecombinator *)new simuPOP::MutSpaceRecombinator(arg1,(simuPOP::intMatrix const &)*arg2,(simuPOP::stringFunc const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MutSpaceRecombinator, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MutSpaceRecombinator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MutSpaceRecombinator *arg1 = (simuPOP::MutSpaceRecombinator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MutSpaceRecombinator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MutSpaceRecombinator" "', argument " "1"" of type '" "simuPOP::MutSpaceRecombinator *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MutSpaceRecombinator * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MutSpaceRecombinator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MutSpaceRecombinator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MutSpaceRecombinator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_BaseSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::stringFunc const &arg1_defvalue = "" ;
  simuPOP::stringFunc *arg1 = (simuPOP::stringFunc *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::BaseSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_BaseSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BaseSelector" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseSelector" "', argument " "1"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::stringFunc * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BaseSelector" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_BaseSelector" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_BaseSelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_BaseSelector" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseSelector" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BaseSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_BaseSelector" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseSelector" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_BaseSelector" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseSelector" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::BaseSelector *)new simuPOP::BaseSelector((simuPOP::stringFunc const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BaseSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseSelector *arg1 = (simuPOP::BaseSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BaseSelector" "', argument " "1"" of type '" "simuPOP::BaseSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BaseSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BaseSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BaseSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MapSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  tupleDict *arg2 = 0 ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "fitness",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MapSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOO:new_MapSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MapSelector" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *ptr = (std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MapSelector" "', argument " "2"" of type '" "tupleDict const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "2"" of type '" "tupleDict const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MapSelector" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MapSelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MapSelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MapSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MapSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MapSelector" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MapSelector" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapSelector" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::MapSelector *)new simuPOP::MapSelector((simuPOP::lociList const &)*arg1,(tupleDict const &)*arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MapSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MapSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MapSelector *arg1 = (simuPOP::MapSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MapSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MapSelector" "', argument " "1"" of type '" "simuPOP::MapSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MapSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MapSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MapSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MapSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MaSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  vectorf *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = vectoru(1, 0) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "fitness",(char *) "wildtype",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MaSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOO:new_MaSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MaSelector" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MaSelector" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MaSelector" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MaSelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MaSelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MaSelector" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MaSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MaSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MaSelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MaSelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaSelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::MaSelector *)new simuPOP::MaSelector((simuPOP::lociList const &)*arg1,(vectorf const &)*arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MaSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MaSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MaSelector *arg1 = (simuPOP::MaSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MaSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MaSelector" "', argument " "1"" of type '" "simuPOP::MaSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MaSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MaSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MaSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MaSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MlSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::opList *arg1 = 0 ;
  int arg2 = (int) MULTIPLICATIVE ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::subPopList const &arg8_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg8 = (simuPOP::subPopList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  char *  kwnames[] = {
    (char *) "ops",(char *) "mode",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MlSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOO:new_MlSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MlSelector" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlSelector" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_MlSelector" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_MlSelector" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MlSelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MlSelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_MlSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlSelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MlSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MlSelector" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlSelector" "', argument " "8"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::subPopList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MlSelector" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlSelector" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  {
    try
    {
      result = (simuPOP::MlSelector *)new simuPOP::MlSelector((simuPOP::opList const &)*arg1,arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::subPopList const &)*arg8,(simuPOP::stringList const &)*arg9);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MlSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MlSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MlSelector *arg1 = (simuPOP::MlSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MlSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MlSelector" "', argument " "1"" of type '" "simuPOP::MlSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MlSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MlSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MlSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MlSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PySelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::lociList arg2 = (simuPOP::lociList) vectoru() ;
  int arg3 = (int) 0 ;
  int arg4 = (int) -1 ;
  int arg5 = (int) 1 ;
  simuPOP::intList const &arg6_defvalue = vectori() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::intList const &arg7_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::stringFunc const &arg8_defvalue = "" ;
  simuPOP::stringFunc *arg8 = (simuPOP::stringFunc *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "loci",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "output",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PySelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_PySelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    {
      res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PySelector" "', argument " "2"" of type '" "simuPOP::lociList""'"); 
      }  
      if (!argp2) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "2"" of type '" "simuPOP::lociList""'");
      } else {
        simuPOP::lociList * temp = reinterpret_cast< simuPOP::lociList * >(argp2);
        arg2 = *temp;
        if (SWIG_IsNewObj(res2)) delete temp;
      }
    }
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PySelector" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PySelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PySelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_PySelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PySelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PySelector" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "8"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringFunc * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PySelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PySelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PySelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::PySelector *)new simuPOP::PySelector(arg1,arg2,arg3,arg4,arg5,(simuPOP::intList const &)*arg6,(simuPOP::intList const &)*arg7,(simuPOP::stringFunc const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PySelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PySelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PySelector *arg1 = (simuPOP::PySelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PySelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PySelector" "', argument " "1"" of type '" "simuPOP::PySelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PySelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PySelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PySelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PySelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyMlSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  int arg2 = (int) EXPONENTIAL ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::stringFunc const &arg4_defvalue = "" ;
  simuPOP::stringFunc *arg4 = (simuPOP::stringFunc *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "mode",(char *) "loci",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyMlSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOO:new_PyMlSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PyMlSelector" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyMlSelector" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_PyMlSelector" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "4"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::stringFunc * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyMlSelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyMlSelector" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PyMlSelector" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyMlSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyMlSelector" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyMlSelector" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PyMlSelector" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlSelector" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::PyMlSelector *)new simuPOP::PyMlSelector(arg1,arg2,(simuPOP::lociList const &)*arg3,(simuPOP::stringFunc const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyMlSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyMlSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyMlSelector *arg1 = (simuPOP::PyMlSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyMlSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyMlSelector" "', argument " "1"" of type '" "simuPOP::PyMlSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyMlSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyMlSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyMlSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyMlSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MutSpaceSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::floatListFunc *arg1 = 0 ;
  int arg2 = (int) EXPONENTIAL ;
  simuPOP::stringFunc const &arg3_defvalue = "" ;
  simuPOP::stringFunc *arg3 = (simuPOP::stringFunc *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = simuPOP::stringList("fitness") ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "selDist",(char *) "mode",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MutSpaceSelector *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_MutSpaceSelector",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__floatListFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MutSpaceSelector" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "1"" of type '" "simuPOP::floatListFunc const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::floatListFunc * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_MutSpaceSelector" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MutSpaceSelector" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "3"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringFunc * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MutSpaceSelector" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MutSpaceSelector" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MutSpaceSelector" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MutSpaceSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MutSpaceSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MutSpaceSelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MutSpaceSelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MutSpaceSelector" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::MutSpaceSelector *)new simuPOP::MutSpaceSelector((simuPOP::floatListFunc const &)*arg1,arg2,(simuPOP::stringFunc const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MutSpaceSelector, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MutSpaceSelector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MutSpaceSelector *arg1 = (simuPOP::MutSpaceSelector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MutSpaceSelector, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MutSpaceSelector" "', argument " "1"" of type '" "simuPOP::MutSpaceSelector *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MutSpaceSelector * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MutSpaceSelector_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MutSpaceSelector, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MutSpaceSelector_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_BaseQuanTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::uintList const &arg1_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg1 = (simuPOP::uintList *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::BaseQuanTrait *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_BaseQuanTrait",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BaseQuanTrait" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseQuanTrait" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::uintList * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BaseQuanTrait" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_BaseQuanTrait" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_BaseQuanTrait" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_BaseQuanTrait" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseQuanTrait" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BaseQuanTrait" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseQuanTrait" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_BaseQuanTrait" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseQuanTrait" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_BaseQuanTrait" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BaseQuanTrait" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::BaseQuanTrait *)new simuPOP::BaseQuanTrait((simuPOP::uintList const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BaseQuanTrait, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BaseQuanTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BaseQuanTrait *arg1 = (simuPOP::BaseQuanTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BaseQuanTrait, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BaseQuanTrait" "', argument " "1"" of type '" "simuPOP::BaseQuanTrait *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BaseQuanTrait * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BaseQuanTrait_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BaseQuanTrait, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BaseQuanTrait_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyQuanTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::lociList const &arg2_defvalue = vectoru() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::uintList arg3 = (simuPOP::uintList) (simuPOP::uintList)simuPOP::uintList(NULL) ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "loci",(char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyQuanTrait *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_PyQuanTrait",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyQuanTrait" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    {
      res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyQuanTrait" "', argument " "3"" of type '" "simuPOP::uintList const""'"); 
      }  
      if (!argp3) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "3"" of type '" "simuPOP::uintList const""'");
      } else {
        simuPOP::uintList * temp = reinterpret_cast< simuPOP::uintList * >(argp3);
        arg3 = *temp;
        if (SWIG_IsNewObj(res3)) delete temp;
      }
    }
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyQuanTrait" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyQuanTrait" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyQuanTrait" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyQuanTrait" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyQuanTrait" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyQuanTrait" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyQuanTrait" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyQuanTrait" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::PyQuanTrait *)new simuPOP::PyQuanTrait(arg1,(simuPOP::lociList const &)*arg2,arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyQuanTrait, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyQuanTrait(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyQuanTrait *arg1 = (simuPOP::PyQuanTrait *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyQuanTrait, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyQuanTrait" "', argument " "1"" of type '" "simuPOP::PyQuanTrait *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyQuanTrait * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyQuanTrait_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyQuanTrait, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyQuanTrait_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_BasePenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::uintList const &arg1_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg1 = (simuPOP::uintList *) &arg1_defvalue ;
  int arg2 = (int) 0 ;
  int arg3 = (int) -1 ;
  int arg4 = (int) 1 ;
  simuPOP::intList const &arg5_defvalue = vectori() ;
  simuPOP::intList *arg5 = (simuPOP::intList *) &arg5_defvalue ;
  simuPOP::intList const &arg6_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg6 = (simuPOP::intList *) &arg6_defvalue ;
  simuPOP::subPopList const &arg7_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg7 = (simuPOP::subPopList *) &arg7_defvalue ;
  simuPOP::stringList const &arg8_defvalue = vectorstr() ;
  simuPOP::stringList *arg8 = (simuPOP::stringList *) &arg8_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::BasePenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OOOOOOOO:new_BasePenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  if (obj0) {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_BasePenetrance" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BasePenetrance" "', argument " "1"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg1 = reinterpret_cast< simuPOP::uintList * >(argp1);
  }
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_BasePenetrance" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_int(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_BasePenetrance" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_BasePenetrance" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_BasePenetrance" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BasePenetrance" "', argument " "5"" of type '" "simuPOP::intList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::intList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_BasePenetrance" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BasePenetrance" "', argument " "6"" of type '" "simuPOP::intList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::intList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_BasePenetrance" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BasePenetrance" "', argument " "7"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::subPopList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_BasePenetrance" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_BasePenetrance" "', argument " "8"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::stringList * >(argp8);
  }
  {
    try
    {
      result = (simuPOP::BasePenetrance *)new simuPOP::BasePenetrance((simuPOP::uintList const &)*arg1,arg2,arg3,arg4,(simuPOP::intList const &)*arg5,(simuPOP::intList const &)*arg6,(simuPOP::subPopList const &)*arg7,(simuPOP::stringList const &)*arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__BasePenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BasePenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::BasePenetrance *arg1 = (simuPOP::BasePenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__BasePenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BasePenetrance" "', argument " "1"" of type '" "simuPOP::BasePenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BasePenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BasePenetrance_applyToIndividual(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::BasePenetrance *arg1 = (simuPOP::BasePenetrance *) 0 ;
  simuPOP::Individual *arg2 = (simuPOP::Individual *) 0 ;
  simuPOP::Population *arg3 = (simuPOP::Population *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "ind",(char *) "pop", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:BasePenetrance_applyToIndividual",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__BasePenetrance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BasePenetrance_applyToIndividual" "', argument " "1"" of type '" "simuPOP::BasePenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::BasePenetrance * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BasePenetrance_applyToIndividual" "', argument " "2"" of type '" "simuPOP::Individual *""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Individual * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_simuPOP__Population, 0 |  0 );
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "BasePenetrance_applyToIndividual" "', argument " "3"" of type '" "simuPOP::Population *""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::Population * >(argp3);
  }
  {
    try
    {
      result = (bool)(arg1)->applyToIndividual(arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *BasePenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__BasePenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *BasePenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MapPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  tupleDict *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "penetrance",(char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MapPenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOO:new_MapPenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MapPenetrance" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *ptr = (std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MapPenetrance" "', argument " "2"" of type '" "tupleDict const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "2"" of type '" "tupleDict const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MapPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MapPenetrance" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MapPenetrance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MapPenetrance" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MapPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MapPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MapPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MapPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MapPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::MapPenetrance *)new simuPOP::MapPenetrance((simuPOP::lociList const &)*arg1,(tupleDict const &)*arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MapPenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MapPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MapPenetrance *arg1 = (simuPOP::MapPenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MapPenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MapPenetrance" "', argument " "1"" of type '" "simuPOP::MapPenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MapPenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MapPenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MapPenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MapPenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MaPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::lociList *arg1 = 0 ;
  vectorf *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = vectoru(1, 0) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  int arg5 = (int) 0 ;
  int arg6 = (int) -1 ;
  int arg7 = (int) 1 ;
  simuPOP::intList const &arg8_defvalue = vectori() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::intList const &arg9_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::subPopList const &arg10_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg10 = (simuPOP::subPopList *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  char *  kwnames[] = {
    (char *) "loci",(char *) "penetrance",(char *) "wildtype",(char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MaPenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOOOOOOO:new_MaPenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MaPenetrance" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "1"" of type '" "simuPOP::lociList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::lociList * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MaPenetrance" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MaPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_MaPenetrance" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MaPenetrance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MaPenetrance" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_MaPenetrance" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MaPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MaPenetrance" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MaPenetrance" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "10"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::subPopList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_MaPenetrance" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MaPenetrance" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  {
    try
    {
      result = (simuPOP::MaPenetrance *)new simuPOP::MaPenetrance((simuPOP::lociList const &)*arg1,(vectorf const &)*arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4,arg5,arg6,arg7,(simuPOP::intList const &)*arg8,(simuPOP::intList const &)*arg9,(simuPOP::subPopList const &)*arg10,(simuPOP::stringList const &)*arg11);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MaPenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MaPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MaPenetrance *arg1 = (simuPOP::MaPenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MaPenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MaPenetrance" "', argument " "1"" of type '" "simuPOP::MaPenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MaPenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MaPenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MaPenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MaPenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MlPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::opList *arg1 = 0 ;
  int arg2 = (int) MULTIPLICATIVE ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "ops",(char *) "mode",(char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::MlPenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_MlPenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__opList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MlPenetrance" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "1"" of type '" "simuPOP::opList const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::opList * >(argp1);
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_MlPenetrance" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_MlPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_MlPenetrance" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_MlPenetrance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_MlPenetrance" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_MlPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_MlPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_MlPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_MlPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MlPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::MlPenetrance *)new simuPOP::MlPenetrance((simuPOP::opList const &)*arg1,arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__MlPenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_MlPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::MlPenetrance *arg1 = (simuPOP::MlPenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__MlPenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MlPenetrance" "', argument " "1"" of type '" "simuPOP::MlPenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::MlPenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MlPenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__MlPenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MlPenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  simuPOP::lociList const &arg2_defvalue = vectoru() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::uintList const &arg3_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  int arg4 = (int) 0 ;
  int arg5 = (int) -1 ;
  int arg6 = (int) 1 ;
  simuPOP::intList const &arg7_defvalue = vectori() ;
  simuPOP::intList *arg7 = (simuPOP::intList *) &arg7_defvalue ;
  simuPOP::intList const &arg8_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg8 = (simuPOP::intList *) &arg8_defvalue ;
  simuPOP::subPopList const &arg9_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg9 = (simuPOP::subPopList *) &arg9_defvalue ;
  simuPOP::stringList const &arg10_defvalue = vectorstr() ;
  simuPOP::stringList *arg10 = (simuPOP::stringList *) &arg10_defvalue ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "loci",(char *) "ancGens",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyPenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOO:new_PyPenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_PyPenetrance" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_PyPenetrance" "', argument " "4"" of type '" "int""'");
    } 
    arg4 = static_cast< int >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_PyPenetrance" "', argument " "5"" of type '" "int""'");
    } 
    arg5 = static_cast< int >(val5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyPenetrance" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_PyPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "7"" of type '" "simuPOP::intList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::intList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "new_PyPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "8"" of type '" "simuPOP::intList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::intList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "9"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::subPopList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyPenetrance" "', argument " "10"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringList * >(argp10);
  }
  {
    try
    {
      result = (simuPOP::PyPenetrance *)new simuPOP::PyPenetrance(arg1,(simuPOP::lociList const &)*arg2,(simuPOP::uintList const &)*arg3,arg4,arg5,arg6,(simuPOP::intList const &)*arg7,(simuPOP::intList const &)*arg8,(simuPOP::subPopList const &)*arg9,(simuPOP::stringList const &)*arg10);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyPenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyPenetrance *arg1 = (simuPOP::PyPenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyPenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyPenetrance" "', argument " "1"" of type '" "simuPOP::PyPenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyPenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyPenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyPenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyPenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_PyMlPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  int arg2 = (int) MULTIPLICATIVE ;
  simuPOP::lociList const &arg3_defvalue = simuPOP::lociList() ;
  simuPOP::lociList *arg3 = (simuPOP::lociList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList(NULL) ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  simuPOP::stringFunc const &arg5_defvalue = "" ;
  simuPOP::stringFunc *arg5 = (simuPOP::stringFunc *) &arg5_defvalue ;
  int arg6 = (int) 0 ;
  int arg7 = (int) -1 ;
  int arg8 = (int) 1 ;
  simuPOP::intList const &arg9_defvalue = vectori() ;
  simuPOP::intList *arg9 = (simuPOP::intList *) &arg9_defvalue ;
  simuPOP::intList const &arg10_defvalue = simuPOP::intList() ;
  simuPOP::intList *arg10 = (simuPOP::intList *) &arg10_defvalue ;
  simuPOP::subPopList const &arg11_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg11 = (simuPOP::subPopList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr() ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  char *  kwnames[] = {
    (char *) "func",(char *) "mode",(char *) "loci",(char *) "ancGens",(char *) "output",(char *) "begin",(char *) "end",(char *) "step",(char *) "at",(char *) "reps",(char *) "subPops",(char *) "infoFields", NULL 
  };
  simuPOP::PyMlPenetrance *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOOO:new_PyMlPenetrance",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11)) SWIG_fail;
  arg1 = obj0;
  if (obj1) {
    ecode2 = SWIG_AsVal_int(obj1, &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PyMlPenetrance" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_PyMlPenetrance" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "3"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::lociList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_PyMlPenetrance" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringFunc,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_PyMlPenetrance" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "5"" of type '" "simuPOP::stringFunc const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringFunc * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_int(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_PyMlPenetrance" "', argument " "6"" of type '" "int""'");
    } 
    arg6 = static_cast< int >(val6);
  }
  if (obj6) {
    ecode7 = SWIG_AsVal_int(obj6, &val7);
    if (!SWIG_IsOK(ecode7)) {
      SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_PyMlPenetrance" "', argument " "7"" of type '" "int""'");
    } 
    arg7 = static_cast< int >(val7);
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_int(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_PyMlPenetrance" "', argument " "8"" of type '" "int""'");
    } 
    arg8 = static_cast< int >(val8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "new_PyMlPenetrance" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "9"" of type '" "simuPOP::intList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::intList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__intList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "new_PyMlPenetrance" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "10"" of type '" "simuPOP::intList const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::intList * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "new_PyMlPenetrance" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "11"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::subPopList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "new_PyMlPenetrance" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PyMlPenetrance" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  {
    try
    {
      result = (simuPOP::PyMlPenetrance *)new simuPOP::PyMlPenetrance(arg1,arg2,(simuPOP::lociList const &)*arg3,(simuPOP::uintList const &)*arg4,(simuPOP::stringFunc const &)*arg5,arg6,arg7,arg8,(simuPOP::intList const &)*arg9,(simuPOP::intList const &)*arg10,(simuPOP::subPopList const &)*arg11,(simuPOP::stringList const &)*arg12);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__PyMlPenetrance, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_PyMlPenetrance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::PyMlPenetrance *arg1 = (simuPOP::PyMlPenetrance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__PyMlPenetrance, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PyMlPenetrance" "', argument " "1"" of type '" "simuPOP::PyMlPenetrance *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::PyMlPenetrance * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PyMlPenetrance_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__PyMlPenetrance, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PyMlPenetrance_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Pedigree(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Population *arg1 = 0 ;
  simuPOP::lociList const &arg2_defvalue = vectoru() ;
  simuPOP::lociList *arg2 = (simuPOP::lociList *) &arg2_defvalue ;
  simuPOP::stringList const &arg3_defvalue = vectorstr() ;
  simuPOP::stringList *arg3 = (simuPOP::stringList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  string const &arg5_defvalue = "ind_id" ;
  string *arg5 = (string *) &arg5_defvalue ;
  string const &arg6_defvalue = "father_id" ;
  string *arg6 = (string *) &arg6_defvalue ;
  string const &arg7_defvalue = "mother_id" ;
  string *arg7 = (string *) &arg7_defvalue ;
  bool arg8 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  int res5 = SWIG_OLDOBJ ;
  int res6 = SWIG_OLDOBJ ;
  int res7 = SWIG_OLDOBJ ;
  bool val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  char *  kwnames[] = {
    (char *) "pop",(char *) "loci",(char *) "infoFields",(char *) "ancGens",(char *) "idField",(char *) "fatherField",(char *) "motherField",(char *) "stealPop", NULL 
  };
  simuPOP::Pedigree *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOO:new_Pedigree",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Pedigree" "', argument " "1"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "1"" of type '" "simuPOP::Population const &""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Population * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Pedigree" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "2"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::lociList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_Pedigree" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_Pedigree" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    {
      std::string *ptr = (std::string *)0;
      res5 = SWIG_AsPtr_std_string(obj4, &ptr);
      if (!SWIG_IsOK(res5)) {
        SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_Pedigree" "', argument " "5"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "5"" of type '" "string const &""'"); 
      }
      arg5 = ptr;
    }
  }
  if (obj5) {
    {
      std::string *ptr = (std::string *)0;
      res6 = SWIG_AsPtr_std_string(obj5, &ptr);
      if (!SWIG_IsOK(res6)) {
        SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "new_Pedigree" "', argument " "6"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "6"" of type '" "string const &""'"); 
      }
      arg6 = ptr;
    }
  }
  if (obj6) {
    {
      std::string *ptr = (std::string *)0;
      res7 = SWIG_AsPtr_std_string(obj6, &ptr);
      if (!SWIG_IsOK(res7)) {
        SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "new_Pedigree" "', argument " "7"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Pedigree" "', argument " "7"" of type '" "string const &""'"); 
      }
      arg7 = ptr;
    }
  }
  if (obj7) {
    ecode8 = SWIG_AsVal_bool(obj7, &val8);
    if (!SWIG_IsOK(ecode8)) {
      SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Pedigree" "', argument " "8"" of type '" "bool""'");
    } 
    arg8 = static_cast< bool >(val8);
  }
  {
    try
    {
      result = (simuPOP::Pedigree *)new simuPOP::Pedigree((simuPOP::Population const &)*arg1,(simuPOP::lociList const &)*arg2,(simuPOP::stringList const &)*arg3,(simuPOP::uintList const &)*arg4,(string const &)*arg5,(string const &)*arg6,(string const &)*arg7,arg8);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Pedigree, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  simuPOP::Pedigree *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_clone" "', argument " "1"" of type '" "simuPOP::Pedigree const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    try
    {
      result = (simuPOP::Pedigree *)((simuPOP::Pedigree const *)arg1)->clone();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  string *arg2 = 0 ;
  simuPOP::stringList const &arg3_defvalue = vectorstr() ;
  simuPOP::stringList *arg3 = (simuPOP::stringList *) &arg3_defvalue ;
  simuPOP::lociList const &arg4_defvalue = vectoru() ;
  simuPOP::lociList *arg4 = (simuPOP::lociList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "filename",(char *) "infoFields",(char *) "loci", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OO:Pedigree_save",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_save" "', argument " "1"" of type '" "simuPOP::Pedigree const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_save" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_save" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_save" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_save" "', argument " "3"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::stringList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__lociList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_save" "', argument " "4"" of type '" "simuPOP::lociList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_save" "', argument " "4"" of type '" "simuPOP::lociList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::lociList * >(argp4);
  }
  {
    try
    {
      ((simuPOP::Pedigree const *)arg1)->save((string const &)*arg2,(simuPOP::stringList const &)*arg3,(simuPOP::lociList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_indByID(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "id", NULL 
  };
  simuPOP::Individual *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_indByID",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_indByID" "', argument " "1"" of type '" "simuPOP::Pedigree const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pedigree_indByID" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  {
    try
    {
      result = (simuPOP::Individual *) &((simuPOP::Pedigree const *)arg1)->indByID(arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_simuPOP__Individual, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_numParents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_numParents" "', argument " "1"" of type '" "simuPOP::Pedigree const *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    try
    {
      result = ((simuPOP::Pedigree const *)arg1)->numParents();
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_locateRelatives(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  RelativeType arg2 ;
  vectorstr const &arg3_defvalue = vectorstr() ;
  vectorstr *arg3 = (vectorstr *) &arg3_defvalue ;
  SexChoice arg4 = (SexChoice) ANY_SEX ;
  AffectionStatus arg5 = (AffectionStatus) ANY_AFFECTION_STATUS ;
  simuPOP::uintList const &arg6_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg6 = (simuPOP::uintList *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "relType",(char *) "resultFields",(char *) "sex",(char *) "affectionStatus",(char *) "ancGens", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOO:Pedigree_locateRelatives",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_locateRelatives" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Pedigree_locateRelatives" "', argument " "2"" of type '" "RelativeType""'");
  } 
  arg2 = static_cast< RelativeType >(val2);
  if (obj2) {
    {
      std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
      res3 = swig::asptr(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_locateRelatives" "', argument " "3"" of type '" "vectorstr const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_locateRelatives" "', argument " "3"" of type '" "vectorstr const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    ecode4 = SWIG_AsVal_int(obj3, &val4);
    if (!SWIG_IsOK(ecode4)) {
      SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Pedigree_locateRelatives" "', argument " "4"" of type '" "SexChoice""'");
    } 
    arg4 = static_cast< SexChoice >(val4);
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_int(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Pedigree_locateRelatives" "', argument " "5"" of type '" "AffectionStatus""'");
    } 
    arg5 = static_cast< AffectionStatus >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Pedigree_locateRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_locateRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintList * >(argp6);
  }
  {
    try
    {
      (arg1)->locateRelatives(arg2,(vectorstr const &)*arg3,arg4,arg5,(simuPOP::uintList const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_traceRelatives(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::stringMatrix *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = vectoru() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = vectoru() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  simuPOP::stringList const &arg5_defvalue = vectorstr() ;
  simuPOP::stringList *arg5 = (simuPOP::stringList *) &arg5_defvalue ;
  simuPOP::uintList const &arg6_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg6 = (simuPOP::uintList *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "fieldPath",(char *) "sex",(char *) "affectionStatus",(char *) "resultFields",(char *) "ancGens", NULL 
  };
  bool result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOO:Pedigree_traceRelatives",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_traceRelatives" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_traceRelatives" "', argument " "2"" of type '" "simuPOP::stringMatrix const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_traceRelatives" "', argument " "2"" of type '" "simuPOP::stringMatrix const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringMatrix * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_traceRelatives" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_traceRelatives" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_traceRelatives" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_traceRelatives" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Pedigree_traceRelatives" "', argument " "5"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_traceRelatives" "', argument " "5"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Pedigree_traceRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_traceRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintList * >(argp6);
  }
  {
    try
    {
      result = (bool)(arg1)->traceRelatives((simuPOP::stringMatrix const &)*arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4,(simuPOP::stringList const &)*arg5,(simuPOP::uintList const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_individualsWithRelatives(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::stringList *arg2 = 0 ;
  simuPOP::uintList const &arg3_defvalue = vectoru() ;
  simuPOP::uintList *arg3 = (simuPOP::uintList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = vectoru() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  simuPOP::subPopList const &arg5_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg5 = (simuPOP::subPopList *) &arg5_defvalue ;
  simuPOP::uintList const &arg6_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg6 = (simuPOP::uintList *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "infoFields",(char *) "sex",(char *) "affectionStatus",(char *) "subPops",(char *) "ancGens", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOO:Pedigree_individualsWithRelatives",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_individualsWithRelatives" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_individualsWithRelatives" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_individualsWithRelatives" "', argument " "2"" of type '" "simuPOP::stringList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::stringList * >(argp2);
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_individualsWithRelatives" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_individualsWithRelatives" "', argument " "3"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::uintList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_individualsWithRelatives" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_individualsWithRelatives" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Pedigree_individualsWithRelatives" "', argument " "5"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_individualsWithRelatives" "', argument " "5"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::subPopList * >(argp5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "Pedigree_individualsWithRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_individualsWithRelatives" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintList * >(argp6);
  }
  {
    try
    {
      result = (arg1)->individualsWithRelatives((simuPOP::stringList const &)*arg2,(simuPOP::uintList const &)*arg3,(simuPOP::uintList const &)*arg4,(simuPOP::subPopList const &)*arg5,(simuPOP::uintList const &)*arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  if (SWIG_IsNewObj(res6)) delete arg6;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_identifyFamilies(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  string const &arg2_defvalue = std::string() ;
  string *arg2 = (string *) &arg2_defvalue ;
  simuPOP::subPopList const &arg3_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg3 = (simuPOP::subPopList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pedField",(char *) "subPops",(char *) "ancGens", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOO:Pedigree_identifyFamilies",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_identifyFamilies" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_identifyFamilies" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyFamilies" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_identifyFamilies" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyFamilies" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::subPopList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_identifyFamilies" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyFamilies" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  {
    try
    {
      result = (arg1)->identifyFamilies((string const &)*arg2,(simuPOP::subPopList const &)*arg3,(simuPOP::uintList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_identifyAncestors(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::subPopList const &arg3_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg3 = (simuPOP::subPopList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "IDs",(char *) "subPops",(char *) "ancGens", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOO:Pedigree_identifyAncestors",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_identifyAncestors" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_identifyAncestors" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyAncestors" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_identifyAncestors" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyAncestors" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::subPopList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_identifyAncestors" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyAncestors" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  {
    try
    {
      result = (arg1)->identifyAncestors((simuPOP::uintList const &)*arg2,(simuPOP::subPopList const &)*arg3,(simuPOP::uintList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_identifyOffspring(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::uintList const &arg2_defvalue = vectoru() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::subPopList const &arg3_defvalue = simuPOP::subPopList() ;
  simuPOP::subPopList *arg3 = (simuPOP::subPopList *) &arg3_defvalue ;
  simuPOP::uintList const &arg4_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg4 = (simuPOP::uintList *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "IDs",(char *) "subPops",(char *) "ancGens", NULL 
  };
  vectoru result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOO:Pedigree_identifyOffspring",kwnames,&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_identifyOffspring" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_identifyOffspring" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyOffspring" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_identifyOffspring" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyOffspring" "', argument " "3"" of type '" "simuPOP::subPopList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::subPopList * >(argp3);
  }
  if (obj3) {
    res4 = SWIG_ConvertPtr(obj3, &argp4, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_identifyOffspring" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_identifyOffspring" "', argument " "4"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg4 = reinterpret_cast< simuPOP::uintList * >(argp4);
  }
  {
    try
    {
      result = (arg1)->identifyOffspring((simuPOP::uintList const &)*arg2,(simuPOP::subPopList const &)*arg3,(simuPOP::uintList const &)*arg4);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = swig::from(static_cast< std::vector< size_t,std::allocator< size_t > > >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_removeIndividuals(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::uintList const &arg2_defvalue = vectoru() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  simuPOP::floatList const &arg3_defvalue = simuPOP::floatList() ;
  simuPOP::floatList *arg3 = (simuPOP::floatList *) &arg3_defvalue ;
  string const &arg4_defvalue = "ind_id" ;
  string *arg4 = (string *) &arg4_defvalue ;
  PyObject *arg5 = (PyObject *) NULL ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "indexes",(char *) "IDs",(char *) "idField",(char *) "filter", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOO:Pedigree_removeIndividuals",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_removeIndividuals" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_removeIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_removeIndividuals" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_removeIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_removeIndividuals" "', argument " "3"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg3 = reinterpret_cast< simuPOP::floatList * >(argp3);
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_removeIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_removeIndividuals" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    arg5 = obj4;
  }
  {
    try
    {
      (arg1)->removeIndividuals((simuPOP::uintList const &)*arg2,(simuPOP::floatList const &)*arg3,(string const &)*arg4,arg5);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_removeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::subPopList *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPops", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_removeSubPops",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_removeSubPops" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__subPopList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_removeSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_removeSubPops" "', argument " "2"" of type '" "simuPOP::subPopList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::subPopList * >(argp2);
  {
    try
    {
      (arg1)->removeSubPops((simuPOP::subPopList const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_push(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_push",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_push" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_push" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_push" "', argument " "2"" of type '" "simuPOP::Population &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->push(*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_addChrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  vectorf *arg2 = 0 ;
  vectorstr const &arg3_defvalue = vectorstr() ;
  vectorstr *arg3 = (vectorstr *) &arg3_defvalue ;
  string const &arg4_defvalue = std::string() ;
  string *arg4 = (string *) &arg4_defvalue ;
  simuPOP::stringMatrix const &arg5_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg5 = (simuPOP::stringMatrix *) &arg5_defvalue ;
  size_t arg6 = (size_t) AUTOSOME ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "lociPos",(char *) "lociNames",(char *) "chromName",(char *) "alleleNames",(char *) "chromType", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|OOOO:Pedigree_addChrom",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_addChrom" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    std::vector< double,std::allocator< double > > *ptr = (std::vector< double,std::allocator< double > > *)0;
    res2 = swig::asptr(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_addChrom" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addChrom" "', argument " "2"" of type '" "vectorf const &""'"); 
    }
    arg2 = ptr;
  }
  if (obj2) {
    {
      std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
      res3 = swig::asptr(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_addChrom" "', argument " "3"" of type '" "vectorstr const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addChrom" "', argument " "3"" of type '" "vectorstr const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Pedigree_addChrom" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addChrom" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    res5 = SWIG_ConvertPtr(obj4, &argp5, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "Pedigree_addChrom" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp5) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addChrom" "', argument " "5"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg5 = reinterpret_cast< simuPOP::stringMatrix * >(argp5);
  }
  if (obj5) {
    ecode6 = SWIG_AsVal_size_t(obj5, &val6);
    if (!SWIG_IsOK(ecode6)) {
      SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "Pedigree_addChrom" "', argument " "6"" of type '" "size_t""'");
    } 
    arg6 = static_cast< size_t >(val6);
  }
  {
    try
    {
      (arg1)->addChrom((vectorf const &)*arg2,(vectorstr const &)*arg3,(string const &)*arg4,(simuPOP::stringMatrix const &)*arg5,arg6);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_addChromFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_addChromFrom",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_addChromFrom" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_addChromFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addChromFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->addChromFrom((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_addIndFrom(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::Population *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "pop", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_addIndFrom",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_addIndFrom" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__Population,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_addIndFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_addIndFrom" "', argument " "2"" of type '" "simuPOP::Population const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::Population * >(argp2);
  {
    try
    {
      (arg1)->addIndFrom((simuPOP::Population const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_mergeSubPops(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::uintList const &arg2_defvalue = simuPOP::uintList() ;
  simuPOP::uintList *arg2 = (simuPOP::uintList *) &arg2_defvalue ;
  string const &arg3_defvalue = "" ;
  string *arg3 = (string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "subPops",(char *) "name", NULL 
  };
  size_t result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:Pedigree_mergeSubPops",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_mergeSubPops" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  if (obj1) {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_mergeSubPops" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_mergeSubPops" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pedigree_mergeSubPops" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_mergeSubPops" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  {
    try
    {
      result = (arg1)->mergeSubPops((simuPOP::uintList const &)*arg2,(string const &)*arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_resize(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  simuPOP::uintList *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "sizes",(char *) "propagate", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO|O:Pedigree_resize",kwnames,&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_resize" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_resize" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_resize" "', argument " "2"" of type '" "simuPOP::uintList const &""'"); 
  }
  arg2 = reinterpret_cast< simuPOP::uintList * >(argp2);
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Pedigree_resize" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    try
    {
      (arg1)->resize((simuPOP::uintList const &)*arg2,arg3);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Pedigree_setSubPopByIndInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "self",(char *) "field", NULL 
  };
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"OO:Pedigree_setSubPopByIndInfo",kwnames,&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_simuPOP__Pedigree, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pedigree_setSubPopByIndInfo" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Pedigree_setSubPopByIndInfo" "', argument " "2"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Pedigree_setSubPopByIndInfo" "', argument " "2"" of type '" "string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try
    {
      (arg1)->setSubPopByIndInfo((string const &)*arg2);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Pedigree(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  simuPOP::Pedigree *arg1 = (simuPOP::Pedigree *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_simuPOP__Pedigree, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Pedigree" "', argument " "1"" of type '" "simuPOP::Pedigree *""'"); 
  }
  arg1 = reinterpret_cast< simuPOP::Pedigree * >(argp1);
  {
    try
    {
      delete arg1;
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Pedigree_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args,(char *)"swigregister", 1, 1,&obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_simuPOP__Pedigree, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Pedigree_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_loadPedigree(PyObject *SWIGUNUSEDPARM(self), PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  string *arg1 = 0 ;
  string const &arg2_defvalue = "ind_id" ;
  string *arg2 = (string *) &arg2_defvalue ;
  string const &arg3_defvalue = "father_id" ;
  string *arg3 = (string *) &arg3_defvalue ;
  string const &arg4_defvalue = "mother_id" ;
  string *arg4 = (string *) &arg4_defvalue ;
  float arg5 = (float) 2 ;
  simuPOP::uintList const &arg6_defvalue = vectoru() ;
  simuPOP::uintList *arg6 = (simuPOP::uintList *) &arg6_defvalue ;
  simuPOP::uintList const &arg7_defvalue = vectoru() ;
  simuPOP::uintList *arg7 = (simuPOP::uintList *) &arg7_defvalue ;
  simuPOP::floatList const &arg8_defvalue = simuPOP::floatList() ;
  simuPOP::floatList *arg8 = (simuPOP::floatList *) &arg8_defvalue ;
  simuPOP::stringList const &arg9_defvalue = vectorstr() ;
  simuPOP::stringList *arg9 = (simuPOP::stringList *) &arg9_defvalue ;
  simuPOP::stringMatrix const &arg10_defvalue = simuPOP::stringMatrix() ;
  simuPOP::stringMatrix *arg10 = (simuPOP::stringMatrix *) &arg10_defvalue ;
  simuPOP::stringList const &arg11_defvalue = vectorstr() ;
  simuPOP::stringList *arg11 = (simuPOP::stringList *) &arg11_defvalue ;
  simuPOP::stringList const &arg12_defvalue = vectorstr() ;
  simuPOP::stringList *arg12 = (simuPOP::stringList *) &arg12_defvalue ;
  simuPOP::stringList const &arg13_defvalue = vectorstr() ;
  simuPOP::stringList *arg13 = (simuPOP::stringList *) &arg13_defvalue ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  float val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  void *argp8 = 0 ;
  int res8 = 0 ;
  void *argp9 = 0 ;
  int res9 = 0 ;
  void *argp10 = 0 ;
  int res10 = 0 ;
  void *argp11 = 0 ;
  int res11 = 0 ;
  void *argp12 = 0 ;
  int res12 = 0 ;
  void *argp13 = 0 ;
  int res13 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  PyObject * obj9 = 0 ;
  PyObject * obj10 = 0 ;
  PyObject * obj11 = 0 ;
  PyObject * obj12 = 0 ;
  char *  kwnames[] = {
    (char *) "file",(char *) "idField",(char *) "fatherField",(char *) "motherField",(char *) "ploidy",(char *) "loci",(char *) "chromTypes",(char *) "lociPos",(char *) "chromNames",(char *) "alleleNames",(char *) "lociNames",(char *) "subPopNames",(char *) "infoFields", NULL 
  };
  SwigValueWrapper< simuPOP::Pedigree > result;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OOOOOOOOOOOO:loadPedigree",kwnames,&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8,&obj9,&obj10,&obj11,&obj12)) SWIG_fail;
  {
    std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "loadPedigree" "', argument " "1"" of type '" "string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "1"" of type '" "string const &""'"); 
    }
    arg1 = ptr;
  }
  if (obj1) {
    {
      std::string *ptr = (std::string *)0;
      res2 = SWIG_AsPtr_std_string(obj1, &ptr);
      if (!SWIG_IsOK(res2)) {
        SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "loadPedigree" "', argument " "2"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "2"" of type '" "string const &""'"); 
      }
      arg2 = ptr;
    }
  }
  if (obj2) {
    {
      std::string *ptr = (std::string *)0;
      res3 = SWIG_AsPtr_std_string(obj2, &ptr);
      if (!SWIG_IsOK(res3)) {
        SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "loadPedigree" "', argument " "3"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "3"" of type '" "string const &""'"); 
      }
      arg3 = ptr;
    }
  }
  if (obj3) {
    {
      std::string *ptr = (std::string *)0;
      res4 = SWIG_AsPtr_std_string(obj3, &ptr);
      if (!SWIG_IsOK(res4)) {
        SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "loadPedigree" "', argument " "4"" of type '" "string const &""'"); 
      }
      if (!ptr) {
        SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "4"" of type '" "string const &""'"); 
      }
      arg4 = ptr;
    }
  }
  if (obj4) {
    ecode5 = SWIG_AsVal_float(obj4, &val5);
    if (!SWIG_IsOK(ecode5)) {
      SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "loadPedigree" "', argument " "5"" of type '" "float""'");
    } 
    arg5 = static_cast< float >(val5);
  }
  if (obj5) {
    res6 = SWIG_ConvertPtr(obj5, &argp6, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res6)) {
      SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "loadPedigree" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp6) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "6"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg6 = reinterpret_cast< simuPOP::uintList * >(argp6);
  }
  if (obj6) {
    res7 = SWIG_ConvertPtr(obj6, &argp7, SWIGTYPE_p_simuPOP__uintList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "loadPedigree" "', argument " "7"" of type '" "simuPOP::uintList const &""'"); 
    }
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "7"" of type '" "simuPOP::uintList const &""'"); 
    }
    arg7 = reinterpret_cast< simuPOP::uintList * >(argp7);
  }
  if (obj7) {
    res8 = SWIG_ConvertPtr(obj7, &argp8, SWIGTYPE_p_simuPOP__floatList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "loadPedigree" "', argument " "8"" of type '" "simuPOP::floatList const &""'"); 
    }
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "8"" of type '" "simuPOP::floatList const &""'"); 
    }
    arg8 = reinterpret_cast< simuPOP::floatList * >(argp8);
  }
  if (obj8) {
    res9 = SWIG_ConvertPtr(obj8, &argp9, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res9)) {
      SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "loadPedigree" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp9) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "9"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg9 = reinterpret_cast< simuPOP::stringList * >(argp9);
  }
  if (obj9) {
    res10 = SWIG_ConvertPtr(obj9, &argp10, SWIGTYPE_p_simuPOP__stringMatrix,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res10)) {
      SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "loadPedigree" "', argument " "10"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    if (!argp10) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "10"" of type '" "simuPOP::stringMatrix const &""'"); 
    }
    arg10 = reinterpret_cast< simuPOP::stringMatrix * >(argp10);
  }
  if (obj10) {
    res11 = SWIG_ConvertPtr(obj10, &argp11, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res11)) {
      SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "loadPedigree" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp11) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "11"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg11 = reinterpret_cast< simuPOP::stringList * >(argp11);
  }
  if (obj11) {
    res12 = SWIG_ConvertPtr(obj11, &argp12, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res12)) {
      SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "loadPedigree" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp12) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "12"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg12 = reinterpret_cast< simuPOP::stringList * >(argp12);
  }
  if (obj12) {
    res13 = SWIG_ConvertPtr(obj12, &argp13, SWIGTYPE_p_simuPOP__stringList,  0  | SWIG_POINTER_IMPLICIT_CONV);
    if (!SWIG_IsOK(res13)) {
      SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "loadPedigree" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    if (!argp13) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "loadPedigree" "', argument " "13"" of type '" "simuPOP::stringList const &""'"); 
    }
    arg13 = reinterpret_cast< simuPOP::stringList * >(argp13);
  }
  {
    try
    {
      result = simuPOP::loadPedigree((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5,(simuPOP::uintList const &)*arg6,(simuPOP::uintList const &)*arg7,(simuPOP::floatList const &)*arg8,(simuPOP::stringList const &)*arg9,(simuPOP::stringMatrix const &)*arg10,(simuPOP::stringList const &)*arg11,(simuPOP::stringList const &)*arg12,(simuPOP::stringList const &)*arg13);
    }
    catch(simuPOP::StopIteration e)
    {
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
    catch(simuPOP::IndexError e)
    {
      SWIG_exception(SWIG_IndexError, e.message());
    }
    catch(simuPOP::ValueError e)
    {
      SWIG_exception(SWIG_ValueError, e.message());
    }
    catch(simuPOP::SystemError e)
    {
      SWIG_exception(SWIG_SystemError, e.message());
    }
    catch(simuPOP::RuntimeError e)
    {
      SWIG_exception(SWIG_RuntimeError, e.message());
    }
    catch(std::bad_alloc)
    {
      SWIG_exception(SWIG_MemoryError, "Memory allocation error");
    }
    catch(...)
    {
      SWIG_exception(SWIG_UnknownError, "Unknown runtime error happened.");
    }
  }
  resultobj = SWIG_NewPointerObj((new simuPOP::Pedigree(static_cast< const simuPOP::Pedigree& >(result))), SWIGTYPE_p_simuPOP__Pedigree, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res6)) delete arg6;
  if (SWIG_IsNewObj(res7)) delete arg7;
  if (SWIG_IsNewObj(res8)) delete arg8;
  if (SWIG_IsNewObj(res9)) delete arg9;
  if (SWIG_IsNewObj(res10)) delete arg10;
  if (SWIG_IsNewObj(res11)) delete arg11;
  if (SWIG_IsNewObj(res12)) delete arg12;
  if (SWIG_IsNewObj(res13)) delete arg13;
  return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"delete_SwigPyIterator", (PyCFunction)_wrap_delete_SwigPyIterator, METH_O, NULL},
	 { (char *)"SwigPyIterator_value", (PyCFunction)_wrap_SwigPyIterator_value, METH_O, NULL},
	 { (char *)"SwigPyIterator_incr", (PyCFunction) _wrap_SwigPyIterator_incr, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator_decr", (PyCFunction) _wrap_SwigPyIterator_decr, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator_distance", (PyCFunction) _wrap_SwigPyIterator_distance, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator_equal", (PyCFunction) _wrap_SwigPyIterator_equal, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator_copy", (PyCFunction)_wrap_SwigPyIterator_copy, METH_O, NULL},
	 { (char *)"SwigPyIterator_next", (PyCFunction)_wrap_SwigPyIterator_next, METH_O, NULL},
	 { (char *)"SwigPyIterator___next__", (PyCFunction)_wrap_SwigPyIterator___next__, METH_O, NULL},
	 { (char *)"SwigPyIterator_previous", (PyCFunction)_wrap_SwigPyIterator_previous, METH_O, NULL},
	 { (char *)"SwigPyIterator_advance", (PyCFunction) _wrap_SwigPyIterator_advance, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___eq__", (PyCFunction) _wrap_SwigPyIterator___eq__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___ne__", (PyCFunction) _wrap_SwigPyIterator___ne__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___iadd__", (PyCFunction) _wrap_SwigPyIterator___iadd__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___isub__", (PyCFunction) _wrap_SwigPyIterator___isub__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___add__", (PyCFunction) _wrap_SwigPyIterator___add__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"SwigPyIterator___sub__", _wrap_SwigPyIterator___sub__, METH_VARARGS, NULL},
	 { (char *)"SwigPyIterator_swigregister", SwigPyIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_Exception", (PyCFunction) _wrap_new_Exception, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Exception_message", (PyCFunction)_wrap_Exception_message, METH_O, NULL},
	 { (char *)"delete_Exception", (PyCFunction)_wrap_delete_Exception, METH_O, NULL},
	 { (char *)"Exception_swigregister", Exception_swigregister, METH_VARARGS, NULL},
	 { (char *)"Exception_swiginit", Exception_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_StopIteration", (PyCFunction) _wrap_new_StopIteration, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_StopIteration", (PyCFunction)_wrap_delete_StopIteration, METH_O, NULL},
	 { (char *)"StopIteration_swigregister", StopIteration_swigregister, METH_VARARGS, NULL},
	 { (char *)"StopIteration_swiginit", StopIteration_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_IndexError", (PyCFunction) _wrap_new_IndexError, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_IndexError", (PyCFunction)_wrap_delete_IndexError, METH_O, NULL},
	 { (char *)"IndexError_swigregister", IndexError_swigregister, METH_VARARGS, NULL},
	 { (char *)"IndexError_swiginit", IndexError_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ValueError", (PyCFunction) _wrap_new_ValueError, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_ValueError", (PyCFunction)_wrap_delete_ValueError, METH_O, NULL},
	 { (char *)"ValueError_swigregister", ValueError_swigregister, METH_VARARGS, NULL},
	 { (char *)"ValueError_swiginit", ValueError_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SystemError", (PyCFunction) _wrap_new_SystemError, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_SystemError", (PyCFunction)_wrap_delete_SystemError, METH_O, NULL},
	 { (char *)"SystemError_swigregister", SystemError_swigregister, METH_VARARGS, NULL},
	 { (char *)"SystemError_swiginit", SystemError_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RuntimeError", (PyCFunction) _wrap_new_RuntimeError, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_RuntimeError", (PyCFunction)_wrap_delete_RuntimeError, METH_O, NULL},
	 { (char *)"RuntimeError_swigregister", RuntimeError_swigregister, METH_VARARGS, NULL},
	 { (char *)"RuntimeError_swiginit", RuntimeError_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_StopEvolution", (PyCFunction) _wrap_new_StopEvolution, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_StopEvolution", (PyCFunction)_wrap_delete_StopEvolution, METH_O, NULL},
	 { (char *)"StopEvolution_swigregister", StopEvolution_swigregister, METH_VARARGS, NULL},
	 { (char *)"StopEvolution_swiginit", StopEvolution_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RevertEvolution", (PyCFunction) _wrap_new_RevertEvolution, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_RevertEvolution", (PyCFunction)_wrap_delete_RevertEvolution, METH_O, NULL},
	 { (char *)"RevertEvolution_swigregister", RevertEvolution_swigregister, METH_VARARGS, NULL},
	 { (char *)"RevertEvolution_swiginit", RevertEvolution_swiginit, METH_VARARGS, NULL},
	 { (char *)"turnOnDebug", (PyCFunction) _wrap_turnOnDebug, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    turnOnDebug(code=\"\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Set debug code code. More than one code could be specified using a\n"
		"    comma separated string. Name of available codes are available from\n"
		"    moduleInfo()['debug'].keys().\n"
		"\n"
		"\n"
		""},
	 { (char *)"turnOffDebug", (PyCFunction) _wrap_turnOffDebug, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    turnOffDebug(code=\"DBG_ALL\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Turn off debug code code. More than one code could be specified\n"
		"    using a comma separated string. Default to turn off all debug\n"
		"    codes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"elapsedTime", (PyCFunction) _wrap_elapsedTime, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    elapsedTime(name)\n"
		"\n"
		"\n"
		""},
	 { (char *)"setOptions", (PyCFunction) _wrap_setOptions, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    setOptions(numThreads=-1, name=None, seed=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    First argument is to set number of thread in openMP. The number of\n"
		"    threads can be be positive, integer (number of threads) or 0,\n"
		"    which implies all available cores, or a number set by\n"
		"    environmental variable OMP_NUM_THREADS. Second and third argument\n"
		"    is to set the type or seed of existing random number generator\n"
		"    using RNGname with seed. If using openMP, it sets the type or seed\n"
		"    of random number generator of each thread.\n"
		"\n"
		"\n"
		""},
	 { (char *)"simuPOP_kbhit", (PyCFunction)_wrap_simuPOP_kbhit, METH_NOARGS, NULL},
	 { (char *)"simuPOP_getch", (PyCFunction)_wrap_simuPOP_getch, METH_NOARGS, NULL},
	 { (char *)"pow3", (PyCFunction) _wrap_pow3, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"new_intList", (PyCFunction) _wrap_new_intList, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    intList(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_intList", (PyCFunction)_wrap_delete_intList, METH_O, NULL},
	 { (char *)"intList_swigregister", intList_swigregister, METH_VARARGS, NULL},
	 { (char *)"intList_swiginit", intList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_uintList", (PyCFunction) _wrap_new_uintList, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    uintList(obj=Py_True)\n"
		"\n"
		"\n"
		""},
	 { (char *)"uintList_unspecified", (PyCFunction)_wrap_uintList_unspecified, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.unspecified()\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_uintList", (PyCFunction)_wrap_delete_uintList, METH_O, NULL},
	 { (char *)"uintList_swigregister", uintList_swigregister, METH_VARARGS, NULL},
	 { (char *)"uintList_swiginit", uintList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_lociList", (PyCFunction) _wrap_new_lociList, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    lociList(obj=Py_True)\n"
		"\n"
		"\n"
		""},
	 { (char *)"lociList_empty", (PyCFunction)_wrap_lociList_empty, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.empty()\n"
		"\n"
		"\n"
		""},
	 { (char *)"lociList_dynamic", (PyCFunction)_wrap_lociList_dynamic, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.dynamic()\n"
		"\n"
		"\n"
		""},
	 { (char *)"lociList_elems", (PyCFunction) _wrap_lociList_elems, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_lociList", (PyCFunction)_wrap_delete_lociList, METH_O, NULL},
	 { (char *)"lociList_swigregister", lociList_swigregister, METH_VARARGS, NULL},
	 { (char *)"lociList_swiginit", lociList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_floatList", _wrap_new_floatList, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    floatList(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_floatList", (PyCFunction)_wrap_delete_floatList, METH_O, NULL},
	 { (char *)"floatList_swigregister", floatList_swigregister, METH_VARARGS, NULL},
	 { (char *)"floatList_swiginit", floatList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_stringList", _wrap_new_stringList, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    stringList(str=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"stringList_push_back", (PyCFunction) _wrap_stringList_push_back, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_stringList", (PyCFunction)_wrap_delete_stringList, METH_O, NULL},
	 { (char *)"stringList_swigregister", stringList_swigregister, METH_VARARGS, NULL},
	 { (char *)"stringList_swiginit", stringList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_intMatrix", (PyCFunction) _wrap_new_intMatrix, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    intMatrix(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_intMatrix", (PyCFunction)_wrap_delete_intMatrix, METH_O, NULL},
	 { (char *)"intMatrix_swigregister", intMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"intMatrix_swiginit", intMatrix_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_floatMatrix", (PyCFunction) _wrap_new_floatMatrix, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    floatMatrix(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_floatMatrix", (PyCFunction)_wrap_delete_floatMatrix, METH_O, NULL},
	 { (char *)"floatMatrix_swigregister", floatMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"floatMatrix_swiginit", floatMatrix_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_stringMatrix", (PyCFunction) _wrap_new_stringMatrix, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    stringMatrix(str=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_stringMatrix", (PyCFunction)_wrap_delete_stringMatrix, METH_O, NULL},
	 { (char *)"stringMatrix_swigregister", stringMatrix_swigregister, METH_VARARGS, NULL},
	 { (char *)"stringMatrix_swiginit", stringMatrix_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_uintString", _wrap_new_uintString, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    uintString(value)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_uintString", (PyCFunction)_wrap_delete_uintString, METH_O, NULL},
	 { (char *)"uintString_swigregister", uintString_swigregister, METH_VARARGS, NULL},
	 { (char *)"uintString_swiginit", uintString_swiginit, METH_VARARGS, NULL},
	 { (char *)"PyObj_AsString", (PyCFunction) _wrap_PyObj_AsString, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"new_stringFunc", _wrap_new_stringFunc, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    stringFunc(value)\n"
		"\n"
		"\n"
		""},
	 { (char *)"stringFunc_mode", (PyCFunction)_wrap_stringFunc_mode, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    COPY.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.mode()\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_stringFunc", (PyCFunction)_wrap_delete_stringFunc, METH_O, NULL},
	 { (char *)"stringFunc_swigregister", stringFunc_swigregister, METH_VARARGS, NULL},
	 { (char *)"stringFunc_swiginit", stringFunc_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_uintListFunc", _wrap_new_uintListFunc, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    uintListFunc(values=[])\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_uintListFunc", (PyCFunction)_wrap_delete_uintListFunc, METH_O, NULL},
	 { (char *)"uintListFunc_swigregister", uintListFunc_swigregister, METH_VARARGS, NULL},
	 { (char *)"uintListFunc_swiginit", uintListFunc_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_floatListFunc", _wrap_new_floatListFunc, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    floatListFunc(func)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_floatListFunc", (PyCFunction)_wrap_delete_floatListFunc, METH_O, NULL},
	 { (char *)"floatListFunc_swigregister", floatListFunc_swigregister, METH_VARARGS, NULL},
	 { (char *)"floatListFunc_swiginit", floatListFunc_swiginit, METH_VARARGS, NULL},
	 { (char *)"PyObj_As_Bool", (PyCFunction) _wrap_PyObj_As_Bool, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_Int", (PyCFunction) _wrap_PyObj_As_Int, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_SizeT", (PyCFunction) _wrap_PyObj_As_SizeT, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_Double", (PyCFunction) _wrap_PyObj_As_Double, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_String", (PyCFunction) _wrap_PyObj_As_String, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_Array", (PyCFunction) _wrap_PyObj_As_Array, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_IntArray", (PyCFunction) _wrap_PyObj_As_IntArray, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"PyObj_As_SizeTArray", (PyCFunction) _wrap_PyObj_As_SizeTArray, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Allele_Vec_As_NumArray", (PyCFunction) _wrap_Allele_Vec_As_NumArray, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Lineage_Vec_As_NumArray", (PyCFunction) _wrap_Lineage_Vec_As_NumArray, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"closeOutput", (PyCFunction) _wrap_closeOutput, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    closeOutput(output=\"\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Output files specified by '>' are closed immediately after they\n"
		"    are written. Those specified by '>>' and '>>>' are closed by a\n"
		"    simulator after Simulator.evolve(). However, these files will be\n"
		"    kept open if the operators are applied directly to a population\n"
		"    using the operators' function form. In this case, function\n"
		"    closeOutput can be used to close a specific file output, and close\n"
		"    all unclosed files if output is unspecified. An exception will be\n"
		"    raised if output does not exist or it has already been closed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_RNG_func", (PyCFunction) _wrap_new_RNG_func, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"RNG_func___call__", (PyCFunction) _wrap_RNG_func___call__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_RNG_func", (PyCFunction)_wrap_delete_RNG_func, METH_O, NULL},
	 { (char *)"RNG_func_swigregister", RNG_func_swigregister, METH_VARARGS, NULL},
	 { (char *)"RNG_func_swiginit", RNG_func_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RNG", (PyCFunction) _wrap_new_RNG, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RNG(name=None, seed=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a RNG object using specified name and seed. If rng is not\n"
		"    given, environmental variable GSL_RNG_TYPE will be used if it is\n"
		"    available. Otherwise, generator mt19937 will be used. If seed is\n"
		"    not given, /dev/urandom, /dev/random, or other system random\n"
		"    number source will be used to guarantee that random seeds are used\n"
		"    even if more than one simuPOP sessions are started simultaneously.\n"
		"    Names of supported random number generators are available from\n"
		"    moduleInfo()['availableRNGs'].\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RNG", (PyCFunction)_wrap_delete_RNG, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~RNG()\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_set", (PyCFunction) _wrap_RNG_set, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.set(name=None, seed=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Replace the existing random number generator using RNGname with\n"
		"    seed seed. If seed is 0, a random seed will be used. If name is\n"
		"    empty, use the existing RNG but reset the seed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_name", (PyCFunction)_wrap_RNG_name, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.name()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the name of the current random number generator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_seed", (PyCFunction)_wrap_RNG_seed, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.seed()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the seed used to initialize the RNG. This can be used to\n"
		"    repeat a previous session.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_generateRandomSeed", (PyCFunction)_wrap_RNG_generateRandomSeed, METH_NOARGS, NULL},
	 { (char *)"RNG_randUniform", (PyCFunction)_wrap_RNG_randUniform, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randUniform()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a rng_uniform [0, 1)\n"
		"    distribution.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randBit", (PyCFunction)_wrap_RNG_randBit, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"RNG_randInt", (PyCFunction) _wrap_RNG_randInt, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randInt(n)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return a random number in the range of [0, 1, 2, ... n-1]\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randNormal", (PyCFunction) _wrap_RNG_randNormal, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randNormal(mu, sigma)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a normal distribution with mean\n"
		"    mu and standard deviation sigma.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randExponential", (PyCFunction) _wrap_RNG_randExponential, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randExponential(mu)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a exponential distribution with\n"
		"    parameter mu.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randGamma", (PyCFunction) _wrap_RNG_randGamma, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randGamma(a, b)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a gamma distribution with a\n"
		"    shape parameters a and scale parameter b.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randChisq", (PyCFunction) _wrap_RNG_randChisq, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randChisq(nu)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a Chi-squared distribution with\n"
		"    nu degrees of freedom.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randGeometric", (PyCFunction) _wrap_RNG_randGeometric, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randGeometric(p)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a geometric distribution with\n"
		"    parameter p.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randBinomial", (PyCFunction) _wrap_RNG_randBinomial, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randBinomial(n, p)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a binomial distribution with\n"
		"    parameters n and p.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randPoisson", (PyCFunction) _wrap_RNG_randPoisson, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randPoisson(mu)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a Poisson distribution with\n"
		"    parameter mu.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randTruncatedPoisson", (PyCFunction) _wrap_RNG_randTruncatedPoisson, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randTruncatedPoisson(mu)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a positive random number following a zero-truncated\n"
		"    Poisson distribution with parameter mu.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randTruncatedBinomial", (PyCFunction) _wrap_RNG_randTruncatedBinomial, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randTruncatedBinomial(n, p)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a positive random number following a zero-truncated\n"
		"    binomial distribution with parameters n and p.\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_randMultinomial", (PyCFunction) _wrap_RNG_randMultinomial, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.randMultinomial(N, p)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Generate a random number following a multinomial distribution with\n"
		"    parameters N and p (a list of probabilities).\n"
		"\n"
		"\n"
		""},
	 { (char *)"RNG_swigregister", RNG_swigregister, METH_VARARGS, NULL},
	 { (char *)"RNG_swiginit", RNG_swiginit, METH_VARARGS, NULL},
	 { (char *)"getRNG", (PyCFunction)_wrap_getRNG, METH_NOARGS, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    return the currently used random number generator\n"
		"\n"
		"Usage:\n"
		"\n"
		"    getRNG()\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_WeightedSampler", (PyCFunction) _wrap_new_WeightedSampler, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    WeightedSampler(weights=[], N=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a weighted sampler that returns 0, 1, ... k-1 when a list\n"
		"    of k weights are specified (weights). weights do not have to add\n"
		"    up to 1. If a non-zero N is specified, exact proportions of\n"
		"    numbers will be returned in N returned numbers.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_WeightedSampler", (PyCFunction)_wrap_delete_WeightedSampler, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~WeightedSampler()\n"
		"\n"
		"\n"
		""},
	 { (char *)"WeightedSampler_draw", (PyCFunction)_wrap_WeightedSampler_draw, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.draw()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Returns a random number between 0 and k-1 with probabilities that\n"
		"    are proportional to specified weights.\n"
		"\n"
		"\n"
		""},
	 { (char *)"WeightedSampler_drawSamples", (PyCFunction) _wrap_WeightedSampler_drawSamples, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.drawSamples(n=1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Returns a list of n random numbers\n"
		"\n"
		"\n"
		""},
	 { (char *)"WeightedSampler_swigregister", WeightedSampler_swigregister, METH_VARARGS, NULL},
	 { (char *)"WeightedSampler_swiginit", WeightedSampler_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Bernullitrials", (PyCFunction) _wrap_new_Bernullitrials, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Bernullitrials(, prob, trials=0)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Bernullitrials", (PyCFunction)_wrap_delete_Bernullitrials, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Bernullitrials()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_probSize", (PyCFunction)_wrap_Bernullitrials_probSize, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.probSize()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_doTrial", (PyCFunction)_wrap_Bernullitrials_doTrial, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    generate the trial table, reset m_cur\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.doTrial()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_trial", (PyCFunction)_wrap_Bernullitrials_trial, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    if necessary, do trail again.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.trial()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_trialSucc", _wrap_Bernullitrials_trialSucc, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.trialSucc(idx)\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_trialFirstSucc", (PyCFunction) _wrap_Bernullitrials_trialFirstSucc, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.trialFirstSucc(idx)\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_trialNextSucc", (PyCFunction) _wrap_Bernullitrials_trialNextSucc, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.trialNextSucc(idx, pos)\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_setTrialSucc", (PyCFunction) _wrap_Bernullitrials_setTrialSucc, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setTrialSucc(idx, succ)\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_trialSuccRate", (PyCFunction) _wrap_Bernullitrials_trialSuccRate, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    return the succ rate for one index, used for verification pruposes\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.trialSuccRate(index)\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_probSuccRate", (PyCFunction)_wrap_Bernullitrials_probSuccRate, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    return the succ rate for current trial, used for verification\n"
		"    pruposes\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.probSuccRate()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Bernullitrials_swigregister", Bernullitrials_swigregister, METH_VARARGS, NULL},
	 { (char *)"Bernullitrials_swiginit", Bernullitrials_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Bernullitrials_T", _wrap_new_Bernullitrials_T, METH_VARARGS, NULL},
	 { (char *)"delete_Bernullitrials_T", (PyCFunction)_wrap_delete_Bernullitrials_T, METH_O, NULL},
	 { (char *)"Bernullitrials_T_setParameter", (PyCFunction) _wrap_Bernullitrials_T_setParameter, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Bernullitrials_T_doTrial", (PyCFunction)_wrap_Bernullitrials_T_doTrial, METH_O, NULL},
	 { (char *)"Bernullitrials_T_trial", (PyCFunction)_wrap_Bernullitrials_T_trial, METH_O, NULL},
	 { (char *)"Bernullitrials_T_trialSucc", (PyCFunction) _wrap_Bernullitrials_T_trialSucc, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Bernullitrials_T_probFirstSucc", (PyCFunction)_wrap_Bernullitrials_T_probFirstSucc, METH_O, NULL},
	 { (char *)"Bernullitrials_T_probNextSucc", (PyCFunction) _wrap_Bernullitrials_T_probNextSucc, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Bernullitrials_T_setTrialSucc", (PyCFunction) _wrap_Bernullitrials_T_setTrialSucc, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Bernullitrials_T_trialSuccRate", (PyCFunction) _wrap_Bernullitrials_T_trialSuccRate, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Bernullitrials_T_probSuccRate", (PyCFunction)_wrap_Bernullitrials_T_probSuccRate, METH_O, NULL},
	 { (char *)"Bernullitrials_T_swigregister", Bernullitrials_T_swigregister, METH_VARARGS, NULL},
	 { (char *)"Bernullitrials_T_swiginit", Bernullitrials_T_swiginit, METH_VARARGS, NULL},
	 { (char *)"moduleInfo", (PyCFunction)_wrap_moduleInfo, METH_NOARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    moduleInfo()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a dictionary with information regarding the currently\n"
		"    loaded simuPOP module. This dictionary has the following keys:\n"
		"    *   revision: revision number.\n"
		"    *   version: simuPOP version string.\n"
		"    *   optimized: Is this module optimized (True or False).\n"
		"    *   alleleType: Allele type of the module (short, long or binary).\n"
		"    *   maxAllele: the maximum allowed allele state, which is 1 for\n"
		"    binary modules, 255 for short modules and 65535 for long modules.\n"
		"    *   compiler: the compiler that compiles this module.\n"
		"    *   date: date on which this module is compiled.\n"
		"    *   python: version of python.\n"
		"    *   platform: platform of the module.\n"
		"    *   wordsize: size of word, can be either 32 or 64.\n"
		"    *   alleleBits: the number of bits used to store an allele\n"
		"    *   maxNumSubPop: maximum number of subpopulations.\n"
		"    *   maxIndex: maximum index size (limits population size * total\n"
		"    number of marker).\n"
		"    *   debug: A dictionary with debugging codes as keys and the\n"
		"    status of each debugging code (True or False) as their values.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_GenoStruTrait", (PyCFunction)_wrap_new_GenoStruTrait, METH_NOARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    GenoStruTrait()\n"
		"\n"
		"Details:\n"
		"\n"
		"    A GenoStruTrait object is created with the construction of a\n"
		"    Population object and cannot be initialized directly.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_lociDist", (PyCFunction) _wrap_GenoStruTrait_lociDist, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lociDist(locus1, locus2)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the distance between loci locus1 and locus2 on the same\n"
		"    chromosome. A negative value will be returned if locus1 is after\n"
		"    locus2.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_lociLeft", (PyCFunction) _wrap_GenoStruTrait_lociLeft, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_distLeft", (PyCFunction) _wrap_GenoStruTrait_distLeft, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_lociCovered", (PyCFunction) _wrap_GenoStruTrait_lociCovered, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_ploidy", (PyCFunction)_wrap_GenoStruTrait_ploidy, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.ploidy()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the number of homologous sets of chromosomes, specified by\n"
		"    the ploidy parameter of the Population function. Return 2 for a\n"
		"    haplodiploid population because two sets of chromosomes are stored\n"
		"    for both males and females in such a population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_ploidyName", (PyCFunction)_wrap_GenoStruTrait_ploidyName, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.ploidyName()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the ploidy name of this population, can be one of haploid,\n"
		"    diploid, haplodiploid, triploid, tetraploid or #-ploid where # is\n"
		"    the ploidy number.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_numLoci", _wrap_GenoStruTrait_numLoci, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numLoci()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return a list of the number of loci on all chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_sexChrom", (PyCFunction)_wrap_GenoStruTrait_sexChrom, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_isHaplodiploid", (PyCFunction)_wrap_GenoStruTrait_isHaplodiploid, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_totNumLoci", (PyCFunction)_wrap_GenoStruTrait_totNumLoci, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.totNumLoci()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the total number of loci on all chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_genoSize", (PyCFunction)_wrap_GenoStruTrait_genoSize, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_locusPos", (PyCFunction) _wrap_GenoStruTrait_locusPos, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.locusPos(locus)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the position of locus locus specified by the lociPos\n"
		"    parameter of the Population function.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_lociPos", (PyCFunction)_wrap_GenoStruTrait_lociPos, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lociPos()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the positions of all loci, specified by the lociPos\n"
		"    prameter of the Population function. The default positions are 1,\n"
		"    2, 3, 4, ... on each chromosome.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_numChrom", (PyCFunction)_wrap_GenoStruTrait_numChrom, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numChrom()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the number of chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromBegin", (PyCFunction) _wrap_GenoStruTrait_chromBegin, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromBegin(chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the index of the first locus on chromosome chrom.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromEnd", (PyCFunction) _wrap_GenoStruTrait_chromEnd, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromEnd(chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the index of the last locus on chromosome chrom plus 1.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_absLocusIndex", (PyCFunction) _wrap_GenoStruTrait_absLocusIndex, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.absLocusIndex(chrom, locus)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the absolute index of locus locus on chromosome chrom. c.f.\n"
		"    chromLocusPair.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromLocusPair", (PyCFunction) _wrap_GenoStruTrait_chromLocusPair, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromLocusPair(locus)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the chromosome and relative index of a locus using its\n"
		"    absolute index locus. c.f. absLocusIndex.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromName", (PyCFunction) _wrap_GenoStruTrait_chromName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromName(chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the name of a chromosome chrom.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromNames", (PyCFunction)_wrap_GenoStruTrait_chromNames, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromNames()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return a list of the names of all chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromType", (PyCFunction) _wrap_GenoStruTrait_chromType, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromType(chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the type of a chromosome chrom (CUSTOMIZED, AUTOSOME,\n"
		"    CHROMOSOME_X, CHROMOSOME_Y or MITOCHONDRIAL.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromTypes", (PyCFunction)_wrap_GenoStruTrait_chromTypes, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromTypes()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the type of all chromosomes (CUSTOMIZED, AUTOSOME,\n"
		"    CHROMOSOME_X, CHROMOSOME_Y, or MITOCHONDRIAL).\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_chromByName", (PyCFunction) _wrap_GenoStruTrait_chromByName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chromByName(name)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the index of a chromosome by its name.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_alleleName", (PyCFunction) _wrap_GenoStruTrait_alleleName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.alleleName(allele, locus=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the name of allele allele at lcous specified by the\n"
		"    alleleNames parameter of the Population function. locus could be\n"
		"    ignored if alleles at all loci share the same names. If the name\n"
		"    of an allele is unspecified, its value ('0', '1', '2', etc) is\n"
		"    returned.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_alleleNames", (PyCFunction) _wrap_GenoStruTrait_alleleNames, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.alleleNames(locus=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return a list of allele names at given by the alleleNames\n"
		"    parameter of the Population function. locus could be ignored if\n"
		"    alleles at all loci share the same names. This list does not have\n"
		"    to cover all possible allele states of a population so\n"
		"    alleleNames()[allele] might fail (use alleleNames(allele)\n"
		"    instead).\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_locusName", (PyCFunction) _wrap_GenoStruTrait_locusName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.locusName(locus)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the name of locus locus specified by the lociNames\n"
		"    parameter of the Population function. An empty string will be\n"
		"    returned if no name has been given to locus locus.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_lociNames", (PyCFunction)_wrap_GenoStruTrait_lociNames, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lociNames()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the names of all loci specified by the lociNames parameter\n"
		"    of the Population function. An empty list will be returned if\n"
		"    lociNames was not specified.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_locusByName", (PyCFunction) _wrap_GenoStruTrait_locusByName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.locusByName(name)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the index of a locus with name name. Raise a ValueError if\n"
		"    no locus is found. Note that empty strings are used for loci\n"
		"    without name but you cannot lookup such loci using this function.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_lociByNames", (PyCFunction) _wrap_GenoStruTrait_lociByNames, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lociByNames(names)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the indexes of loci with names names. Raise a ValueError if\n"
		"    any of the loci cannot be found.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_indexesOfLoci", (PyCFunction) _wrap_GenoStruTrait_indexesOfLoci, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.indexesOfLoci(loci=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the indexes of loci with positions positions (list of (chr,\n"
		"    pos) pairs). Raise a ValueError if any of the loci cannot be\n"
		"    found.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_hasInfoField", (PyCFunction) _wrap_GenoStruTrait_hasInfoField, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_infoSize", (PyCFunction)_wrap_GenoStruTrait_infoSize, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"GenoStruTrait_infoFields", (PyCFunction)_wrap_GenoStruTrait_infoFields, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.infoFields()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return a list of the names of all information fields of the\n"
		"    population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_infoField", (PyCFunction) _wrap_GenoStruTrait_infoField, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.infoField(idx)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the name of information field idx.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoStruTrait_infoIdx", (PyCFunction) _wrap_GenoStruTrait_infoIdx, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.infoIdx(name)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the index of information field name. Raise an IndexError if\n"
		"    name is not one of the information fields.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_GenoStruTrait", (PyCFunction)_wrap_delete_GenoStruTrait, METH_O, NULL},
	 { (char *)"GenoStruTrait_swigregister", GenoStruTrait_swigregister, METH_VARARGS, NULL},
	 { (char *)"GenoStruTrait_swiginit", GenoStruTrait_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_pyMutantIterator", (PyCFunction) _wrap_new_pyMutantIterator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    pyMutantIterator(base, begin, end, step)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_pyMutantIterator", (PyCFunction)_wrap_delete_pyMutantIterator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~pyMutantIterator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyMutantIterator___iter__", (PyCFunction)_wrap_pyMutantIterator___iter__, METH_O, NULL},
	 { (char *)"pyMutantIterator_next", (PyCFunction)_wrap_pyMutantIterator_next, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.__next__()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyMutantIterator___next__", (PyCFunction)_wrap_pyMutantIterator___next__, METH_O, NULL},
	 { (char *)"pyMutantIterator_swigregister", pyMutantIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"pyMutantIterator_swiginit", pyMutantIterator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Individual", (PyCFunction)_wrap_new_Individual, METH_NOARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Individual()\n"
		"\n"
		"Details:\n"
		"\n"
		"    An Individual object cannot be created directly. It has to be\n"
		"    accessed from a Population object using functions such as\n"
		"    Population::Individual(idx).\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Individual", (PyCFunction)_wrap_delete_Individual, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor. Do nothing.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Individual()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_allele", (PyCFunction) _wrap_Individual_allele, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.allele(idx, ploidy=-1, chrom=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the current allele at a locus, using its absolute index\n"
		"    idx. If a ploidy ploidy and/or a chromosome indexes is given, idx\n"
		"    is relative to the beginning of specified homologous copy of\n"
		"    chromosomes (if chrom=-1) or the beginning of the specified\n"
		"    homologous copy of specified chromosome (if chrom >= 0).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_alleleChar", (PyCFunction) _wrap_Individual_alleleChar, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.alleleChar(idx, ploidy=-1, chrom=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the name of allele(idx, ploidy, chrom). If idx is invalid\n"
		"    (e.g. second homologus copy of chromosome Y), '_' is returned.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setAllele", (PyCFunction) _wrap_Individual_setAllele, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setAllele(allele, idx, ploidy=-1, chrom=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set allele allele to a locus, using its absolute index idx. If a\n"
		"    ploidy ploidy and/or a chromosome indexes are given, idx is\n"
		"    relative to the beginning of specified homologous copy of\n"
		"    chromosomes (if chrom=-1) or the beginning of the specified\n"
		"    homologous copy of specified chromosome (if chrom >= 0).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_alleleLineage", (PyCFunction) _wrap_Individual_alleleLineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.alleleLineage(idx, ploidy=-1, chrom=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the lineage of the allele at a locus, using its absolute\n"
		"    index idx. If a ploidy ploidy and/or a chromosome indexes is\n"
		"    given, idx is relative to the beginning of specified homologous\n"
		"    copy of chromosomes (if chrom=-1) or the beginning of the\n"
		"    specified homologous copy of specified chromosome (if chrom >= 0).\n"
		"    This function returns 0 for modules without lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setAlleleLineage", (PyCFunction) _wrap_Individual_setAlleleLineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setAlleleLineage(lineage, idx, ploidy=-1, chrom=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set lineage lineage to an allele, using its absolute index idx. If\n"
		"    a ploidy ploidy and/or a chromosome indexes are given, idx is\n"
		"    relative to the beginning of specified homologous copy of\n"
		"    chromosomes (if chrom=-1) or the beginning of the specified\n"
		"    homologous copy of specified chromosome (if chrom >= 0). This\n"
		"    function does nothing for modules without lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_genotype", (PyCFunction) _wrap_Individual_genotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.genotype(ploidy=ALL_AVAIL, chroms=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return an editable array (a carray object) that represents all\n"
		"    alleles of an individual. If ploidy or chroms is given, only\n"
		"    alleles on the specified chromosomes and homologous copy of\n"
		"    chromosomes will be returned. If multiple chromosomes are\n"
		"    specified, there should not be gaps between chromosomes. This\n"
		"    function ignores type of chromosomes so it will return unused\n"
		"    alleles for sex and mitochondrial chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_mutants", (PyCFunction) _wrap_Individual_mutants, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.mutants(ploidy=ALL_AVAIL, chroms=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return an itertor that iterate through all mutants (non-zero\n"
		"    alleles) of an individual. Each mutant is presented as a tuple of\n"
		"    (index, value) where index is the index of mutant ranging from\n"
		"    zero to totNumLoci() * ploidy() - 1, so you will have to adjust\n"
		"    indexes to check multiple alleles at a locus. If ploidy or chroms\n"
		"    is given, only alleles on the specified chromosomes and homologous\n"
		"    copy of chromosomes will be iterated. If multiple chromosomes are\n"
		"    specified, there should not be gaps between chromosomes. This\n"
		"    function ignores type of chromosomes so it will return unused\n"
		"    alleles for sex and mitochondrial chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_lineage", (PyCFunction) _wrap_Individual_lineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lineage(ploidy=ALL_AVAIL, chroms=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return an editable array (a carray_lineage object) that represents\n"
		"    the lineages of all alleles of an individual. If ploidy or chroms\n"
		"    is given, only lineages on the specified chromosomes and\n"
		"    homologous copy of chromosomes will be returned. If multiple\n"
		"    chromosomes are specified, there should not be gaps between\n"
		"    chromosomes. This function ignores type of chromosomes so it will\n"
		"    return lineage of unused alleles for sex and mitochondrial\n"
		"    chromosomes. A None object will be returned for modules without\n"
		"    lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setGenotype", (PyCFunction) _wrap_Individual_setGenotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setGenotype(geno, ploidy=ALL_AVAIL, chroms=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Fill the genotype of an individual using a list of alleles geno.\n"
		"    If parameters ploidy and/or chroms are specified, alleles will be\n"
		"    copied to only all or specified chromosomes on selected homologous\n"
		"    copies of chromosomes. geno will be reused if its length is less\n"
		"    than number of alleles to be filled. This function ignores type of\n"
		"    chromosomes so it will set genotype for unused alleles for sex and\n"
		"    mitochondrial chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setLineage", (PyCFunction) _wrap_Individual_setLineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setLineage(lineage, ploidy=ALL_AVAIL, chroms=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Fill the lineage of an individual using a list of IDs lineage. If\n"
		"    parameters ploidy and/or chroms are specified, lineages will be\n"
		"    copied to only all or specified chromosomes on selected homologous\n"
		"    copies of chromosomes. lineage will be reused if its length is\n"
		"    less than number of allelic lineage to be filled. This function\n"
		"    ignores type of chromosomes so it will set lineage to unused\n"
		"    alleles for sex and mitochondrial chromosomes. It does nothing for\n"
		"    modules without lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_sex", (PyCFunction)_wrap_Individual_sex, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.sex()\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the sex of an individual, 1 for male and 2 for female.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setSex", (PyCFunction) _wrap_Individual_setSex, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setSex(sex)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set individual sex to MALE or FEMALE.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_affected", (PyCFunction)_wrap_Individual_affected, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.affected()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return True if this individual is affected.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setAffected", (PyCFunction) _wrap_Individual_setAffected, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setAffected(affected)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set affection status to affected (True or False).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_info", (PyCFunction) _wrap_Individual_info, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.info(field)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the value of an information field filed (by index or name).\n"
		"    ind.info(name) is equivalent to ind.name although the function\n"
		"    form allows the use of indexes of information fieldes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_setInfo", (PyCFunction) _wrap_Individual_setInfo, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setInfo(value, field)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set the value of an information field field (by index or name) to\n"
		"    value. ind.setInfo(value, field) is equivalent to ind.field =\n"
		"    value although the function form allows the use of indexes of\n"
		"    information fieldes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Individual_genoEnd", (PyCFunction) _wrap_Individual_genoEnd, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Individual___eq__", (PyCFunction) _wrap_Individual___eq__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Individual___ne__", (PyCFunction) _wrap_Individual___ne__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Individual___cmp__", (PyCFunction) _wrap_Individual___cmp__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Individual_swigregister", Individual_swigregister, METH_VARARGS, NULL},
	 { (char *)"Individual_swiginit", Individual_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_vspID", _wrap_new_vspID, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    vspID(id)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a subpopulation id. Accept id as well as names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_vspID", (PyCFunction)_wrap_delete_vspID, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~vspID()\n"
		"\n"
		"\n"
		""},
	 { (char *)"vspID___eq__", (PyCFunction) _wrap_vspID___eq__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"vspID_resolve", (PyCFunction) _wrap_vspID_resolve, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.resolve(pop)\n"
		"\n"
		"\n"
		""},
	 { (char *)"vspID_swigregister", vspID_swigregister, METH_VARARGS, NULL},
	 { (char *)"vspID_swiginit", vspID_swiginit, METH_VARARGS, NULL},
	 { (char *)"__lshift__", (PyCFunction) _wrap___lshift__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"new_subPopList", (PyCFunction) _wrap_new_subPopList, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    subPopList(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"subPopList___len__", (PyCFunction)_wrap_subPopList___len__, METH_O, NULL},
	 { (char *)"subPopList_push_back", (PyCFunction) _wrap_subPopList_push_back, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"subPopList_begin", (PyCFunction)_wrap_subPopList_begin, METH_O, NULL},
	 { (char *)"subPopList_end", (PyCFunction)_wrap_subPopList_end, METH_O, NULL},
	 { (char *)"subPopList_expandFrom", (PyCFunction) _wrap_subPopList_expandFrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    expand ALL_AVAIL and [(ALL_AVAIL, vsp), ...] according to pop\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.expandFrom(pop)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_subPopList", (PyCFunction)_wrap_delete_subPopList, METH_O, NULL},
	 { (char *)"subPopList_swigregister", subPopList_swigregister, METH_VARARGS, NULL},
	 { (char *)"subPopList_swiginit", subPopList_swiginit, METH_VARARGS, NULL},
	 { (char *)"BaseVspSplitter_clone", (PyCFunction)_wrap_BaseVspSplitter_clone, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clone()\n"
		"\n"
		"Details:\n"
		"\n"
		"    All VSP splitter defines a clone() function to create an identical\n"
		"    copy of itself.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BaseVspSplitter", (PyCFunction)_wrap_delete_BaseVspSplitter, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BaseVspSplitter()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseVspSplitter_numVirtualSubPop", (PyCFunction)_wrap_BaseVspSplitter_numVirtualSubPop, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numVirtualSubPop()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the number of VSPs defined by this splitter.\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseVspSplitter_name", (PyCFunction) _wrap_BaseVspSplitter_name, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.name(vsp)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the name of VSP vsp (an index between 0 and\n"
		"    numVirtualSubPop()).\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseVspSplitter_vspByName", (PyCFunction) _wrap_BaseVspSplitter_vspByName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.vspByName(name)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the index of a virtual subpopulation from its name. If\n"
		"    multiple virtual subpopulations share the same name, the first vsp\n"
		"    is returned.\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseVspSplitter_swigregister", BaseVspSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_CombinedSplitter", (PyCFunction) _wrap_new_CombinedSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    CombinedSplitter(splitters=[], vspMap=[], names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a combined splitter using a list of splitters. For example,\n"
		"    CombinedSplitter([SexSplitter(), AffectionSplitter()]) defines a\n"
		"    combined splitter with four VSPs, defined by male (vsp 0), female\n"
		"    (vsp 1), unaffected (vsp 2) and affected individuals (vsp 3).\n"
		"    Optionally, a new set of VSPs could be defined by parameter\n"
		"    vspMap. Each item in this parameter is a list of VSPs that will be\n"
		"    combined to a single VSP. For example, vspMap=[(0, 2), (1, 3)] in\n"
		"    the previous example will define two VSPs defined by male or\n"
		"    unaffected, and female or affected individuals. VSP names are\n"
		"    usually determined by splitters, but can also be specified using\n"
		"    parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_CombinedSplitter", (PyCFunction)_wrap_delete_CombinedSplitter, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~CombinedSplitter()\n"
		"\n"
		"\n"
		""},
	 { (char *)"CombinedSplitter_swigregister", CombinedSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"CombinedSplitter_swiginit", CombinedSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ProductSplitter", (PyCFunction) _wrap_new_ProductSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ProductSplitter(splitters=[], names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a product splitter using a list of splitters. For example,\n"
		"    ProductSplitter([SexSplitter(), AffectionSplitter()]) defines four\n"
		"    VSPs by male unaffected, male affected, female unaffected, and\n"
		"    female affected individuals. VSP names are usually determined by\n"
		"    splitters, but can also be specified using parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ProductSplitter", (PyCFunction)_wrap_delete_ProductSplitter, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~ProductSplitter()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ProductSplitter_swigregister", ProductSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ProductSplitter_swiginit", ProductSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SexSplitter", (PyCFunction) _wrap_new_SexSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SexSplitter(names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a sex splitter that defines male and female VSPs. These\n"
		"    VSPs are named Male and Female unless a new set of names are\n"
		"    specified by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SexSplitter", (PyCFunction)_wrap_delete_SexSplitter, METH_O, NULL},
	 { (char *)"SexSplitter_swigregister", SexSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"SexSplitter_swiginit", SexSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_AffectionSplitter", (PyCFunction) _wrap_new_AffectionSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    AffectionSplitter(names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a splitter that defined two VSPs by affection status.These\n"
		"    VSPs are named Unaffected and Affected unless a new set of names\n"
		"    are specified by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_AffectionSplitter", (PyCFunction)_wrap_delete_AffectionSplitter, METH_O, NULL},
	 { (char *)"AffectionSplitter_swigregister", AffectionSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"AffectionSplitter_swiginit", AffectionSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InfoSplitter", (PyCFunction) _wrap_new_InfoSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InfoSplitter(field, values=[], cutoff=[], ranges=[], names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an infomration splitter using information field field. If\n"
		"    parameter values is specified, each item in this list defines a\n"
		"    VSP in which all individuals have this value at information field\n"
		"    field. If a set of cutoff values are defined in parameter cutoff,\n"
		"    individuals are grouped by intervals defined by these cutoff\n"
		"    values. For example, cutoff=[1,2] defines three VSPs with v < 1, 1\n"
		"    <= v < 2 and v >=2 where v is the value of an individual at\n"
		"    information field field. If parameter ranges is specified, each\n"
		"    range defines a VSP. For example, ranges=[[1, 3], [2, 5]] defines\n"
		"    two VSPs with 1 <= v < 3 and 2 <= 3 < 5. Of course, only one of\n"
		"    the parameters values, cutoff and ranges should be defined, and\n"
		"    values in cutoff should be distinct, and in an increasing order. A\n"
		"    default set of names are given to each VSP unless a new set of\n"
		"    names is given by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InfoSplitter", (PyCFunction)_wrap_delete_InfoSplitter, METH_O, NULL},
	 { (char *)"InfoSplitter_swigregister", InfoSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"InfoSplitter_swiginit", InfoSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ProportionSplitter", (PyCFunction) _wrap_new_ProportionSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ProportionSplitter(proportions=[], names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a splitter that divides subpopulations by proportions,\n"
		"    which should be a list of float numbers (between 0 and 1) that add\n"
		"    up to 1. A default set of names are given to each VSP unless a new\n"
		"    set of names is given by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ProportionSplitter", (PyCFunction)_wrap_delete_ProportionSplitter, METH_O, NULL},
	 { (char *)"ProportionSplitter_swigregister", ProportionSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ProportionSplitter_swiginit", ProportionSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RangeSplitter", (PyCFunction) _wrap_new_RangeSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RangeSplitter(ranges, names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a splitter according to a number of individual ranges\n"
		"    defined in ranges. For example, RangeSplitter(ranges=[[0, 20],\n"
		"    [40, 50]]) defines two VSPs. The first VSP consists of individuals\n"
		"    0, 1, ..., 19, and the sceond VSP consists of individuals 40, 41,\n"
		"    ..., 49. Note that a nested list has to be used even if only one\n"
		"    range is defined. A default set of names are given to each VSP\n"
		"    unless a new set of names is given by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RangeSplitter", (PyCFunction)_wrap_delete_RangeSplitter, METH_O, NULL},
	 { (char *)"RangeSplitter_swigregister", RangeSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"RangeSplitter_swiginit", RangeSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_GenotypeSplitter", (PyCFunction) _wrap_new_GenotypeSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    GenotypeSplitter(loci, alleles, phase=False, names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a splitter that defines VSPs by individual genotype at loci\n"
		"    (can be indexes or names of one or more loci). Each list in a list\n"
		"    allele defines a VSP, which is a list of allowed alleles at these\n"
		"    loci. If only one VSP is defined, the outer list of the nested\n"
		"    list can be ignored. If phase if true, the order of alleles in\n"
		"    each list is significant. If more than one set of alleles are\n"
		"    given, Individuals having either of them is qualified.  For\n"
		"    example, in a haploid population, loci=1, alleles=[0, 1] defines a\n"
		"    VSP with individuals having allele 0 or 1 at locus 1, alleles=[[0,\n"
		"    1], [2]] defines two VSPs with indivdiuals in the second VSP\n"
		"    having allele 2 at locus 1. If multiple loci are involved, alleles\n"
		"    at each locus need to be defined. For example, VSP defined by\n"
		"    loci=[0, 1], alleles=[0, 1, 1, 1] consists of individuals having\n"
		"    alleles [0, 1] or [1, 1] at loci [0, 1].  In a haploid population,\n"
		"    loci=1, alleles=[0, 1] defines a VSP with individuals having\n"
		"    genotype [0, 1] or [1, 0] at locus 1. alleles[[0, 1], [2, 2]]\n"
		"    defines two VSPs with indivdiuals in the second VSP having\n"
		"    genotype [2, 2] at locus 1. If phase is set to True, the first VSP\n"
		"    will only has individuals with genotype [0, 1]. In the multiple\n"
		"    loci case, alleles should be arranged by haplotypes, for example,\n"
		"    loci=[0, 1], alleles=[0, 0, 1, 1], phase=True defines a VSP with\n"
		"    individuals having genotype -0-0-, -1-1- at loci 0 and 1. If\n"
		"    phase=False (default), genotypes -1-1-, -0-0-, -0-1- and -1-0- are\n"
		"    all allowed.  A default set of names are given to each VSP unless\n"
		"    a new set of names is given by parameter names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_GenotypeSplitter", (PyCFunction)_wrap_delete_GenotypeSplitter, METH_O, NULL},
	 { (char *)"GenotypeSplitter_swigregister", GenotypeSplitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"GenotypeSplitter_swiginit", GenotypeSplitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_pyIndIterator", (PyCFunction) _wrap_new_pyIndIterator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    pyIndIterator(begin, end, allInds, func)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_pyIndIterator", (PyCFunction)_wrap_delete_pyIndIterator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~pyIndIterator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyIndIterator___iter__", (PyCFunction)_wrap_pyIndIterator___iter__, METH_O, NULL},
	 { (char *)"pyIndIterator_next", (PyCFunction)_wrap_pyIndIterator_next, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.__next__()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyIndIterator___next__", (PyCFunction)_wrap_pyIndIterator___next__, METH_O, NULL},
	 { (char *)"pyIndIterator_swigregister", pyIndIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"pyIndIterator_swiginit", pyIndIterator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Population", (PyCFunction) _wrap_new_Population, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Population(size=[], ploidy=2, loci=[], chromTypes=[],\n"
		"      lociPos=[], ancGen=0, chromNames=[], alleleNames=[],\n"
		"      lociNames=[], subPopNames=[], infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    The following parameters are used to create a population object:\n"
		"\n"
		"Arguments:\n"
		"\n"
		"    size:           A list of subpopulation sizes. The length of this\n"
		"                    list determines the number of subpopulations of\n"
		"                    this population. If there is no subpopulation,\n"
		"                    size=[popSize] can be written as size=popSize.\n"
		"    ploidy:         Number of homologous sets of chromosomes. Default\n"
		"                    to 2 (diploid). For efficiency considerations, all\n"
		"                    chromosomes have the same number of homologous\n"
		"                    sets, even if some customized chromosomes or some\n"
		"                    individuals (e.g. males in a haplodiploid\n"
		"                    population) have different numbers of homologous\n"
		"                    sets. The first case is handled by setting\n"
		"                    chromTypes of each chromosome. Only the\n"
		"                    haplodiploid populations are handled for the\n"
		"                    second case, for which ploidy=HAPLODIPLOID should\n"
		"                    be used.\n"
		"    loci:           A list of numbers of loci on each chromosome. The\n"
		"                    length of this parameter determines the number of\n"
		"                    chromosomes. If there is only one chromosome,\n"
		"                    numLoci instead of [numLoci] can be used.\n"
		"    chromTypes:     A list that specifies the type of each chromosome,\n"
		"                    which can be AUTOSOME, CHROMOSOME_X, CHROMOSOME_Y,\n"
		"                    or CUSTOMIZED. All chromosomes are assumed to be\n"
		"                    autosomes if this parameter is ignored. Sex\n"
		"                    chromosome can only be specified in a diploid\n"
		"                    population where the sex of an individual is\n"
		"                    determined by the existence of these chromosomes\n"
		"                    using the XX (FEMALE) and XY (MALE) convention.\n"
		"                    Both sex chromosomes have to be available and be\n"
		"                    specified only once. Because chromosomes X and Y\n"
		"                    are treated as two chromosomes, recombination on\n"
		"                    the pseudo-autosomal regions of the sex chromsomes\n"
		"                    is not supported. CUSTOMIZED chromosomes are\n"
		"                    special chromosomes whose inheritance patterns are\n"
		"                    undefined. They rely on user-defined functions and\n"
		"                    operators to be passed from parents to offspring.\n"
		"                    Multiple customized chromosomes have to be\n"
		"                    arranged consecutively.\n"
		"    lociPos:        Positions of all loci on all chromosome, as a list\n"
		"                    of float numbers. Default to 1, 2, ... etc on each\n"
		"                    chromosome. lociPos should be arranged chromosome\n"
		"                    by chromosome. If lociPos are not in order within\n"
		"                    a chromosome, they will be re-arranged along with\n"
		"                    corresponding lociNames (if specified).\n"
		"    ancGen:         Number of the most recent ancestral generations to\n"
		"                    keep during evolution. Default to 0, which means\n"
		"                    only the current generation will be kept. If it is\n"
		"                    set to -1, all ancestral generations will be kept\n"
		"                    in this population (and exhaust your computer RAM\n"
		"                    quickly).\n"
		"    chromNames:     A list of chromosome names. Default to '' for all\n"
		"                    chromosomes.\n"
		"    alleleNames:    A list or a nested list of allele names. If a list\n"
		"                    of alleles is given, it will be used for all loci\n"
		"                    in this population. For example,\n"
		"                    alleleNames=('A','C','T','G') gives names A, C, T,\n"
		"                    and G to alleles 0, 1, 2, and 3 respectively. If a\n"
		"                    nested list of names is given, it should specify\n"
		"                    alleles names for all loci.\n"
		"    lociNames:      A list of names for each locus. It can be empty or\n"
		"                    a list of unique names for each locus. If loci are\n"
		"                    not specified in order, loci names will be\n"
		"                    rearranged according to their position on the\n"
		"                    chromosome.\n"
		"    subPopNames:    A list of subpopulation names. All subpopulations\n"
		"                    will have name '' if this parameter is not\n"
		"                    specified.\n"
		"    infoFields:     Names of information fields (named float number)\n"
		"                    that will be attached to each individual.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_clone", (PyCFunction)_wrap_Population_clone, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clone()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a cloned copy of a population. Note that Python statement\n"
		"    pop1 = pop only creates a reference to an existing population pop.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_swap", (PyCFunction) _wrap_Population_swap, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.swap(rhs)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Swap the content of two population objects, which can be handy in\n"
		"    some particular circumstances. For example, you could swap out a\n"
		"    population in a simulator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Population", (PyCFunction)_wrap_delete_Population, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destroy a population\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Population()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_virtualSplitter", (PyCFunction)_wrap_Population_virtualSplitter, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.virtualSplitter()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the virtual splitter associated with the population, None\n"
		"    will be returned if there is no splitter.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setVirtualSplitter", (PyCFunction) _wrap_Population_setVirtualSplitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setVirtualSplitter(splitter)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Set a VSP splitter to the population, which defines the same VSPs\n"
		"    for all subpopulations. If different VSPs are needed for different\n"
		"    subpopulations, a CombinedSplitter can be used to make these VSPs\n"
		"    available to all subpopulations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_numVirtualSubPop", (PyCFunction)_wrap_Population_numVirtualSubPop, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numVirtualSubPop()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the number of virtual subpopulations (VSP) defined by a VSP\n"
		"    splitter. Return 0 if no VSP is defined.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_activateVirtualSubPop", (PyCFunction) _wrap_Population_activateVirtualSubPop, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_deactivateVirtualSubPop", (PyCFunction) _wrap_Population_deactivateVirtualSubPop, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population___cmp__", (PyCFunction) _wrap_Population___cmp__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_fitGenoStru", (PyCFunction) _wrap_Population_fitGenoStru, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_setSubPopStru", (PyCFunction) _wrap_Population_setSubPopStru, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_numSubPop", (PyCFunction)_wrap_Population_numSubPop, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numSubPop()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the number of subpopulations in a population. Return 1 if\n"
		"    there is no subpopulation structure.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopSize", (PyCFunction) _wrap_Population_subPopSize, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopSize(subPop=[], ancGen=-1, sex=ANY_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the size of a subpopulation (subPopSize(sp)) or a virtual\n"
		"    subpopulation (subPopSize([sp, vsp])) in the current generation\n"
		"    (default) or a specified ancestral generation ancGen. If no subpop\n"
		"    is given, it is the same as popSize(ancGen, sex). Population and\n"
		"    virtual subpopulation names can be used. This function by default\n"
		"    returns number of all individuals (sex=ANY_SEX), but it will\n"
		"    return number of males (if sex=MALE_ONLY), number of females (if\n"
		"    sex=MALE_ONLY), and number of male/female pairs (if sex=PAIR_ONLY)\n"
		"    which is essentially less of the number of males and females.\n"
		"    <group>2-subpopsize</grouplociList()>\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopByName", (PyCFunction) _wrap_Population_subPopByName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopByName(name)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the index of the first subpopulation with name name. An\n"
		"    IndexError will be raised if subpopulations are not named, or if\n"
		"    no subpopulation with name name is found. Virtual subpopulation\n"
		"    name is not supported.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopName", (PyCFunction) _wrap_Population_subPopName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopName(subPop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the \"spName - vspName\" (virtual named subpopulation), \"\"\n"
		"    (unnamed non-virtual subpopulation), \"spName\" (named\n"
		"    subpopulation) or \"vspName\" (unnamed virtual subpopulation),\n"
		"    depending on whether subpopulation is named or if subPop is\n"
		"    virtual.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopNames", (PyCFunction)_wrap_Population_subPopNames, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopNames()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the names of all subpopulations (excluding virtual\n"
		"    subpopulations). An empty string will be returned for unnamed\n"
		"    subpopulations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setSubPopName", (PyCFunction) _wrap_Population_setSubPopName, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setSubPopName(name, subPop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Assign a name name to subpopulation subPop. Note that\n"
		"    subpopulation names do not have to be unique.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopSizes", (PyCFunction) _wrap_Population_subPopSizes, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopSizes(ancGen=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the sizes of all subpopulations at the current generation\n"
		"    (default) or specified ancestral generation ancGen. Virtual\n"
		"    subpopulations are not considered.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_popSize", (PyCFunction) _wrap_Population_popSize, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.popSize(ancGen=-1, sex=ANY_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the total number of individuals in all subpopulations of\n"
		"    the current generation (default) or the an ancestral generation\n"
		"    ancGen. This function by default returns number of all individuals\n"
		"    (sex=ANY_SEX), but it will return number of males (if\n"
		"    sex=MALE_ONLY), number of females (if sex=MALE_ONLY), and number\n"
		"    of male/female pairs (if sex=PAIR_ONLY) which is essentially less\n"
		"    of the number of males and females.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_absIndIndex", (PyCFunction) _wrap_Population_absIndIndex, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.absIndIndex(idx, subPop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    return the absolute index of an individual idx in subpopulation\n"
		"    subPop.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopIndPair", (PyCFunction) _wrap_Population_subPopIndPair, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopIndPair(idx)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the subpopulation ID and relative index of an individual,\n"
		"    given its absolute index idx.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopBegin", (PyCFunction) _wrap_Population_subPopBegin, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopBegin(subPop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the index of the first individual in subpopulation subPop.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_subPopEnd", (PyCFunction) _wrap_Population_subPopEnd, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.subPopEnd(subPop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the index of the last individual in subpopulation subPop\n"
		"    plus 1, so that range(subPopBegin(subPop), subPopEnd(subPop) can\n"
		"    iterate through the index of all individuals in subpopulation\n"
		"    subPop.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_individual", _wrap_Population_individual, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.individual(idx, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a refernce to individual idx in the population (if\n"
		"    subPop=[], default) or a subpopulation (if subPop=sp). Virtual\n"
		"    subpopulation is not supported. Note that a float idx is\n"
		"    acceptable as long as it rounds closely to an integer.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_indByID", (PyCFunction) _wrap_Population_indByID, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.indByID(id, ancGens=ALL_AVAIL, idField=\"ind_id\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a reference to individual with id stored in information\n"
		"    field idField (default to ind_id). This function by default search\n"
		"    the present and all ancestral generations (ancGen=ALL_AVAIL), but\n"
		"    you can limit the search in specific generations if you know which\n"
		"    generations to search (ancGens=[0,1] for present and parental\n"
		"    generations) or UNSPECIFIED to search only the current generation.\n"
		"    If no individual with id is found, an IndexError will be raised. A\n"
		"    float id is acceptable as long as it rounds closely to an integer.\n"
		"    Note that this function uses a dynamic searching algorithm which\n"
		"    tends to be slow. If you need to look for multiple individuals\n"
		"    from a static population, you might want to convert a population\n"
		"    object to a pedigree object and use function Pedigree.indByID.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_ancestor", (PyCFunction) _wrap_Population_ancestor, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.ancestor(idx, gen, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a reference to individual idx in ancestral generation gen.\n"
		"    The correct individual will be returned even if the current\n"
		"    generation is not the present one (see also useAncestralGen). If a\n"
		"    valid subPop is specified, index is relative to that subPop.\n"
		"    Virtual subpopulation is not supported. Note that a float idx is\n"
		"    acceptable as long as it rounds closely to an integer.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_individuals", (PyCFunction) _wrap_Population_individuals, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.individuals(subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return an iterator that can be used to iterate through all\n"
		"    individuals in a population (if subPop=[], default), or a\n"
		"    (virtual) subpopulation (subPop=spID or (spID, vspID)). If you\n"
		"    would like to iterate through multiple subpopulations in multiple\n"
		"    ancestral generations, please use function\n"
		"    Population.allIndividuals().\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_indIterator", (PyCFunction) _wrap_Population_indIterator, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_rawIndBegin", (PyCFunction) _wrap_Population_rawIndBegin, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_rawIndEnd", _wrap_Population_rawIndEnd, METH_VARARGS, NULL},
	 { (char *)"Population_alleleIterator", (PyCFunction) _wrap_Population_alleleIterator, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_indGenoBegin", (PyCFunction) _wrap_Population_indGenoBegin, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_indGenoEnd", (PyCFunction) _wrap_Population_indGenoEnd, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_genotype", (PyCFunction) _wrap_Population_genotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.genotype(subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return an editable array of the genotype of all individuals in a\n"
		"    population (if subPop=[], default), or individuals in a\n"
		"    subpopulation subPop. Virtual subpopulation is unsupported.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_mutants", (PyCFunction) _wrap_Population_mutants, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.mutants(subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return an iterator that iterate through mutants of all individuals\n"
		"    in a population (if subPop=[], default), or individuals in a\n"
		"    subpopulation subPop. Virtual subpopulation is unsupported. Each\n"
		"    mutant is presented as a tuple of (index, value) where index is\n"
		"    the index of mutant (from 0 to totNumLoci()*ploidy()) so you will\n"
		"    have to adjust its value to check multiple alleles at a locus.\n"
		"    This function ignores type of chromosomes so non-zero alleles in\n"
		"    unused alleles of sex and mitochondrial chromosomes are also\n"
		"    iterated.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_lineage", (PyCFunction) _wrap_Population_lineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.lineage(subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return an editable array of the lineage of alleles for all\n"
		"    individuals in a population (if subPop=[], default), or\n"
		"    individuals in a subpopulation subPop. Virtual subpopulation is\n"
		"    unsupported. This function returns None for modules without\n"
		"    lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setGenotype", (PyCFunction) _wrap_Population_setGenotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setGenotype(geno, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Fill the genotype of all individuals in a population (if\n"
		"    subPop=[]) or in a (virtual) subpopulation subPop (if subPop=sp or\n"
		"    (sp, vsp)) using a list of alleles geno. geno will be reused if\n"
		"    its length is less than subPopSize(subPop)*totNumLoci()*ploidy().\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setLineage", (PyCFunction) _wrap_Population_setLineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setLineage(geno, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Fill the lineage of all individuals in a population (if subPop=[])\n"
		"    or in a (virtual) subpopulation subPop (if subPop=sp or (sp, vsp))\n"
		"    using a list of IDs lineage. lineage will be reused if its length\n"
		"    is less than subPopSize(subPop)*totNumLoci()*ploidy(). This\n"
		"    function returns directly for modules without lineage information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_sortIndividuals", (PyCFunction) _wrap_Population_sortIndividuals, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.sortIndividuals(infoFields, reverse=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Sort individuals according to values at specified information\n"
		"    fields (infoFields). Individuals will be sorted at an increasing\n"
		"    order unless reverse is set to true.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setSubPopByIndInfo", (PyCFunction) _wrap_Population_setSubPopByIndInfo, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setSubPopByIndInfo(field)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Rearrange individuals to their new subpopulations according to\n"
		"    their integer values at information field field (value returned by\n"
		"    Individual::info(field)). individuals with negative values at this\n"
		"    field will be removed. Existing subpopulation names are kept. New\n"
		"    subpopulations will have empty names.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_splitSubPop", (PyCFunction) _wrap_Population_splitSubPop, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.splitSubPop(subPop, sizes, names=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Split subpopulation subPop into subpopulations of given sizes,\n"
		"    which should add up to the size of subpopulation subPop or 1, in\n"
		"    which case sizes are treated as proportions. If subPop is not the\n"
		"    last subpopulation, indexes of subpopulations after subPop are\n"
		"    shifted. If subPop is named, the same name will be given to all\n"
		"    new subpopulations unless a new set of names are specified for\n"
		"    these subpopulations. This function returns the IDs of split\n"
		"    subpopulations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_removeSubPops", (PyCFunction) _wrap_Population_removeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.removeSubPops(subPops)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Remove (virtual) subpopulation(s) subPops and all their\n"
		"    individuals. This function can be used to remove complete\n"
		"    subpopulations (with shifted subpopulation indexes) or individuals\n"
		"    belonging to virtual subpopulations of a subpopulation. In the\n"
		"    latter case, the subpopulations are kept even if all individuals\n"
		"    have been removed. This function only handles the present\n"
		"    generation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_removeIndividuals", (PyCFunction) _wrap_Population_removeIndividuals, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.removeIndividuals(indexes=[], IDs=[], idField=\"ind_id\",\n"
		"      filter=None)\n"
		"\n"
		"Details:\n"
		"\n"
		"    remove individual(s) by absolute indexes (parameter index) or\n"
		"    their IDs (parameter IDs), or using a filter function (paramter\n"
		"    filter). If indexes are used, only individuals at the current\n"
		"    generation will be removed. If IDs are used, all individuals with\n"
		"    one of the IDs at information field idField (default to \"ind_id\")\n"
		"    will be removed. Although \"ind_id\" usually stores unique IDs of\n"
		"    individuals, this function is frequently used to remove groups of\n"
		"    individuals with the same value at an information field. An\n"
		"    IndexError will be raised if an index is out of bound, but no\n"
		"    error will be given if an invalid ID is specified. In the last\n"
		"    case, a user-defined function should be provided. This function\n"
		"    should accept parameter \"ind\" or one or more of the information\n"
		"    fields. All individuals, including ancestors if there are multiple\n"
		"    ancestral generations, will be passed to this function.\n"
		"    Individuals that returns True will be removed. This function does\n"
		"    not affect subpopulation structure in the sense that a\n"
		"    subpopulation will be kept even if all individuals from it are\n"
		"    removed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_mergeSubPops", (PyCFunction) _wrap_Population_mergeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.mergeSubPops(subPops=ALL_AVAIL, name=\"\", toSubPop=-1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Merge subpopulations subPops. If subPops is ALL_AVAIL (default),\n"
		"    all subpopulations will be merged. subPops do not have to be\n"
		"    adjacent to each other. They will all be merged to the\n"
		"    subpopulation with the smallest subpopulation ID, unless a\n"
		"    subpopulation ID is specified using parameter toSubPop. Indexes of\n"
		"    the rest of the subpopulation may be changed. A new name can be\n"
		"    assigned to the merged subpopulation through parameter name (an\n"
		"    empty name will be ignored). This function returns the ID of the\n"
		"    merged subpopulation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addIndFrom", (PyCFunction) _wrap_Population_addIndFrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addIndFrom(pop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add all individuals, including ancestors, in pop to the current\n"
		"    population. Two populations should have the same genotypic\n"
		"    structures and number of ancestral generations. Subpopulations in\n"
		"    population pop are kept.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addChromFrom", (PyCFunction) _wrap_Population_addChromFrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addChromFrom(pop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add chromosomes in population pop to the current population.\n"
		"    population pop should have the same number of individuals as the\n"
		"    current population in the current and all ancestral generations.\n"
		"    Chromosomes of pop, if named, should not conflict with names of\n"
		"    existing chromosome. This function merges genotypes on the new\n"
		"    chromosomes from population pop individual by individual.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addLociFrom", (PyCFunction) _wrap_Population_addLociFrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addLociFrom(pop, byName=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add loci from population pop. By default, chromosomes are merged\n"
		"    by index and names of merged chromosomes of population pop will be\n"
		"    ignored (merge of two chromosomes with different names will yield\n"
		"    a warning). If byName is set to True, chromosomes in pop will be\n"
		"    merged to chromosomes with identical names. Added loci will be\n"
		"    inserted according to their position. Their position and names\n"
		"    should not overlap with any locus in the current population.\n"
		"    population pop should have the same number of individuals as the\n"
		"    current population in the current and all ancestral generations.\n"
		"    Allele lineages are also copied from pop in modules with lineage\n"
		"    information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addChrom", (PyCFunction) _wrap_Population_addChrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addChrom(lociPos, lociNames=[], chromName=\"\", alleleNames=[],\n"
		"      chromType=AUTOSOME)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add chromosome chromName with given type chromType to a\n"
		"    population, with loci lociNames inserted at position lociPos.\n"
		"    lociPos should be ordered. lociNames and chromName should not\n"
		"    exist in the current population. Allele names could be specified\n"
		"    for all loci (a list of names) or differently for each locus (a\n"
		"    nested list of names), using parameter alleleNames. Empty loci\n"
		"    names will be used if lociNames is not specified. The newly added\n"
		"    alleles will have zero lineage in modules wiht lineage\n"
		"    information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addLoci", (PyCFunction) _wrap_Population_addLoci, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addLoci(chrom, pos, lociNames=[], alleleNames=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Insert loci lociNames at positions pos on chromosome chrom. These\n"
		"    parameters should be lists of the same length, although names may\n"
		"    be ignored, in which case empty strings will be assumed. Single-\n"
		"    value input is allowed for parameter chrom and pos if only one\n"
		"    locus is added. Alleles at inserted loci are initialized with zero\n"
		"    alleles. Note that loci have to be added to existing chromosomes.\n"
		"    If loci on a new chromosome need to be added, function addChrom\n"
		"    should be used. Optionally, allele names could be specified either\n"
		"    for all loci (a single list) or each loci (a nested list). This\n"
		"    function returns indexes of the inserted loci. Newly inserted\n"
		"    alleles will have zero lineage in modules with lineage\n"
		"    information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_resize", (PyCFunction) _wrap_Population_resize, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.resize(sizes, propagate=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Resize population by giving new subpopulation sizes sizes.\n"
		"    individuals at the end of some subpopulations will be removed if\n"
		"    the new subpopulation size is smaller than the old one. New\n"
		"    individuals will be appended to a subpopulation if the new size is\n"
		"    larger. Their genotypes will be set to zero (default), or be\n"
		"    copied from existing individuals if propagate is set to True. More\n"
		"    specifically, if a subpopulation with 3 individuals is expanded to\n"
		"    7, the added individuals will copy genotypes from individual 1, 2,\n"
		"    3, and 1 respectively. Note that this function only resizes the\n"
		"    current generation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_extractSubPops", (PyCFunction) _wrap_Population_extractSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.extractSubPops(subPops=ALL_AVAIL, rearrange=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Extract a list of (virtual) subpopulations from a population and\n"
		"    create a new population. If rearrange is False (default),\n"
		"    structure and names of extracted subpopulations are kept although\n"
		"    extracted subpopulations can have fewer individuals if they are\n"
		"    created from extracted virtual subpopulations. (e.g. it is\n"
		"    possible to extract all male individuals from a subpopulation\n"
		"    using a SexSplitter()). If rearrange is True, each (virtual)\n"
		"    subpopulation in subPops becomes a new subpopulation in the\n"
		"    extracted population in the order at which they are specified.\n"
		"    Because each virtual subpopulation becomes a subpopulation, this\n"
		"    function could be used, for example, to separate male and female\n"
		"    individuals to two subpopulations ( subPops=[(0,0), (0,1)]). If\n"
		"    overlapping (virtual) subpopulations are specified, individuals\n"
		"    will be copied multiple times. This function only extract\n"
		"    individuals from the present generation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_extractIndividuals", (PyCFunction) _wrap_Population_extractIndividuals, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.extractIndividuals(indexes=[], IDs=[], idField=\"ind_id\",\n"
		"      filter=None)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Extract individuals with given absolute indexes (parameter\n"
		"    indexes), IDs (parameter IDs, stored in information field idField,\n"
		"    default to ind_id), or a filter function (parameter filter). If a\n"
		"    list of absolute indexes are specified, the present generation\n"
		"    will be extracted and form a one-generational population. If a\n"
		"    list of IDs are specified, this function will look through all\n"
		"    ancestral generations and extract individuals with given ID.\n"
		"    Individuals with shared IDs are allowed. In the last case, a user-\n"
		"    defined Python function should be provided. This function should\n"
		"    accept parameter \"ind\" or one or more of the information fields.\n"
		"    All individuals, including ancestors if there are multiple\n"
		"    ancestral generations, will be passed to this function.\n"
		"    Individuals that returns True will be extracted. Extracted\n"
		"    individuals will be in their original ancestral generations and\n"
		"    subpopulations, even if some subpopulations or generations are\n"
		"    empty. An IndexError will be raised if an index is out of bound\n"
		"    but no error will be given if an invalid ID is encountered.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_removeLoci", (PyCFunction) _wrap_Population_removeLoci, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.removeLoci(loci=UNSPECIFIED, keep=UNSPECIFIED)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Remove loci (absolute indexes or names) and genotypes at these\n"
		"    loci from the current population. Alternatively, a parameter keep\n"
		"    can be used to specify loci that will not be removed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_recodeAlleles", (PyCFunction) _wrap_Population_recodeAlleles, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.recodeAlleles(alleles, loci=ALL_AVAIL, alleleNames=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Recode alleles at loci (can be a list of loci indexes or names, or\n"
		"    all loci in a population (ALL_AVAIL)) to other values according to\n"
		"    parameter alleles. This parameter can a list of new allele numbers\n"
		"    for alleles 0, 1, 2, ... (allele x will be recoded to\n"
		"    newAlleles[x], x outside of the range of newAlleles will not be\n"
		"    recoded, although a warning will be given if DBG_WARNING is\n"
		"    defined) or a Python function, which should accept one or both\n"
		"    parameters allele (existing allele) and locus (index of locus).\n"
		"    The return value will become the new allele. This function is\n"
		"    intended to recode some alleles without listing all alleles in a\n"
		"    list. It will be called once for each existing allele so it is not\n"
		"    possible to recode an allele to different alleles. A new list of\n"
		"    allele names could be specified for these loci. Different sets of\n"
		"    names could be specified for each locus if a nested list of names\n"
		"    are given. This function recode alleles for all subpopulations in\n"
		"    all ancestral generations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_push", (PyCFunction) _wrap_Population_push, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.push(pop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Push population pop into the current population. Both populations\n"
		"    should have the same genotypic structure. The current population\n"
		"    is discarded if ancestralDepth (maximum number of ancestral\n"
		"    generations to hold) is zero so no ancestral generation can be\n"
		"    kept. Otherise, the current population will become the parental\n"
		"    generation of pop. If ancGen of a population is positive and there\n"
		"    are already ancGen ancestral generations (c.f. ancestralGens()),\n"
		"    the greatest ancestral generation will be discarded. In any case,\n"
		"    Populationpop becomes invalid as all its individuals are absorbed\n"
		"    by the current population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_curAncestralGen", (PyCFunction)_wrap_Population_curAncestralGen, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_ancestralGens", (PyCFunction)_wrap_Population_ancestralGens, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.ancestralGens()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the actual number of ancestral generations stored in a\n"
		"    population, which does not necessarily equal to the number set by\n"
		"    setAncestralDepth().\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setIndInfo", (PyCFunction) _wrap_Population_setIndInfo, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setIndInfo(values, field, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Set information field field (specified by index or name) of all\n"
		"    individuals (if subPop=[], default), or individuals in a (virtual)\n"
		"    subpopulation (subPop=sp or (sp, vsp)) to values. values will be\n"
		"    reused if its length is smaller than the size of the population or\n"
		"    (virtual) subpopulation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_infoBegin", (PyCFunction) _wrap_Population_infoBegin, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_infoEnd", (PyCFunction) _wrap_Population_infoEnd, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Population_indInfo", (PyCFunction) _wrap_Population_indInfo, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.indInfo(field, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the values (as a list) of information field field (by index\n"
		"    or name) of all individuals (if subPop=[], default), or\n"
		"    individuals in a (virtual) subpopulation (if subPop=sp or (sp,\n"
		"    vsp)).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_addInfoFields", (PyCFunction) _wrap_Population_addInfoFields, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.addInfoFields(fields, init=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add a list of information fields fields to a population and\n"
		"    initialize their values to init. If an information field alreay\n"
		"    exists, it will be re-initialized.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setInfoFields", (PyCFunction) _wrap_Population_setInfoFields, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setInfoFields(fields, init=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Set information fields fields to a population and initialize them\n"
		"    with value init. All existing information fields will be removed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_removeInfoFields", (PyCFunction) _wrap_Population_removeInfoFields, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.removeInfoFields(fields)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Remove information fields fields from a population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_updateInfoFieldsFrom", (PyCFunction) _wrap_Population_updateInfoFieldsFrom, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.updateInfoFieldsFrom(fields, pop, fromFields=[],\n"
		"      ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Update information fields fields from fromFields of another\n"
		"    population (or Pedigree) pop. Two populations should have the same\n"
		"    number of individuals. If fromFields is not specified, it is\n"
		"    assumed to be the same as fields. If ancGens is not ALL_AVAIL,\n"
		"    only the specified ancestral generations are updated.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_setAncestralDepth", (PyCFunction) _wrap_Population_setAncestralDepth, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.setAncestralDepth(depth)\n"
		"\n"
		"Details:\n"
		"\n"
		"    set the intended ancestral depth of a population to depth, which\n"
		"    can be 0 (does not store any ancestral generation), -1 (store all\n"
		"    ancestral generations), and a positive number (store depth\n"
		"    ancestral generations. If there exists more than depth ancestral\n"
		"    generations (if depth > 0), extra ancestral generations are\n"
		"    removed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_useAncestralGen", (PyCFunction) _wrap_Population_useAncestralGen, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.useAncestralGen(idx)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Making ancestral generation idx (0 for current generation, 1 for\n"
		"    parental generation, 2 for grand-parental generation, etc) the\n"
		"    current generation. This is an efficient way to access Population\n"
		"    properties of an ancestral generation. useAncestralGen(0) should\n"
		"    always be called afterward to restore the correct order of\n"
		"    ancestral generations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_save", (PyCFunction) _wrap_Population_save, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.save(filename)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Save population to a file filename, which can be loaded by a\n"
		"    global function loadPopulation(filename).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_vars", (PyCFunction) _wrap_Population_vars, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.vars(subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    return variables of a population as a Python dictionary. If a\n"
		"    valid subpopulation subPop is specified, a dictionary\n"
		"    vars()[\"subPop\"][subPop] is returned. A ValueError will be raised\n"
		"    if key subPop does not exist in vars(), or if key subPop does not\n"
		"    exist in vars()[\"subPop\"].\n"
		"\n"
		"\n"
		""},
	 { (char *)"Population_evaluate", (PyCFunction) _wrap_Population_evaluate, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_execute", (PyCFunction) _wrap_Population_execute, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Population_swigregister", Population_swigregister, METH_VARARGS, NULL},
	 { (char *)"Population_swiginit", Population_swiginit, METH_VARARGS, NULL},
	 { (char *)"loadPopulation", (PyCFunction) _wrap_loadPopulation, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    loadPopulation(file)\n"
		"\n"
		"Details:\n"
		"\n"
		"    load a population from a file saved by Population::save().\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_BaseOperator", (PyCFunction) _wrap_new_BaseOperator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BaseOperator(output, begin, end, step, at, reps, subPops,\n"
		"      infoFields)\n"
		"\n"
		"Details:\n"
		"\n"
		"    The following parameters can be specified by all operators.\n"
		"    However, an operator can ignore some parameters and the exact\n"
		"    meaning of a parameter can vary.\n"
		"\n"
		"Arguments:\n"
		"\n"
		"    output:         A string that specifies how output from an\n"
		"                    operator is written, which can be '' (no output),\n"
		"                    '>' (standard output), 'filename' prefixed by one\n"
		"                    or more '>', or an Python expression prefixed by\n"
		"                    an exclamation mark ('!expr'). If a file object,\n"
		"                    or any Python object with a write function is\n"
		"                    provided, the output will be write to this file.\n"
		"                    Alternatively, a Python function or a file object\n"
		"                    (any Python object with a write function) can be\n"
		"                    given which will be called with a string of output\n"
		"                    content. A global function WithMode can be used to\n"
		"                    let simuPOP output bytes instead of string.\n"
		"    begin:          The starting generation at which an operator will\n"
		"                    be applied. Default to 0. A negative number is\n"
		"                    interpreted as a generation counted from the end\n"
		"                    of an evolution (-1 being the last evolved\n"
		"                    generation).\n"
		"    end:            The last generation at which an operator will be\n"
		"                    applied. Default to -1, namely the last\n"
		"                    generation.\n"
		"    step:           The number of generations between applicable\n"
		"                    generations. Default to 1.\n"
		"    at:             A list of applicable generations. Parameters\n"
		"                    begin, end, and step will be ignored if this\n"
		"                    parameter is specified. A single generation number\n"
		"                    is also acceptable.\n"
		"    reps:           A list of applicable replicates. A common default\n"
		"                    value ALL_AVAIL is interpreted as all replicates\n"
		"                    in a simulator. Negative indexes such as -1 (last\n"
		"                    replicate) is acceptable. rep=idx can be used as a\n"
		"                    shortcut for rep=[idx].\n"
		"    subPops:        A list of applicable (virtual) subpopulations,\n"
		"                    such as subPops=[sp1, sp2, (sp2, vsp1)].\n"
		"                    subPops=[sp1] can be simplied as subPops=sp1.\n"
		"                    Negative indexes are not supported. A common\n"
		"                    default value (ALL_AVAIL) of this parameter\n"
		"                    reprents all subpopulations of the population\n"
		"                    being aplied. Suport for this parameter vary from\n"
		"                    operator to operator and some operators do not\n"
		"                    support virtual subpopulations at all. Please\n"
		"                    refer to the reference manual of individual\n"
		"                    operators for their support for this parameter.\n"
		"    infoFields:     A list of information fields that will be used by\n"
		"                    an operator. You usually do not need to specify\n"
		"                    this parameter because operators that use\n"
		"                    information fields usually have default values for\n"
		"                    this parameter.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BaseOperator", (PyCFunction)_wrap_delete_BaseOperator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destroy an operator\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BaseOperator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseOperator_clone", (PyCFunction)_wrap_BaseOperator_clone, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clone()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a cloned copy of an operator. This function is available to\n"
		"    all operators.\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseOperator_apply", (PyCFunction) _wrap_BaseOperator_apply, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.apply(pop)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Apply an operator to population pop directly, without checking its\n"
		"    applicability.\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseOperator_describe", (PyCFunction) _wrap_BaseOperator_describe, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"BaseOperator_swigregister", BaseOperator_swigregister, METH_VARARGS, NULL},
	 { (char *)"BaseOperator_swiginit", BaseOperator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_opList", _wrap_new_opList, METH_VARARGS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    opList(obj=None)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_opList", (PyCFunction)_wrap_delete_opList, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~opList()\n"
		"\n"
		"\n"
		""},
	 { (char *)"opList_swigregister", opList_swigregister, METH_VARARGS, NULL},
	 { (char *)"opList_swiginit", opList_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Pause", (PyCFunction) _wrap_new_Pause, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Pause(stopOnKeyStroke=False, prompt=True, output=\">\", begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that pause the evolution of a population when\n"
		"    it is applied to this population. If stopOnKeyStroke is False\n"
		"    (default), it will always pause a population when it is applied,\n"
		"    if this parameter is set to True, the operator will pause a\n"
		"    population if any key has been pressed. If a specific character is\n"
		"    set, the operator will stop when this key has been pressed. This\n"
		"    allows, for example, the use of several pause operators to pause\n"
		"    different populations.  After a population has been paused, a\n"
		"    message will be displayed (unless prompt is set to False) and\n"
		"    tells you how to proceed. You can press 's' to stop the evolution\n"
		"    of this population, 'S' to stop the evolution of all populations,\n"
		"    or 'p' to enter a Python shell. The current population will be\n"
		"    available in this Python shell as \"pop_X_Y\" when X is generation\n"
		"    number and Y is replicate number. The evolution will continue\n"
		"    after you exit this interactive Python shell.\n"
		"\n"
		"Note:\n"
		"\n"
		"    Ctrl-C will be intercepted even if a specific character is\n"
		"    specified in parameter stopOnKeyStroke.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Pause", (PyCFunction)_wrap_delete_Pause, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Pause()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pause_swigregister", Pause_swigregister, METH_VARARGS, NULL},
	 { (char *)"Pause_swiginit", Pause_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_NoneOp", (PyCFunction) _wrap_new_NoneOp, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    NoneOp(output=\">\", begin=0, end=0, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a NoneOp.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_NoneOp", (PyCFunction)_wrap_delete_NoneOp, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~NoneOp()\n"
		"\n"
		"\n"
		""},
	 { (char *)"NoneOp_swigregister", NoneOp_swigregister, METH_VARARGS, NULL},
	 { (char *)"NoneOp_swiginit", NoneOp_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_IfElse", (PyCFunction) _wrap_new_IfElse, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    IfElse(cond, ifOps=[], elseOps=[], output=\">\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a conditional operator that will apply operators ifOps if\n"
		"    condition cond is met and elseOps otherwise. If a Python\n"
		"    expression (a string) is given to parameter cond, the expression\n"
		"    will be evalulated in each population's local namespace when this\n"
		"    operator is applied. When a Python function is specified, it\n"
		"    accepts parameter pop when it is applied to a population, and one\n"
		"    or more parameters pop, off, dad or mom when it is applied during\n"
		"    mating. The return value of this function should be True or False.\n"
		"    Otherwise, parameter cond will be treated as a fixed condition\n"
		"    (converted to True or False) upon which one set of operators is\n"
		"    always applied. The applicability of ifOps and elseOps are\n"
		"    controlled by parameters begin, end, step, at and rep of both the\n"
		"    IfElse operator and individual operators but ifOps and elseOps\n"
		"    opeartors does not support negative indexes for replicate and\n"
		"    generation numbers.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_IfElse", (PyCFunction)_wrap_delete_IfElse, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~IfElse()\n"
		"\n"
		"\n"
		""},
	 { (char *)"IfElse_swigregister", IfElse_swigregister, METH_VARARGS, NULL},
	 { (char *)"IfElse_swiginit", IfElse_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_TerminateIf", (PyCFunction) _wrap_new_TerminateIf, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    TerminateIf(condition=\"\", stopAll=False, message=\"\", output=\"\",\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a terminator with an expression condition, which will be\n"
		"    evalulated in a population's local namespace when the operator is\n"
		"    applied to this population. If the return value of condition is\n"
		"    True, the evolution of the population will be terminated. If\n"
		"    stopAll is set to True, the evolution of all replicates of the\n"
		"    simulator will be terminated. If this operator is allowed to write\n"
		"    to an output (default to \"\"), the generation number, proceeded\n"
		"    with an optional message.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_TerminateIf", (PyCFunction)_wrap_delete_TerminateIf, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~TerminateIf()\n"
		"\n"
		"\n"
		""},
	 { (char *)"TerminateIf_swigregister", TerminateIf_swigregister, METH_VARARGS, NULL},
	 { (char *)"TerminateIf_swiginit", TerminateIf_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RevertIf", (PyCFunction) _wrap_new_RevertIf, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RevertIf(cond, fromPop=\"\", ops=[], output=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Replaces the current evolving population by a population loaded\n"
		"    from fromPop, which should be a file saved by function\n"
		"    Population.save() or operator SavePopulation. If a Python\n"
		"    expression (a string) is given to parameter cond, the expression\n"
		"    will be evalulated in each population's local namespace when this\n"
		"    operator is applied. When a Python function with optional\n"
		"    parameter pop is specified, it should accept the current\n"
		"    population (to parameter pop) and converts and return True or\n"
		"    False. Otherwise, parameter cond will be treated as a fixed\n"
		"    condition (converted to True or False) upon which the population\n"
		"    is reverted. After the population is reverted, an optional list of\n"
		"    operators ops could be applied to the population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RevertIf", (PyCFunction)_wrap_delete_RevertIf, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~RevertIf()\n"
		"\n"
		"\n"
		""},
	 { (char *)"RevertIf_swigregister", RevertIf_swigregister, METH_VARARGS, NULL},
	 { (char *)"RevertIf_swiginit", RevertIf_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_DiscardIf", (PyCFunction) _wrap_new_DiscardIf, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    DiscardIf(cond, exposeInd=\"\", output=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that discard individuals according to an\n"
		"    expression or the return value of a Python function (parameter\n"
		"    cond). This operator can be applied to a population before or\n"
		"    after mating, or to offspring during mating. If an expression is\n"
		"    passed to cond, it will be evalulated with each individual's\n"
		"    information fields (see operator InfoEval for details). If\n"
		"    exposeInd is non-empty, individuals will be available for\n"
		"    evaluation in the expression as an variable with name spacied by\n"
		"    exposeInd. If the expression is evaluated to be True, individuals\n"
		"    (if applied before or after mating) or offspring (if applied\n"
		"    during mating) will be removed or discard. Otherwise the return\n"
		"    value should be either False (not discard), or a float number\n"
		"    between 0 and 1 as the probability that the individual is removed.\n"
		"    If a function is passed to cond, it should accept paramters ind\n"
		"    and pop or names of information fields when it is applied to a\n"
		"    population (pre or post mating), or parameters off, dad, mom, pop\n"
		"    (parental population), or names of information fields if the\n"
		"    operator is applied during mating. Individuals will be discarded\n"
		"    if this function returns True or at a probability if a float\n"
		"    number between 0 and 1 is returned. A constant expression (e.g.\n"
		"    True, False, 0.4) is also acceptable, with the last example\n"
		"    (cond=0.1) that removes 10% of individuals at randomly. This\n"
		"    operator supports parameter subPops and will remove only\n"
		"    individuals belonging to specified (virtual) subpopulations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_DiscardIf", (PyCFunction)_wrap_delete_DiscardIf, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~DiscardIf()\n"
		"\n"
		"\n"
		""},
	 { (char *)"DiscardIf_swigregister", DiscardIf_swigregister, METH_VARARGS, NULL},
	 { (char *)"DiscardIf_swiginit", DiscardIf_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_TicToc", (PyCFunction) _wrap_new_TicToc, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    TicToc(output=\">\", stopAfter=0, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a TicToc operator that outputs the elapsed since the last\n"
		"    time it was applied, and the overall time since the first time\n"
		"    this operator is applied.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_TicToc", (PyCFunction)_wrap_delete_TicToc, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~TicToc()\n"
		"\n"
		"\n"
		""},
	 { (char *)"TicToc_swigregister", TicToc_swigregister, METH_VARARGS, NULL},
	 { (char *)"TicToc_swiginit", TicToc_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyOperator", (PyCFunction) _wrap_new_PyOperator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyOperator(func, param=None, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a pure-Python operator that calls a user-defined function\n"
		"    when it is applied. If this operator is applied before or after\n"
		"    mating, your function should have form func(pop) or func(pop,\n"
		"    param) where pop is the population to which the operator is\n"
		"    applied, param is the value specified in parameter param. param\n"
		"    will be ignored if your function only accepts one parameter.\n"
		"    Althernatively, the function should have form func(ind) with\n"
		"    optional parameters pop and param. In this case, the function will\n"
		"    be called for all individuals, or individuals in subpopulations\n"
		"    subPops. Individuals for which the function returns False will be\n"
		"    removed from the population. This operator can therefore perform\n"
		"    similar functions as operator DiscardIf.  If this operator is\n"
		"    applied during mating, your function should accept parameters pop,\n"
		"    off (or ind), dad, mom and param where pop is the parental\n"
		"    population, and off or ind, dad, and mom are offspring and their\n"
		"    parents for each mating event, and param is an optional parameter.\n"
		"    If subPops are provided, only offspring in specified (virtual)\n"
		"    subpopulations are acceptable.  This operator does not support\n"
		"    parameters output, and infoFields. If certain output is needed, it\n"
		"    should be handled in the user defined function func. Because the\n"
		"    status of files used by other operators through parameter output\n"
		"    is undetermined during evolution, they should not be open or\n"
		"    closed in this Python operator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyOperator", (PyCFunction)_wrap_delete_PyOperator, METH_O, NULL},
	 { (char *)"PyOperator_swigregister", PyOperator_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyOperator_swiginit", PyOperator_swiginit, METH_VARARGS, NULL},
	 { (char *)"applyDuringMatingOperator", (PyCFunction) _wrap_applyDuringMatingOperator, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"new_OffspringGenerator", (PyCFunction) _wrap_new_OffspringGenerator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    OffspringGenerator(ops, numOffspring=1, sexMode=RANDOM_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a basic offspring generator. This offspring generator uses\n"
		"    ops genotype transmitters to transmit genotypes from parents to\n"
		"    offspring.  A number of during-mating operators (parameter ops)\n"
		"    can be used to, among other possible duties such as setting\n"
		"    information fields of offspring, transmit genotype from parents to\n"
		"    offspring. This general offspring generator does not have any\n"
		"    default during-mating operator but all stock mating schemes use an\n"
		"    offspring generator with a default operator. For example, a\n"
		"    mendelianOffspringGenerator is used by RandomMating to trasmit\n"
		"    genotypes. Note that applicability parameters begin, step, end, at\n"
		"    and reps could be used in these operators but negative population\n"
		"    and generation indexes are unsupported.  Parameter numOffspring is\n"
		"    used to control the number of offspring per mating event, or in\n"
		"    another word the number of offspring in each family. It can be a\n"
		"    number, a Python function or generator, or a mode parameter\n"
		"    followed by some optional arguments. If a number is given, given\n"
		"    number of offspring will be generated at each mating event. If a\n"
		"    Python function is given, it will be called each time when a\n"
		"    mating event happens. When a generator function is specified, it\n"
		"    will be called for each subpopulation to provide number of\n"
		"    offspring for all mating events during the populating of this\n"
		"    subpopulation. Current generation number will be passed to this\n"
		"    function or generator function if parameter \"gen\" is used in this\n"
		"    function. In the last case, a tuple (or a list) in one of the\n"
		"    following forms can be given:\n"
		"    *   (GEOMETRIC_DISTRIBUTION, p)\n"
		"    *   (POISSON_DISTRIBUTION, p), p > 0\n"
		"    *   (BINOMIAL_DISTRIBUTION, p, N), 0 < p <=1, N > 0\n"
		"    *   (UNIFORM_DISTRIBUTION, a, b), 0 <= a <= b. In this case, the\n"
		"    number of offspring will be determined randomly following the\n"
		"    specified statistical distributions. Because families with zero\n"
		"    offspring are silently ignored, the distribution of the observed\n"
		"    number of offspring per mating event (excluding zero) follows\n"
		"    zero-truncated versions of these distributions.  Parameter\n"
		"    numOffspring specifies the number of offspring per mating event\n"
		"    but the actual surviving offspring can be less than specified.\n"
		"    More spefically, if any during-mating operator returns False, an\n"
		"    offspring will be discarded so the actually number of offspring of\n"
		"    a mating event will be reduced. This is essentially how during-\n"
		"    mating selector works.  Parameter sexMode is used to control the\n"
		"    sex of each offspring. Its default value is usually RANDOM_SEX\n"
		"    which assign MALE or FEMALE to each individual randomly, with\n"
		"    equal probabilities. If NO_SEX is given, offspring sex will not be\n"
		"    changed. sexMode can also be one of\n"
		"    *   (PROB_OF_MALES, p) where p is the probability of male for each\n"
		"    offspring,\n"
		"    *   (NUM_OF_MALES, n) where n is the number of males in a mating\n"
		"    event. If n is greater than or equal to the number of offspring in\n"
		"    this family, all offspring in this family will be MALE.\n"
		"    *   (NUM_OF_FEMALES, n) where n is the number of females in a\n"
		"    mating event,\n"
		"    *   (SEQUENCE_OF_SEX, s1, s2 ...) where s1, s2 etc are MALE or\n"
		"    FEMALE. The sequence will be used for each mating event. It will\n"
		"    be reused if the number of offspring in a mating event is greater\n"
		"    than the length of sequence.\n"
		"    *   (GLOBAL_SEQUENCE_OF_SEX, s1, s2, ...) where s1, s2 etc are\n"
		"    MALE or FEMALE. The sequence will be used across mating events. It\n"
		"    will be reused if the number of offspring in a subpopulation is\n"
		"    greater than the length of sequence. Finally, parameter sexMode\n"
		"    accepts a function or a generator function. A function will be\n"
		"    called whenever an offspring is produced. A generator will be\n"
		"    created at each subpopulation and will be used to produce sex for\n"
		"    all offspring in this subpopulation. No parameter is accepted.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_OffspringGenerator", (PyCFunction)_wrap_delete_OffspringGenerator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~OffspringGenerator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"OffspringGenerator_clone", (PyCFunction)_wrap_OffspringGenerator_clone, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"OffspringGenerator_describe", (PyCFunction) _wrap_OffspringGenerator_describe, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"OffspringGenerator_swigregister", OffspringGenerator_swigregister, METH_VARARGS, NULL},
	 { (char *)"OffspringGenerator_swiginit", OffspringGenerator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ControlledOffspringGenerator", (PyCFunction) _wrap_new_ControlledOffspringGenerator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ControlledOffspringGenerator(loci, alleles, freqFunc, ops=[],\n"
		"      numOffspring=1, sexMode=RANDOM_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an offspring generator that selects offspring so that\n"
		"    allele frequency at specified loci in the offspring generation\n"
		"    reaches specified allele frequency. At the beginning of each\n"
		"    generation, expected allele frequency of alleles at loci is\n"
		"    returned from a user-defined trajectory function freqFunc.\n"
		"    Parameter loci can be a list of loci indexes, names, or ALL_AVAIL.\n"
		"    If there is no subpopulation, this function should return a list\n"
		"    of frequencies for each locus. If there are multiple\n"
		"    subpopulations, freqFunc can return a list of allele frequencies\n"
		"    for all subpopulations or combined frequencies that ignore\n"
		"    population structure. In the former case, allele frequencies\n"
		"    should be arranged by loc0_sp0, loc1_sp0, ... loc0_sp1, loc1_sp1,\n"
		"    ..., and so on. In the latter case, overall expected number of\n"
		"    alleles are scattered to each subpopulation in proportion to\n"
		"    existing number of alleles in each subpopulation, using a\n"
		"    multinomial distribution.  After the expected alleles are\n"
		"    calculated, this offspring generator accept and reject families\n"
		"    according to their genotype at loci until allele frequecies reach\n"
		"    their expected values. The rest of the offspring generation is\n"
		"    then filled with families without only wild type alleles at these\n"
		"    loci.  This offspring generator is derived from class\n"
		"    OffspringGenerator. Please refer to class OffspringGenerator for a\n"
		"    detailed description of parameters ops, numOffspring and sexMode.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ControlledOffspringGenerator", (PyCFunction)_wrap_delete_ControlledOffspringGenerator, METH_O, NULL},
	 { (char *)"ControlledOffspringGenerator_swigregister", ControlledOffspringGenerator_swigregister, METH_VARARGS, NULL},
	 { (char *)"ControlledOffspringGenerator_swiginit", ControlledOffspringGenerator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ParentChooser", (PyCFunction) _wrap_new_ParentChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ParentChooser(selectionField=\"\")\n"
		"\n"
		"\n"
		""},
	 { (char *)"ParentChooser_clone", (PyCFunction)_wrap_ParentChooser_clone, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"ParentChooser_initialize", (PyCFunction) _wrap_ParentChooser_initialize, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    Initialize a parent chooser for subpopulation subPop of population\n"
		"    pop.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.initialize(pop, subPop)\n"
		"\n"
		"\n"
		""},
	 { (char *)"ParentChooser_describe", (PyCFunction) _wrap_ParentChooser_describe, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"ParentChooser_chooseParents", (PyCFunction)_wrap_ParentChooser_chooseParents, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    Return chosen parents from a population if the parent chooser\n"
		"    object is created with a population.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.chooseParents()\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ParentChooser", (PyCFunction)_wrap_delete_ParentChooser, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~ParentChooser()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ParentChooser_swigregister", ParentChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"ParentChooser_swiginit", ParentChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SequentialParentChooser", (PyCFunction) _wrap_new_SequentialParentChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SequentialParentChooser(sexChoice=ANY_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a parent chooser that chooses a parent from a parental\n"
		"    (virtual) subpopulation sequentially. Parameter choice can be\n"
		"    ANY_SEX (default), MALE_ONLY and FEMALE_ONLY. In the latter two\n"
		"    cases, only male or female individuals are selected. A\n"
		"    RuntimeError will be raised if there is no male or female\n"
		"    individual from the population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SequentialParentChooser", (PyCFunction)_wrap_delete_SequentialParentChooser, METH_O, NULL},
	 { (char *)"SequentialParentChooser_swigregister", SequentialParentChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"SequentialParentChooser_swiginit", SequentialParentChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RandomParentChooser", (PyCFunction) _wrap_new_RandomParentChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RandomParentChooser(replacement=True, selectionField=\"fitness\",\n"
		"      sexChoice=ANY_SEX)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a random parent chooser that choose parents with or without\n"
		"    replacement (parameter replacement, default to True). If selection\n"
		"    is enabled and information field selectionField exists in the\n"
		"    passed population, the probability that a parent is chosen is\n"
		"    proportional to his/her fitness value stored in selectionField.\n"
		"    This parent chooser by default chooses parent from all individuals\n"
		"    (ANY_SEX), but it can be made to select only male (MALE_ONLY) or\n"
		"    female (FEMALE_ONLY) individuals by setting parameter sexChoice.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RandomParentChooser", (PyCFunction)_wrap_delete_RandomParentChooser, METH_O, NULL},
	 { (char *)"RandomParentChooser_swigregister", RandomParentChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"RandomParentChooser_swiginit", RandomParentChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RandomParentsChooser", (PyCFunction) _wrap_new_RandomParentsChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RandomParentsChooser(replacement=True, selectionField=\"fitness\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a random parents chooser that choose two parents with or\n"
		"    without replacement (parameter replacement, default to True). If\n"
		"    selection is enabled and information field selectionField exists\n"
		"    in the passed population, the probability that a parent is chosen\n"
		"    is proportional to his/her fitness value stored in selectionField.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RandomParentsChooser", (PyCFunction)_wrap_delete_RandomParentsChooser, METH_O, NULL},
	 { (char *)"RandomParentsChooser_swigregister", RandomParentsChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"RandomParentsChooser_swiginit", RandomParentsChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PolyParentsChooser", (PyCFunction) _wrap_new_PolyParentsChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PolyParentsChooser(polySex=MALE, polyNum=1,\n"
		"      selectionField=\"fitness\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a multi-spouse parents chooser where each father (if\n"
		"    polySex is MALE) or mother (if polySex is FEMALE) has polyNum\n"
		"    spouses. The parents are chosen with replacement. If individual\n"
		"    fitness values are assigned (stored to information field\n"
		"    selectionField, default to \"fitness\"), the probability that an\n"
		"    individual is chosen is proportional to his/her fitness value\n"
		"    among all individuals with the same sex.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PolyParentsChooser", (PyCFunction)_wrap_delete_PolyParentsChooser, METH_O, NULL},
	 { (char *)"PolyParentsChooser_swigregister", PolyParentsChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"PolyParentsChooser_swiginit", PolyParentsChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_CombinedParentsChooser", (PyCFunction) _wrap_new_CombinedParentsChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    CombinedParentsChooser(fatherChooser, motherChooser,\n"
		"      allowSelfing=True)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Python parent chooser using two parent choosers\n"
		"    fatherChooser and motherChooser. It takes one parent from each\n"
		"    parent chooser and return them as father and mother. If two valid\n"
		"    parents are returned, the first valid parent (father) will be used\n"
		"    for fatherChooser, the second valid parent (mother) will be used\n"
		"    for motherChooser. Although these two parent choosers are supposed\n"
		"    to return a father and a mother respectively, the sex of returned\n"
		"    parents are not checked so it is possible to return parents with\n"
		"    the same sex using this parents chooser. This choose by default\n"
		"    allows the selection of the same parents as father and mother\n"
		"    (self-fertilization), unless a parameter allowSelfing is used to\n"
		"    disable it.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_CombinedParentsChooser", (PyCFunction)_wrap_delete_CombinedParentsChooser, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~CombinedParentsChooser()\n"
		"\n"
		"\n"
		""},
	 { (char *)"CombinedParentsChooser_swigregister", CombinedParentsChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"CombinedParentsChooser_swiginit", CombinedParentsChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyParentsChooser", (PyCFunction) _wrap_new_PyParentsChooser, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyParentsChooser(generator)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Python parent chooser using a Python generator function\n"
		"    parentsGenerator. This function should accept one or both of\n"
		"    parameters pop (the parental population) and subPop (index of\n"
		"    subpopulation) and return the reference or index (relative to\n"
		"    subpopulation) of a parent or a pair of parents repeatedly using\n"
		"    the iterator interface of the generator function.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyParentsChooser", (PyCFunction)_wrap_delete_PyParentsChooser, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyParentsChooser()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyParentsChooser_swigregister", PyParentsChooser_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyParentsChooser_swiginit", PyParentsChooser_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MatingScheme", (PyCFunction) _wrap_new_MatingScheme, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MatingScheme(subPopSize=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a base mating scheme that evolves a population without\n"
		"    transmitting genotypes. At each generation, this mating scheme\n"
		"    creates an offspring generation according to parameter subPopSize,\n"
		"    which can be a list of subpopulation sizes (or a number if there\n"
		"    is only one subpopulation) or a Python function which will be\n"
		"    called at each generation, just before mating, to determine the\n"
		"    subpopulation sizes of the offspring generation. The function\n"
		"    should be defined with one or both parameters of gen and pop where\n"
		"    gen is the current generation number and pop is the parental\n"
		"    population just before mating. The return value of this function\n"
		"    should be a list of subpopulation sizes for the offspring\n"
		"    generation. A single number can be returned if there is only one\n"
		"    subpopulation. The passed parental population is usually used to\n"
		"    determine offspring population size from parental population size\n"
		"    but you can also modify this population to prepare for mating. A\n"
		"    common practice is to split and merge parental populations in this\n"
		"    function so that you demographic related information and actions\n"
		"    could be implemented in the same function.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MatingScheme", (PyCFunction)_wrap_delete_MatingScheme, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MatingScheme()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MatingScheme_clone", (PyCFunction)_wrap_MatingScheme_clone, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"MatingScheme_describe", (PyCFunction) _wrap_MatingScheme_describe, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"MatingScheme_swigregister", MatingScheme_swigregister, METH_VARARGS, NULL},
	 { (char *)"MatingScheme_swiginit", MatingScheme_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_HomoMating", (PyCFunction) _wrap_new_HomoMating, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    HomoMating(chooser, generator, subPopSize=[], subPops=ALL_AVAIL,\n"
		"      weight=0)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a homogeneous mating scheme using a parent chooser chooser\n"
		"    and an offspring generator generator.  If this mating scheme is\n"
		"    used directly in a simulator, it will be responsible for creating\n"
		"    an offspring population according to parameter subPopSize. This\n"
		"    parameter can be a list of subpopulation sizes (or a number if\n"
		"    there is only one subpopulation) or a Python function which will\n"
		"    be called at each generation to determine the subpopulation sizes\n"
		"    of the offspring generation. Please refer to class MatingScheme\n"
		"    for details about this parameter.  If this mating shcme is used\n"
		"    within a heterogeneous mating scheme. Parameters subPops and\n"
		"    weight are used to determine which (virtual) subpopulations this\n"
		"    mating scheme will be applied to, and how many offspring this\n"
		"    mating scheme will produce. Please refer to mating scheme\n"
		"    HeteroMating for the use of these two parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_HomoMating", (PyCFunction)_wrap_delete_HomoMating, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~HomoMating()\n"
		"\n"
		"\n"
		""},
	 { (char *)"HomoMating_swigregister", HomoMating_swigregister, METH_VARARGS, NULL},
	 { (char *)"HomoMating_swiginit", HomoMating_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PedigreeMating", (PyCFunction) _wrap_new_PedigreeMating, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PedigreeMating(ped, ops, idField=\"ind_id\")\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a pedigree mating scheme that evolves a population\n"
		"    according to Pedigree object ped. The evolved population should\n"
		"    contain individuals with ID (at information field idField, default\n"
		"    to 'ind_id') that match those individual in the topmost ancestral\n"
		"    generation who have offspring. After parents of each individuals\n"
		"    are determined from their IDs, a list of during-mating operators\n"
		"    ops are applied to transmit genotypes. The return value of these\n"
		"    operators are not checked.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PedigreeMating", (PyCFunction)_wrap_delete_PedigreeMating, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PedigreeMating()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PedigreeMating_parallelizable", (PyCFunction)_wrap_PedigreeMating_parallelizable, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.parallelizable()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PedigreeMating_swigregister", PedigreeMating_swigregister, METH_VARARGS, NULL},
	 { (char *)"PedigreeMating_swiginit", PedigreeMating_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_HeteroMating", (PyCFunction) _wrap_new_HeteroMating, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    HeteroMating(matingSchemes, subPopSize=[],\n"
		"      shuffleOffspring=True)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a heterogeneous mating scheme that will apply a list of\n"
		"    homogeneous mating schemes matingSchemes to different (virtual)\n"
		"    subpopulations. The size of the offspring generation is determined\n"
		"    by parameter subPopSize, which can be a list of subpopulation\n"
		"    sizes or a Python function that returns a list of subpopulation\n"
		"    sizes at each generation. Please refer to class MatingScheme for a\n"
		"    detailed explanation of this parameter.  Each mating scheme\n"
		"    defined in matingSchemes can be applied to one or more (virtual)\n"
		"    subpopulation. If parameter subPops is not specified, a mating\n"
		"    scheme will be applied to all subpopulations. If a list of\n"
		"    (virtual) subpopulation is specified, the mating scheme will be\n"
		"    applied to specific (virtual) subpopulations.  If multiple mating\n"
		"    schemes are applied to the same subpopulation, a weight (parameter\n"
		"    weight) can be given to each mating scheme to determine how many\n"
		"    offspring it will produce. The default for all mating schemes are\n"
		"    0. In this case, the number of offspring each mating scheme\n"
		"    produces is proportional to the size of its parental (virtual)\n"
		"    subpopulation. If all weights are negative, the numbers of\n"
		"    offspring are determined by the multiplication of the absolute\n"
		"    values of the weights and their respective parental (virtual)\n"
		"    subpopulation sizes. If all weights are positive, the number of\n"
		"    offspring produced by each mating scheme is proportional to these\n"
		"    weights. Mating schemes with zero weight in this case will produce\n"
		"    no offspring. If both negative and positive weights are present,\n"
		"    negative weights are processed before positive ones.  If multiple\n"
		"    mating schemes are applied to the same subpopulation, offspring\n"
		"    produced by these mating schemes are shuffled randomly. If this is\n"
		"    not desired, you can turn off offspring shuffling by setting\n"
		"    parameter shuffleOffspring to False.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_HeteroMating", (PyCFunction)_wrap_delete_HeteroMating, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~HeteroMating()\n"
		"\n"
		"\n"
		""},
	 { (char *)"HeteroMating_swigregister", HeteroMating_swigregister, METH_VARARGS, NULL},
	 { (char *)"HeteroMating_swiginit", HeteroMating_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ConditionalMating", (PyCFunction) _wrap_new_ConditionalMating, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ConditionalMating(cond, ifMatingScheme, elseMatingScheme)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a conditional mating scheme that applies mating scheme\n"
		"    ifMatingScheme if the condition cond is True, or elseMatingScheme\n"
		"    if cond is False. If a Python expression (a string) is given to\n"
		"    parameter cond, the expression will be evalulated in parental\n"
		"    population's local namespace. When a Python function is specified,\n"
		"    it accepts parameter pop for the parental population. The return\n"
		"    value of this function should be True or False. Otherwise,\n"
		"    parameter cond will be treated as a fixed condition (converted to\n"
		"    True or False) upon which ifMatingScheme or elseMatingScheme will\n"
		"    alway be applied.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ConditionalMating", (PyCFunction)_wrap_delete_ConditionalMating, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~ConditionalMating()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ConditionalMating_swigregister", ConditionalMating_swigregister, METH_VARARGS, NULL},
	 { (char *)"ConditionalMating_swiginit", ConditionalMating_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_pyPopIterator", (PyCFunction) _wrap_new_pyPopIterator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    pyPopIterator(begin, end)\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_pyPopIterator", (PyCFunction)_wrap_delete_pyPopIterator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~pyPopIterator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyPopIterator___iter__", (PyCFunction)_wrap_pyPopIterator___iter__, METH_O, NULL},
	 { (char *)"pyPopIterator_next", (PyCFunction)_wrap_pyPopIterator_next, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.__next__()\n"
		"\n"
		"\n"
		""},
	 { (char *)"pyPopIterator___next__", (PyCFunction)_wrap_pyPopIterator___next__, METH_O, NULL},
	 { (char *)"pyPopIterator_swigregister", pyPopIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"pyPopIterator_swiginit", pyPopIterator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Simulator", (PyCFunction) _wrap_new_Simulator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Simulator(pops, rep=1, stealPops=True)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a simulator with rep (default to 1) replicates of\n"
		"    populations pops, which is a list of populations although a single\n"
		"    population object is also acceptable. Contents of passed\n"
		"    populations are by default moved to the simulator to avoid\n"
		"    duplication of potentially large population objects, leaving empty\n"
		"    populations behind. This behavior can be changed by setting\n"
		"    stealPops to False, in which case populations are copied to the\n"
		"    simulator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Simulator", (PyCFunction)_wrap_delete_Simulator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Simulator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_clone", (PyCFunction)_wrap_Simulator_clone, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clone()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Clone a simulator, along with all its populations. Note that\n"
		"    Python assign statement simu1 = simu only creates a symbolic link\n"
		"    to an existing simulator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_numRep", (PyCFunction)_wrap_Simulator_numRep, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.numRep()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the number of replicates.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_population", (PyCFunction) _wrap_Simulator_population, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.population(rep)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a reference to the rep-th population of a simulator. The\n"
		"    reference will become invalid once the simulator starts evolving\n"
		"    or becomes invalid (removed). If an independent copy of the\n"
		"    population is needed, you can use population.clone() to create a\n"
		"    cloned copy or simulator.extract() to remove the population from\n"
		"    the simulator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_add", (PyCFunction) _wrap_Simulator_add, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.add(pop, stealPop=True)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Add a population pop to the end of an existing simulator. This\n"
		"    function by default moves pop to the simulator, leaving an empty\n"
		"    population for passed population object. If steal is set to False,\n"
		"    the population will be copied to the simulator, and thus\n"
		"    unchanged.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_extract", (PyCFunction) _wrap_Simulator_extract, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.extract(rep)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Extract the rep-th population from a simulator. This will reduce\n"
		"    the number of populations in this simulator by one.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_populations", (PyCFunction)_wrap_Simulator_populations, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.populations()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a Python iterator that can be used to iterate through all\n"
		"    populations in a simulator.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_evolve", (PyCFunction) _wrap_Simulator_evolve, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.evolve(initOps=[], preOps=[], matingScheme=MatingScheme,\n"
		"      postOps=[], finalOps=[], gen=-1, dryrun=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Evolve all populations gen generations, subject to several lists\n"
		"    of operators which are applied at different stages of an\n"
		"    evolutionary process. Operators initOps are applied to all\n"
		"    populations (subject to applicability restrictions of the\n"
		"    operators, imposed by the rep parameter of these operators) before\n"
		"    evolution. They are used to initialize populations before\n"
		"    evolution. Operators finalOps are applied to all populations after\n"
		"    the evolution.  Operators preOps, and postOps are applied during\n"
		"    the life cycle of each generation. These operators can be applied\n"
		"    at all or some of the generations, to all or some of the evolving\n"
		"    populations, depending the begin, end, step, at and reps\n"
		"    parameters of these operators. These operators are applied in the\n"
		"    order at which they are specified. populations in a simulator are\n"
		"    evolved one by one. At each generation, operators preOps are\n"
		"    applied to the parental generations. A mating scheme is then used\n"
		"    to populate an offspring generation. For each offspring, his or\n"
		"    her sex is determined before during-mating operators of the mating\n"
		"    scheme are used to transmit parental genotypes. After an offspring\n"
		"    generation is successfully generated and becomes the current\n"
		"    generation, operators postOps are applied to the offspring\n"
		"    generation. If any of the preOps and postOps fails (return False),\n"
		"    the evolution of a population will be stopped. The generation\n"
		"    number of a population, which is the variable \"gen\" in each\n"
		"    populations local namespace, is increased by one if an offspring\n"
		"    generation has been successfully populated even if a post-mating\n"
		"    operator fails. Another variable \"rep\" will also be set to\n"
		"    indicate the index of each population in the simulator. Note that\n"
		"    populations in a simulator does not have to have the same\n"
		"    generation number. You could reset a population's generation\n"
		"    number by changing this variable.  Parameter gen can be set to a\n"
		"    non-negative number, which is the number of generations to evolve.\n"
		"    If a simulator starts at the beginning of a generation g (for\n"
		"    example 0), a simulator will stop at the beginning (instead of the\n"
		"    end) of generation g + gen (for example gen). If gen is negative\n"
		"    (default), the evolution will continue indefinitely, until all\n"
		"    replicates are stopped by operators that return False at some\n"
		"    point (these operators are called terminators). At the end of the\n"
		"    evolution, the generations that each replicates have evolved are\n"
		"    returned. Note that finalOps are applied to all applicable\n"
		"    population, including those that have stopped before others.  If\n"
		"    parameter dryrun is set to True, this function will print a\n"
		"    description of the evolutionary process generated by function\n"
		"    describeEvolProcess() and exits.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator_vars", (PyCFunction) _wrap_Simulator_vars, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.vars(rep, subPop=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return the local namespace of the rep-th population, equivalent to\n"
		"    x.Population(rep).vars(subPop).\n"
		"\n"
		"\n"
		""},
	 { (char *)"Simulator___cmp__", (PyCFunction) _wrap_Simulator___cmp__, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"Simulator_swigregister", Simulator_swigregister, METH_VARARGS, NULL},
	 { (char *)"Simulator_swiginit", Simulator_swiginit, METH_VARARGS, NULL},
	 { (char *)"describeEvolProcess", (PyCFunction) _wrap_describeEvolProcess, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    describeEvolProcess(initOps=[], preOps=[],\n"
		"      matingScheme=MatingScheme, postOps=[], finalOps=[], gen=-1,\n"
		"      numRep=1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function takes the same parameters as Simulator.evolve and\n"
		"    output a description of how an evolutionary process will be\n"
		"    executed. It is recommended that you call this function if you\n"
		"    have any doubt how your simulation will proceed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_PyEval", (PyCFunction) _wrap_new_PyEval, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyEval(expr=\"\", stmts=\"\", exposePop=\"\", output=\">\", begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=Py_False,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a PyEval operator that evaluates a Python expression expr\n"
		"    in a population's local namespaces when it is applied to this\n"
		"    population. This namespace can either be the population's local\n"
		"    namespace (pop.vars()), or namespaces subPop[sp] for (virtual)\n"
		"    subpop (pop.vars(subpop)) in specified subPops. If Python\n"
		"    statements stmts is given (a single or multi-line string), the\n"
		"    statement will be executed before expr. If exposePop is set to an\n"
		"    non-empty string, the current population will be exposed in its\n"
		"    own local namespace as a variable with this name. This allows the\n"
		"    execution of expressions such as 'pop.individual(0).allele(0)'.\n"
		"    The result of expr will be sent to an output stream specified by\n"
		"    parameter output. The exposed population variable will be removed\n"
		"    after expr is evaluated. Please refer to class BaseOperator for\n"
		"    other parameters.\n"
		"\n"
		"Note:\n"
		"\n"
		"    Although the statements and expressions are evaluated in a\n"
		"    population's local namespace, they have access to a global\n"
		"    namespace which is the module global namespace. It is therefore\n"
		"    possible to refer to any module variable in these expressions.\n"
		"    Such mixed use of local and global variables is, however, strongly\n"
		"    discouraged.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyEval", (PyCFunction)_wrap_delete_PyEval, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyEval()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyEval_evaluate", (PyCFunction) _wrap_PyEval_evaluate, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"PyEval_swigregister", PyEval_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyEval_swiginit", PyEval_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyExec", (PyCFunction) _wrap_new_PyExec, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyExec(stmts=\"\", exposePop=\"\", output=\">\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=Py_False, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a PyExec operator that executes statements stmts in a\n"
		"    population's local namespace when it is applied to this\n"
		"    population. This namespace can either be the population's local\n"
		"    namespace (pop.vars()), or namespaces subPop[sp] for each\n"
		"    (virtual) subpop (pop.vars(subpop)) in specified subPops. If\n"
		"    exposePop is given, current population will be exposed in its\n"
		"    local namespace as a variable named by exposePop. Although\n"
		"    multiple statements can be executed, it is recommended that you\n"
		"    use this operator to execute short statements and use PyOperator\n"
		"    for more complex once. Note that exposed population variables will\n"
		"    be removed after the statements are executed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyExec", (PyCFunction)_wrap_delete_PyExec, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyExec()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyExec_swigregister", PyExec_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyExec_swiginit", PyExec_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InfoEval", (PyCFunction) _wrap_new_InfoEval, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InfoEval(expr=\"\", stmts=\"\", usePopVars=False, exposeInd=\"\",\n"
		"      output=\">\", begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that evaluate a Python expression expr using\n"
		"    individual information fields and population variables as\n"
		"    variables. If exposeInd is not empty, the individual itself will\n"
		"    be exposed in the population's local namespace as a variable with\n"
		"    name specified by exposeInd.  A Python expression (expr) is\n"
		"    evaluated for each individual. The results are converted to\n"
		"    strings and are written to an output specified by parameter\n"
		"    output. Optionally, a statement (or several statements separated\n"
		"    by newline) can be executed before expr is evaluated. The\n"
		"    evaluation of this statement may change the value of information\n"
		"    fields.  Parameter usePopVars is obsolete because population\n"
		"    variables are always usable in such expressions.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InfoEval", (PyCFunction)_wrap_delete_InfoEval, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InfoEval()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InfoEval_swigregister", InfoEval_swigregister, METH_VARARGS, NULL},
	 { (char *)"InfoEval_swiginit", InfoEval_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InfoExec", (PyCFunction) _wrap_new_InfoExec, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InfoExec(stmts=\"\", usePopVars=False, exposeInd=\"\", output=\"\",\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that executes Python statements stmts using\n"
		"    individual information fields and population variables as\n"
		"    variables. If exposeInd is not empty, the individual itself will\n"
		"    be exposed in the population's local namespace as a variable with\n"
		"    name specified by exposeInd.  One or more python statements\n"
		"    (stmts) are executed for each individual. Information fields of\n"
		"    these individuals are then updated from the corresponding\n"
		"    variables. For example, a=1 will set information field a of all\n"
		"    individuals to 1, a=b will set information field a of all\n"
		"    individuals to information field b or a population variable b if b\n"
		"    is not an information field but a population variable, and\n"
		"    a=ind.sex() will set information field a of all individuals to its\n"
		"    sex (needs exposeInd='ind'.  Parameter usePopVars is obsolete\n"
		"    because population variables will always be usable.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InfoExec", (PyCFunction)_wrap_delete_InfoExec, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InfoExec()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InfoExec_swigregister", InfoExec_swigregister, METH_VARARGS, NULL},
	 { (char *)"InfoExec_swiginit", InfoExec_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Stat", (PyCFunction) _wrap_new_Stat, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Stat(popSize=False, numOfMales=False, numOfAffected=False,\n"
		"      numOfSegSites=[], numOfMutants=[], alleleFreq=[], heteroFreq=[],\n"
		"      homoFreq=[], genoFreq=[], haploFreq=[], haploHeteroFreq=[],\n"
		"      haploHomoFreq=[], sumOfInfo=[], meanOfInfo=[], varOfInfo=[],\n"
		"      maxOfInfo=[], minOfInfo=[], LD=[], association=[],\n"
		"      neutrality=[], structure=[], HWE=[], inbreeding=[],\n"
		"      effectiveSize=[], vars=ALL_AVAIL, suffix=\"\", output=\"\", begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Stat operator that calculates specified statistics of a\n"
		"    population when it is applied to this population. This operator\n"
		"    can be applied to specified replicates (parameter rep) at\n"
		"    specified generations (parameter begin, end, step, and at). This\n"
		"    operator does not produce any output (ignore parameter output)\n"
		"    after statistics are calculated. Instead, it stores results in the\n"
		"    local namespace of the population being applied. Other operators\n"
		"    can retrieve these variables or evalulate expression directly in\n"
		"    this local namespace. Please refer to operator BaseOperator for a\n"
		"    detailed explanation of these common operator parameters.   Stat\n"
		"    supports parameter subPops. It usually calculate the same set of\n"
		"    statistics for all subpopulations (subPops=subPopList()). If a\n"
		"    list of (virtual) subpopulations are specified, statistics for\n"
		"    only specified subpopulations will be calculated. However,\n"
		"    different statistics treat this parameter differently and it is\n"
		"    very important to check its reference before you use subPops for\n"
		"    any statistics.  Calculated statistics are saved as variables in a\n"
		"    population's local namespace. These variables can be numbers,\n"
		"    lists or dictionaries and can be retrieved using functions\n"
		"    Population.vars() or Population.dvars(). A special default\n"
		"    dictionary (defdict) is used for dictionaries whose keys are\n"
		"    determined dynamically. Accessing elements of such a dictionary\n"
		"    with an invalid key will yield value 0 instead of a KeyError. If\n"
		"    the same variables are calculated for one or more (virtual)\n"
		"    subpopulation, the variables are stored in\n"
		"    vars()['subPop'][sp]['var'] where sp is a subpopulation ID (sp) or\n"
		"    a tuple of virtual subpopulation ID ((sp, vsp)).\n"
		"    Population.vars(sp) and Population.dvars(sp) provide shortcuts to\n"
		"    these variables.  Operator Stat outputs a number of most useful\n"
		"    variables for each type of statistic. For example, alleleFreq\n"
		"    calculates both allele counts and allele frequencies and it by\n"
		"    default sets variable alleleFreq (dvars().alleleFreq) for all or\n"
		"    specified subpopulations. If this does not fit your need, you can\n"
		"    use parameter vars to output additional parameters, or limit the\n"
		"    output of existing parameters. More specifically, for this\n"
		"    particular statistic, the available variables are 'alleleFreq',\n"
		"    'alleleNum', 'alleleFreq_sp' ('alleleFreq' in each subpopulation),\n"
		"    and 'alleleNum_sp' ('alleleNum' in each subpopulation). You can\n"
		"    set vars=['alleleNum_sp'] to output only subpopulation specific\n"
		"    allele count. An optional suffix (parameter suffix) can be used to\n"
		"    append a suffix to default parameter names. This parameter can be\n"
		"    used, for example, to calculate and store the same statistics for\n"
		"    different subpopulations (e.g. pairwise Fst).  Operator Stat\n"
		"    supports the following statistics:  popSize: If popSize=True,\n"
		"    number of individuals in all or specified subpopulations\n"
		"    (parameter subPops) will be set to the following variables:\n"
		"    *   popSize (default): Number of individuals in all or specified\n"
		"    subpopulations. Because subPops does not have to cover all\n"
		"    individuals, it may not be the actual population size.\n"
		"    *   popSize_sp: Size of (virtual) subpopulation sp.\n"
		"    *   subPopSize (default): A list of (virtual) subpopulation sizes.\n"
		"    This variable is easier to use than accessing popSize from each\n"
		"    (virtual) subpopulation.numOfMales: If numOfMales=True, number of\n"
		"    male individuals in all or specified (virtual) subpopulations will\n"
		"    be set to the following variables:\n"
		"    *   numOfMales (default): Total number of male individuals in all\n"
		"    or specified (virtual) subpopulations.\n"
		"    *   numOfFemales (default): Total number of female individuals in\n"
		"    all or specified (virtual) subpopulations.\n"
		"    *   propOfMales: Proportion of male individuals.\n"
		"    *   propOfFemales: Proportion of female individuals.\n"
		"    *   numOfMales_sp: Number of male individuals in each (virtual)\n"
		"    subpopulation.\n"
		"    *   numOfFemales_sp: Number of female individuals in each\n"
		"    (virtual) subpopulation.\n"
		"    *   propOfMales_sp: Proportion of male individuals in each\n"
		"    (virtual) subpopulation.\n"
		"    *   propOfFemales_sp: Proportion of female individuals in each\n"
		"    (virtual) subpopulation.numOfAffected: If numOfAffected=True,\n"
		"    number of affected individuals in all or specified (virtual)\n"
		"    subpopulations will be set to the following variables:\n"
		"    *   numOfAffected (default): Total number of affected individuals\n"
		"    in all or specified (virtual) subpopulations.\n"
		"    *   numOfUnaffected (default): Total number of unaffected\n"
		"    individuals in all or specified (virtual) subpopulations.\n"
		"    *   propOfAffected: Proportion of affected individuals.\n"
		"    *   propOfUnaffected: Proportion of unaffected individuals.\n"
		"    *   numOfAffected_sp: Number of affected individuals in each\n"
		"    (virtual) subpopulation.\n"
		"    *   numOfUnaffected_sp: Number of unaffected individuals in each\n"
		"    (virtual) subpopulation.\n"
		"    *   propOfAffected_sp: Proportion of affected individuals in each\n"
		"    (virtual) subpopulation.\n"
		"    *   propOfUnaffected_sp: Proportion of unaffected individuals in\n"
		"    each (virtual) subpopulation.numOfSegSites: Parameter\n"
		"    numOfSegSites accepts a list of loci (loci indexes, names, or\n"
		"    ALL_AVAIL) and count the number of loci with at least two\n"
		"    different alleles (segregating sites) or loci with only one non-\n"
		"    zero allele (no zero allele, not segragating) for individuals in\n"
		"    all or specified (virtual) subpopulations. This parameter sets\n"
		"    variables\n"
		"    *   numOfSegSites (default): Number of segregating sites in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   numOfSegSites_sp: Number of segregating sites in each\n"
		"    (virtual) subpopulation.\n"
		"    *   numOfFixedSites: Number of sites with one non-zero allele in\n"
		"    all or specified (virtual) subpopulations.\n"
		"    *   numOfFixedSites_sp: Number of sites with one non-zero allele\n"
		"    in in each (virtual) subpopulations.\n"
		"    *   segSites: A list of segregating sites in all or specified\n"
		"    (virtual) subpopulations.\n"
		"    *   segSites_sp: A list of segregating sites in each (virtual)\n"
		"    subpopulation.\n"
		"    *   fixedSites: A list of sites with one non-zero allele in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   fixedSites_sp: A list of sites with one non-zero allele in in\n"
		"    each (virtual) subpopulations.numOfMutants: Parameter numOfMutants\n"
		"    accepts a list of loci (loci indexes, names, or ALL_AVAIL) and\n"
		"    count the number of mutants (non-zero alleles) for individuals in\n"
		"    all or specified (virtual) subpopulations. It sets variables\n"
		"    *   numOfMutants (default): Number of mutants in all or specified\n"
		"    (virtual) subpopulations.\n"
		"    *   numOfMutants_sp: Number of mutants in each (virtual)\n"
		"    subpopulations.alleleFreq: This parameter accepts a list of loci\n"
		"    (loci indexes, names, or ALL_AVAIL), at which allele frequencies\n"
		"    will be calculated. This statistic outputs the following\n"
		"    variables, all of which are dictionary (with loci indexes as keys)\n"
		"    of default dictionaries (with alleles as keys). For example,\n"
		"    alleleFreq[loc][a] returns 0 if allele a does not exist.\n"
		"    *   alleleFreq (default): alleleFreq[loc][a] is the frequency of\n"
		"    allele a at locus for all or specified (virtual) subpopulations.\n"
		"    *   alleleNum (default): alleleNum[loc][a] is the number of allele\n"
		"    a at locus for all or specified (virtual) subpopulations.\n"
		"    *   alleleFreq_sp: Allele frequency in each (virtual)\n"
		"    subpopulation.\n"
		"    *   alleleNum_sp: Allele count in each (virtual)\n"
		"    subpopulation.heteroFreq and homoFreq: These parameters accept a\n"
		"    list of loci (by indexes or names), at which the number and\n"
		"    frequency of homozygotes and/or heterozygotes will be calculated.\n"
		"    These statistics are only available for diploid populations. The\n"
		"    following variables will be outputted:\n"
		"    *   heteroFreq (default for parameter heteroFreq): A dictionary of\n"
		"    proportion of heterozygotes in all or specified (virtual)\n"
		"    subpopulations, with loci indexes as dictionary keys.\n"
		"    *   homoFreq (default for parameter homoFreq): A dictionary of\n"
		"    proportion of homozygotes in all or specified (virtual)\n"
		"    subpopulations.\n"
		"    *   heteroNum: A dictionary of number of heterozygotes in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   homoNum: A dictionary of number of homozygotes in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   heteroFreq_sp: A dictionary of proportion of heterozygotes in\n"
		"    each (virtual) subpopulation.\n"
		"    *   homoFreq_sp: A dictionary of proportion of homozygotes in each\n"
		"    (virtual) subpopulation.\n"
		"    *   heteroNum_sp: A dictionary of number of heterozygotes in each\n"
		"    (virtual) subpopulation.\n"
		"    *   homoNum_sp: A dictionary of number of homozygotes in each\n"
		"    (virtual) subpopulation.genoFreq: This parameter accept a list of\n"
		"    loci (by indexes or names) at which number and frequency of all\n"
		"    genotypes are outputed as a dictionary (indexed by loci indexes)\n"
		"    of default dictionaries (indexed by tuples of possible indexes).\n"
		"    This statistic is available for all population types with genotype\n"
		"    defined as ordered alleles at a locus. The length of genotype\n"
		"    equals the number of homologous copies of chromosomes (ploidy) of\n"
		"    a population. Genotypes for males or females on sex chromosomes or\n"
		"    in haplodiploid populations will have different length. Because\n"
		"    genotypes are ordered, (1, 0) and (0, 1) (two possible genotypes\n"
		"    in a diploid population) are considered as different genotypes.\n"
		"    This statistic outputs the following variables:\n"
		"    *   genoFreq (default): A dictionary (by loci indexes) of default\n"
		"    dictionaries (by genotype) of genotype frequencies. For example,\n"
		"    genoFreq[1][(1, 0)] is the frequency of genotype (1, 0) at locus\n"
		"    1.\n"
		"    *   genoNum (default): A dictionary of default dictionaries of\n"
		"    genotype counts of all or specified (virtual) subpopulations.\n"
		"    *   genoFreq_sp: genotype frequency in each specified (virtual)\n"
		"    subpopulation.\n"
		"    *   genoFreq_sp: genotype count in each specified (virtual)\n"
		"    subpopulation.haploFreq: This parameter accepts one or more lists\n"
		"    of loci (by index) at which number and frequency of haplotypes are\n"
		"    outputted as default dictionaries. [(1,2)] can be abbreviated to\n"
		"    (1,2). For example, using parameter haploFreq=(1,2,4), all\n"
		"    haplotypes at loci 1, 2 and 4 are counted. This statistic saves\n"
		"    results to dictionary (with loci index as keys) of default\n"
		"    dictionaries (with haplotypes as keys) such as\n"
		"    haploFreq[(1,2,4)][(1,1,0)] (frequency of haplotype (1,1,0) at\n"
		"    loci (1,2,3)). This statistic works for all population types.\n"
		"    Number of haplotypes for each individual equals to his/her ploidy\n"
		"    number. Haplodiploid populations are supported in the sense that\n"
		"    the second homologous copy of the haplotype is not counted for\n"
		"    male individuals. This statistic outputs the following variables:\n"
		"    *   haploFreq (default): A dictionary (with tuples of loci indexes\n"
		"    as keys) of default dictionaries of haplotype frequencies. For\n"
		"    example, haploFreq[(0, 1)][(1,1)] records the frequency of\n"
		"    haplotype (1,1) at loci (0, 1) in all or specified (virtual)\n"
		"    subpopulations.\n"
		"    *   haploNum (default): A dictionary of default dictionaries of\n"
		"    haplotype counts in all or specified (virtual) subpopulations.\n"
		"    *   haploFreq_sp: Halptype frequencies in each (virtual)\n"
		"    subpopulation.\n"
		"    *   haploNum_sp: Halptype count in each (virtual)\n"
		"    subpopulation.haploHeteroFreq and haploHomoFreq: These parameters\n"
		"    accept a list of haplotypes (list of loci), at which the number\n"
		"    and frequency of haplotype homozygotes and/or heterozygotes will\n"
		"    be calculated. Note that these statistics are observed count of\n"
		"    haplotype heterozygote. The following variables will be outputted:\n"
		"    *   haploHeteroFreq (default for parameter haploHeteroFreq): A\n"
		"    dictionary of proportion of haplotype heterozygotes in all or\n"
		"    specified (virtual) subpopulations, with haplotype indexes as\n"
		"    dictionary keys.\n"
		"    *   haploHomoFreq (default for parameter haploHomoFreq): A\n"
		"    dictionary of proportion of homozygotes in all or specified\n"
		"    (virtual) subpopulations.\n"
		"    *   haploHeteroNum: A dictionary of number of heterozygotes in all\n"
		"    or specified (virtual) subpopulations.\n"
		"    *   haploHomoNum: A dictionary of number of homozygotes in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   haploHeteroFreq_sp: A dictionary of proportion of\n"
		"    heterozygotes in each (virtual) subpopulation.\n"
		"    *   haploHomoFreq_sp: A dictionary of proportion of homozygotes in\n"
		"    each (virtual) subpopulation.\n"
		"    *   haploHeteroNum_sp: A dictionary of number of heterozygotes in\n"
		"    each (virtual) subpopulation.\n"
		"    *   haploHomoNum_sp: A dictionary of number of homozygotes in each\n"
		"    (virtual) subpopulation.sumOfinfo, meanOfInfo, varOfInfo,\n"
		"    maxOfInfo and minOfInfo: Each of these five parameters accepts a\n"
		"    list of information fields. For each information field, the sum,\n"
		"    mean, variance, maximum or minimal (depending on the specified\n"
		"    parameter(s)) of this information field at iddividuals in all or\n"
		"    specified (virtual) subpopulations will be calculated. The results\n"
		"    will be put into the following population variables:\n"
		"    *   sumOfInfo (default for sumOfInfo): A dictionary of the sum of\n"
		"    specified information fields of individuals in all or specified\n"
		"    (virtual) subpopulations. This dictionary is indexed by names of\n"
		"    information fields.\n"
		"    *   meanOfInfo (default for meanOfInfo): A dictionary of the mean\n"
		"    of information fields of all individuals.\n"
		"    *   varOfInfo (default for varOfInfo): A dictionary of the sample\n"
		"    variance of information fields of all individuals.\n"
		"    *   maxOfInfo (default for maxOfInfo): A dictionary of the maximum\n"
		"    value of information fields of all individuals.\n"
		"    *   minOfInfo (default for minOfInfo): A dictionary of the minimal\n"
		"    value of information fields of all individuals.\n"
		"    *   sumOfInfo_sp: A dictionary of the sum of information fields of\n"
		"    individuals in each subpopulation.\n"
		"    *   meanOfInfo_sp: A dictionary of the mean of information fields\n"
		"    of individuals in each subpopulation.\n"
		"    *   varOfInfo_sp: A dictionary of the sample variance of\n"
		"    information fields of individuals in each subpopulation.\n"
		"    *   maxOfInfo_sp: A dictionary of the maximum value of information\n"
		"    fields of individuals in each subpopulation.\n"
		"    *   minOfInfo_sp: A dictionary of the minimal value of information\n"
		"    fields of individuals in each subpopulation.LD: Parameter LD\n"
		"    accepts one or a list of loci pairs (e.g. LD=[[0,1], [2,3]]) with\n"
		"    optional primary alleles at both loci (e.g. LD=[0,1,0,0]). For\n"
		"    each pair of loci, this operator calculates linkage disequilibrium\n"
		"    and optional association statistics between two loci. When primary\n"
		"    alleles are specified, signed linkage disequilibrium values are\n"
		"    calculated with non-primary alleles are combined. Otherwise,\n"
		"    absolute values of diallelic measures are combined to yield\n"
		"    positive measure of LD. Association measures are calculated from a\n"
		"    m by n contigency of haplotype counts (m=n=2 if primary alleles\n"
		"    are specified). Please refer to the simuPOP user's guide for\n"
		"    detailed information. This statistic sets the following variables:\n"
		"    *   LD (default) Basic LD measure for haplotypes in all or\n"
		"    specified (virtual) subpopulations. Signed if primary alleles are\n"
		"    specified.\n"
		"    *   LD_prime (default) Lewontin's D' measure for haplotypes in all\n"
		"    or specified (virtual) subpopulations. Signed if primary alleles\n"
		"    are specified.\n"
		"    *   R2 (default) Correlation LD measure for haplotypes in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   LD_ChiSq ChiSq statistics for a contigency table with\n"
		"    frequencies of haplotypes in all or specified (virtual)\n"
		"    subpopulations.\n"
		"    *   LD_ChiSq_p Single side p-value for the ChiSq statistic.\n"
		"    Degrees of freedom is determined by number of alleles at both loci\n"
		"    and the specification of primary alleles.\n"
		"    *   CramerV Normalized ChiSq statistics.\n"
		"    *   LD_sp Basic LD measure for haplotypes in each (virtual)\n"
		"    subpopulation.\n"
		"    *   LD_prime_sp Lewontin's D' measure for haplotypes in each\n"
		"    (virtual) subpopulation.\n"
		"    *   R2_sp R2 measure for haplotypes in each (virtual)\n"
		"    subpopulation.\n"
		"    *   LD_ChiSq_sp ChiSq statistics for each (virtual) subpopulation.\n"
		"    *   LD_ChiSq_p_sp p value for the ChiSq statistics for each\n"
		"    (virtual) subpopulation.\n"
		"    *   CramerV_sp Cramer V statistics for each (virtual)\n"
		"    subpopulation.association: Parameter association accepts a list of\n"
		"    loci, which can be a list of indexes, names, or ALL_AVAIL. At each\n"
		"    locus, one or more statistical tests will be performed to test\n"
		"    association between this locus and individual affection status.\n"
		"    Currently, simuPOP provides the following tests:\n"
		"    *   An allele-based Chi-square test using alleles counts. This\n"
		"    test can be applied to loci with more than two alleles, and to\n"
		"    haploid populations.\n"
		"    *   A genotype-based Chi-square test using genotype counts. This\n"
		"    test can be applied to loci with more than two alleles (more than\n"
		"    3 genotypes) in diploid populations. aA and Aa are considered to\n"
		"    be the same genotype.\n"
		"    *   A genotype-based Cochran-Armitage trend test. This test can\n"
		"    only be applied to diallelic loci in diploid populations. A\n"
		"    codominant model is assumed. This statistic sets the following\n"
		"    variables:\n"
		"    *   Allele_ChiSq A dictionary of allele-based Chi-Square\n"
		"    statistics for each locus, using cases and controls in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   Allele_ChiSq_p (default) A dictionary of p-values of the\n"
		"    corresponding Chi-square statistics.\n"
		"    *   Geno_ChiSq A dictionary of genotype-based Chi-Square\n"
		"    statistics for each locus, using cases and controls in all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   Geno_ChiSq_p A dictionary of p-values of the corresponding\n"
		"    genotype-based Chi-square test.\n"
		"    *   Armitage_p A dictionary of p-values of the Cochran-Armitage\n"
		"    tests, using cases and controls in all or specified (virtual)\n"
		"    subpopulations.\n"
		"    *   Allele_ChiSq_sp A dictionary of allele-based Chi-Square\n"
		"    statistics for each locus, using cases and controls from each\n"
		"    subpopulation.\n"
		"    *   Allele_ChiSq_p_sp A dictionary of p-values of allele-based\n"
		"    Chi-square tests, using cases and controls from each (virtual)\n"
		"    subpopulation.\n"
		"    *   Geno_ChiSq_sp A dictionary of genotype-based Chi-Square tests\n"
		"    for each locus, using cases and controls from each subpopulation.\n"
		"    *   Geno_ChiSq_p_sp A dictionary of p-values of genotype-based\n"
		"    Chi-Square tests, using cases and controls from each\n"
		"    subpopulation.\n"
		"    *   Armitage_p_sp A dictionary of p-values of the Cochran-\n"
		"    Armitage tests, using cases and controls from each\n"
		"    subpopulation.neutrality: This parameter performs neutrality tests\n"
		"    (detection of natural selection) on specified loci, which can be a\n"
		"    list of loci indexes, names or ALL_AVAIL. It currently only\n"
		"    outputs Pi, which is the average number of pairwise difference\n"
		"    between loci. This statistic outputs the following variables:\n"
		"    *   Pi Mean pairwise difference between all sequences from all or\n"
		"    specified (virtual) subpopulations.\n"
		"    *   Pi_sp Mean paiewise difference between all sequences in each\n"
		"    (virtual) subpopulation.structure: Parameter structure accepts a\n"
		"    list of loci at which statistics that measure population structure\n"
		"    are calculated. structure accepts a list of loci indexes, names or\n"
		"    ALL_AVAIL. This parameter currently supports the following\n"
		"    statistics:\n"
		"    *   Weir and Cockerham's Fst (1984). This is the most widely used\n"
		"    estimator of Wright's fixation index and can be used to measure\n"
		"    Population differentiation. However, this method is designed to\n"
		"    estimate Fst from samples of larger populations and might not be\n"
		"    appropriate for the calculation of Fst of large populations.\n"
		"    *   Nei's Gst (1973). The Gst estimator is another estimator for\n"
		"    Wright's fixation index but it is extended for multi-allele (more\n"
		"    than two alleles) and multi-loci cases. This statistics should be\n"
		"    used if you would like to obtain a true Fst value of a large\n"
		"    Population. Nei's Gst uses only allele frequency information so it\n"
		"    is available for all population type (haploid, diploid etc). Weir\n"
		"    and Cockerham's Fst uses heterozygosity frequency so it is best\n"
		"    for autosome of diploid populations. For non-diploid population,\n"
		"    sex, and mitochondrial DNAs, simuPOP uses expected heterozygosity\n"
		"    (1 - sum p_i^2) when heterozygosity is needed. These statistics\n"
		"    output the following variables:\n"
		"    *   F_st (default) The WC84 Fst statistic estimated for all *\n"
		"    specified loci.\n"
		"    *   F_is The WC84 Fis statistic estimated for all specified loci.\n"
		"    *   F_it The WC84 Fit statistic estimated for all specified loci.\n"
		"    *   f_st A dictionary of locus level WC84 Fst values.\n"
		"    *   f_is A dictionary of locus level WC84 Fis values.\n"
		"    *   f_it A dictionary of locus level WC84 Fit values.\n"
		"    *   G_st Nei's Gst statistic estimated for all specified loci.\n"
		"    *   g_st A dictionary of Nei's Gst statistic estimated for each\n"
		"    locus.HWE: Parameter HWE accepts a list of loci at which exact\n"
		"    two-side tests for Hardy-Weinberg equilibrium will be performed.\n"
		"    This statistic is only available for diallelic loci in diploid\n"
		"    populations. HWE can be a list of loci indexes, names or\n"
		"    ALL_AVAIL. This statistic outputs the following variables:\n"
		"    *   HWE (default) A dictionary of p-values of HWE tests using\n"
		"    genotypes in all or specified (virtual) subpopulations.\n"
		"    *   HWE_sp A dictionary of p-values of HWS tests using genotypes\n"
		"    in each (virtual) subpopulation.inbreeding: Inbreeding measured by\n"
		"    Identitcal by Decent (and by State). This statistics go through\n"
		"    all loci of individuals in a diploid population and calculate the\n"
		"    number and proportions of alleles that are identitcal by decent\n"
		"    and by state. Because ancestral information is only available in\n"
		"    lineage module, variables IBD_freq are always set to zero in other\n"
		"    modules. Loci on sex and mitochondrial chromosomes, and non-\n"
		"    diploid populations are currently not supported. This statistic\n"
		"    outputs the following variables:\n"
		"    *   IBD_freq (default) The frequency of IBD pairs among all allele\n"
		"    pairs. To use this statistic, the population must be initialized\n"
		"    by operator InitLineage() to assign each ancestral allele an\n"
		"    unique identify.\n"
		"    *   IBS_freq (default) The proportion of IBS pairs among all\n"
		"    allele pairs.\n"
		"    *   IBD_freq_sp frequency of IBD in each (virtual) subpopulations.\n"
		"    *   IBS_freq_sp frequency of IBS in each (virtual)\n"
		"    subpopulations.effectiveSize: Parameter effectiveSize accepts a\n"
		"    list of loci at which the effective population size for the whole\n"
		"    or specified (virtual) subpopulations is calculated. effectiveSize\n"
		"    can be a list of loci indexes, names or ALL_AVAIL. Parameter\n"
		"    subPops is usually used to define samples from which effective\n"
		"    sizes are estimated. This statistic allows the calculation of true\n"
		"    effective size based on number of gametes each parents transmit to\n"
		"    the offspring population (per-locus before and after mating), and\n"
		"    estimated effective size based on sample genotypes. Due to the\n"
		"    temporal natural of some methods, more than one Stat operators\n"
		"    might be needed to calculate effective size. The vars parameter\n"
		"    specified which method to use and which variable to set.\n"
		"    Acceptable values include:\n"
		"    *   Ne_demo_base When this variable is set before mating, it\n"
		"    stores IDs of breeding parents and, more importantly, assign an\n"
		"    unique lineage value to alleles at specified loci of each\n"
		"    individual. This feature is only available for lineage modules and\n"
		"    will change lineage values at specified loci of all individuals.\n"
		"    *   Ne_demo_base_sp Pre-mating information for each (virtual)\n"
		"    subpopulation, used by variable Ne_demo_sp.\n"
		"    *   Ne_demo A dictionary of locus-specific demographic effective\n"
		"    population size, calculated using number of gemetes each parent\n"
		"    transmits to the offspring population. The method is vased on Crow\n"
		"    & Denniston 1988 (Ne = KN-1/k-1+Vk/k) and need variable\n"
		"    Ne_demo_base set before mating. Effective size estimated from this\n"
		"    formula is model dependent and might not be applicable to your\n"
		"    mating schemes.\n"
		"    *   Ne_demo_sp Calculate subpopulation-specific effective size.\n"
		"    *   Ne_temporal_base When this variable is set in parameter vars,\n"
		"    the Stat operator saves baseline allele frequencies and other\n"
		"    information in this variable, which are used by temporary methods\n"
		"    to estimate effective population size according to changes in\n"
		"    allele frequency between the baseline and present generations.\n"
		"    This variable could be set repeatedly to change baselines.\n"
		"    *   Ne_temporal_base_sp Set baseline information for each\n"
		"    (virtual) subpopulation specified.\n"
		"    *   Ne_tempoFS_P1 Effective population size, 2.5% and 97.5%\n"
		"    confidence interval for sampling plan 1 as a list of size 3,\n"
		"    estimated using a temporal method as described in Jorde & Ryman\n"
		"    (2007), and as implemented by software tempoFS\n"
		"    (http://www.zoologi.su.se/~ryman/). This variable is set to census\n"
		"    population size if no baseline has been set, and to the temporal\n"
		"    effective size between the present and the baseline generation\n"
		"    otherwise. This method uses population size or sum of\n"
		"    subpopulation sizes of specified (virtual) subpopulations as\n"
		"    census population size for the calculation based on plan 1.\n"
		"    *   Ne_tempoFS_P2 Effective population size, 2.5% and 97.5%\n"
		"    confidence interval for sampling plan 2 as a list of size 6,\n"
		"    estimated using a temporal method as described in Jorde & Ryman\n"
		"    (2007). This variable is set to census population size no baseline\n"
		"    has been set, and to the temporal effective size between the\n"
		"    present and the baseline generation otherwise. This method assumes\n"
		"    that the sample is drawn from an infinitely-sized population.\n"
		"    *   Ne_tempoFS deprecated, use Ne_tempoFS_P2 instead.\n"
		"    *   Ne_tempoFS_P1_sp Estimate effective size of each (virtual)\n"
		"    subpopulation using method Jorde & Ryman 2007, assuming sampling\n"
		"    plan 1. The census population sizes for sampling plan 1 are the\n"
		"    sizes for each subpopulation that contain the specified (virtual)\n"
		"    subpopulations.\n"
		"    *   Ne_tempoFS_P2_sp Estimate effective size of each (virtual)\n"
		"    subpopulation using method Jorde & Ryman 2007, assuming sampling\n"
		"    plan 2.\n"
		"    *   Ne_tempoFS_sp deprecated, use Ne_tempoFS_P2_sp instead.\n"
		"    *   Ne_waples89_P1 Effective population size, 2.5% and 97.5%\n"
		"    confidence interval for sampling plan 1 as a list of size 6,\n"
		"    estimated using a temporal method as described in Waples 1989,\n"
		"    Genetics. Because this is a temporal method, Ne_waples89 estimates\n"
		"    effective size between the present and the baseline generation set\n"
		"    by variable Ne_temporal_base. Census population size will be\n"
		"    resutned if no baseline has been set. This method uses population\n"
		"    size or sum of subpopulation sizes of specified (virtual)\n"
		"    subpopulations as census population size for the calculation based\n"
		"    on plan 1.\n"
		"    *   Ne_waples89_P2 Effective population size, 2.5% and 97.5%\n"
		"    confidence interval for sampling plan 2 as a list of size 6,\n"
		"    estimated using a temporal method as described in Waples 1989,\n"
		"    Genetics. Because this is a temporal method, Ne_waples89 estimates\n"
		"    effective size between the present and the baseline generation set\n"
		"    by variable Ne_temporal_base. Census population size will be\n"
		"    returned if no baseline has been set.\n"
		"    *   Ne_waples89_P1_sp Estimate effective size for each (virtual)\n"
		"    subpopulation using method Waples 89, assuming sampling plan 1.\n"
		"    The census population sizes are the sizes for each subpopulation\n"
		"    that contain the specified (virtual) subpopulation.\n"
		"    *   Ne_waples89_P2_sp Estimate effective size for each (virtual)\n"
		"    subpopulation using method Waples 89, assuming sampling plan 2.\n"
		"    *   Ne_waples89_sp deprecated, use Ne_waples89_P2_sp instead.\n"
		"    *   Ne_LD Lists of length three for effective population size,\n"
		"    2.5% and 97.% confidence interval for cutoff allele frequency 0.,\n"
		"    0.01, 0.02 and 0.05 (as dictionary keys), using a parametric\n"
		"    method, estimated from linkage disequilibrim information of one\n"
		"    sample, using LD method developed by Waples & Do 2006 (LDNe). This\n"
		"    method assumes unlinked loci and uses LD measured from genotypes\n"
		"    at loci. Because this is a sample based method, it should better\n"
		"    be applied to a random sample of the population. 95% CI is\n"
		"    calculated using a Jackknife estimated effective number of\n"
		"    independent alleles. Please refer to relevant papers and the LDNe\n"
		"    user's guide for details.\n"
		"    *   Ne_LD_sp Estimate LD-based effective population size for each\n"
		"    specified (virtual) subpopulation.\n"
		"    *   Ne_LD_mono A version of Ne_LD that assumes monogamy (see\n"
		"    Waples 2006 for details.\n"
		"    *   Ne_LD_mono_sp Ne_LD_mono calculated for each (virtual)\n"
		"    subpopulation.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Stat", (PyCFunction)_wrap_delete_Stat, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Stat()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Stat_swigregister", Stat_swigregister, METH_VARARGS, NULL},
	 { (char *)"Stat_swiginit", Stat_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyOutput", (PyCFunction) _wrap_new_PyOutput, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyOutput(msg=\"\", output=\">\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a PyOutput operator that outputs a string msg to output\n"
		"    (default to standard terminal output) when it is applied to a\n"
		"    population. Please refer to class BaseOperator for a detailed\n"
		"    description of common operator parameters such as stage, begin and\n"
		"    output.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyOutput", (PyCFunction)_wrap_delete_PyOutput, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyOutput()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyOutput_swigregister", PyOutput_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyOutput_swiginit", PyOutput_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Dumper", (PyCFunction) _wrap_new_Dumper, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Dumper(genotype=True, structure=True, ancGens=UNSPECIFIED,\n"
		"      width=1, max=100, loci=[], output=\">\", begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a operator that dumps the genotype structure (if structure\n"
		"    is True) and genotype (if genotype is True) to an output ( default\n"
		"    to standard terminal output). Because a population can be large,\n"
		"    this operator will only output the first 100 (parameter max)\n"
		"    individuals of the present generation (parameter ancGens). All\n"
		"    loci will be outputed unless parameter loci are used to specify a\n"
		"    subset of loci. This operator by default output values of all\n"
		"    information fields unless parameter infoFields is used to specify\n"
		"    a subset of info fields to display. If a list of (virtual)\n"
		"    subpopulations are specified, this operator will only output\n"
		"    individuals in these outputs. Please refer to class BaseOperator\n"
		"    for a detailed explanation for common parameters such as output\n"
		"    and stage.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Dumper", (PyCFunction)_wrap_delete_Dumper, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Dumper()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Dumper_swigregister", Dumper_swigregister, METH_VARARGS, NULL},
	 { (char *)"Dumper_swiginit", Dumper_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SavePopulation", (PyCFunction) _wrap_new_SavePopulation, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SavePopulation(output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that saves a population to output when it is\n"
		"    applied to the population. This operator supports all output\n"
		"    specifications ('', 'filename', 'filename' prefixed by one or more\n"
		"    '>' characters, and '!expr') but output from different operators\n"
		"    will always replace existing files (effectively ignore '>'\n"
		"    specification). Parameter subPops is ignored. Please refer to\n"
		"    class BaseOperator for a detailed description about common\n"
		"    operator parameters such as stage and begin.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SavePopulation", (PyCFunction)_wrap_delete_SavePopulation, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~SavePopulation()\n"
		"\n"
		"\n"
		""},
	 { (char *)"SavePopulation_swigregister", SavePopulation_swigregister, METH_VARARGS, NULL},
	 { (char *)"SavePopulation_swiginit", SavePopulation_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InitSex", (PyCFunction) _wrap_new_InitSex, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InitSex(maleFreq=0.5, maleProp=-1, sex=[], begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that initializes individual sex to MALE or\n"
		"    FEMALE. By default, it assigns sex to individuals randomly, with\n"
		"    equal probability of having a male or a female. This probabability\n"
		"    can be adjusted through parameter maleFreq or be made to exact\n"
		"    proportions by specifying parameter maleProp. Alternatively, a\n"
		"    fixed sequence of sexes can be assigned. For example, if\n"
		"    sex=[MALE, FEMALE], individuals will be assigned MALE and FEMALE\n"
		"    successively. Parameter maleFreq or maleProp are ignored if sex is\n"
		"    given. If a list of (virtual) subpopulation is specified in\n"
		"    parameter subPop, only individuals in these subpopulations will be\n"
		"    initialized. Note that the sex sequence, if used, is assigned\n"
		"    repeatedly regardless of (virtual) subpopulation boundaries so\n"
		"    that you can assign sex to all individuals in a population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InitSex", (PyCFunction)_wrap_delete_InitSex, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InitSex()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitSex_swigregister", InitSex_swigregister, METH_VARARGS, NULL},
	 { (char *)"InitSex_swiginit", InitSex_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InitInfo", (PyCFunction) _wrap_new_InitInfo, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InitInfo(values, begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that initialize individual information fields\n"
		"    infoFields using a sequence of values or a user-defined function.\n"
		"    If a list of values are given, it will be used sequentially for\n"
		"    all individuals. The values will be reused if its length is less\n"
		"    than the number of individuals. The values will be assigned\n"
		"    repeatedly regardless of subpopulation boundaries. If a Python\n"
		"    function is given, it will be called, without any argument,\n"
		"    whenever a value is needed. If a list of (virtual) subpopulation\n"
		"    is specified in parameter subPop, only individuals in these\n"
		"    subpopulations will be initialized.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InitInfo", (PyCFunction)_wrap_delete_InitInfo, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InitInfo()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitInfo_swigregister", InitInfo_swigregister, METH_VARARGS, NULL},
	 { (char *)"InitInfo_swiginit", InitInfo_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InitGenotype", (PyCFunction) _wrap_new_InitGenotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InitGenotype(freq=[], genotype=[], prop=[], haplotypes=[],\n"
		"      genotypes=[], loci=ALL_AVAIL, ploidy=ALL_AVAIL, begin=0, end=1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function creates an initializer that initializes individual\n"
		"    genotypes with random alleles, genotypes, or haplotypes with\n"
		"    specified frequencies (parameter freq) or proportions (parameter\n"
		"    prop). If parameter genotypes or haplotypes is not specified, freq\n"
		"    specifies the allele frequencies of alleles 0, 1, 2...\n"
		"    respectively. Alternatively, you can use parameter prop to\n"
		"    specified the exact proportions of alleles 0, 1, ..., although\n"
		"    alleles with small proportions might not be assigned at all.\n"
		"    Values of parameter prob or prop should add up to 1. In addition\n"
		"    to a vector, parameter prob and prop can also be a function that\n"
		"    accepts optional parameters loc, subPop or vsp and returns a list\n"
		"    of requencies for alleles 0, 1, etc, or a number for frequency of\n"
		"    allele 0 as a speciail case for each locus, subpopulation\n"
		"    (parameter subPop), or virtual subpopulations (parameter vsp, pass\n"
		"    as a tuple).  If parameter genotypes is specified, it should\n"
		"    contain a list of genotypes (alleles on different strand of\n"
		"    chromosomes) with length equal to population ploidy. Parameter\n"
		"    prob and prop then specifies frequencies or proportions of each\n"
		"    genotype, which can vary for each subpopulation but not each locus\n"
		"    if the function form of parameters is used.  If parameter\n"
		"    haplotypes is specified, it should contain a list of haplotypes\n"
		"    (alleles on the same strand of chromosome) and parameter prob or\n"
		"    prop specifies frequencies or proportions of each haplotype.  If\n"
		"    loci, ploidy and/or subPop are specified, only specified loci,\n"
		"    ploidy, and individuals in these (virtual) subpopulations will be\n"
		"    initialized. Parameter loci can be a list of loci indexes, names\n"
		"    or ALL_AVAIL. If the length of a haplotype is not enough to fill\n"
		"    all loci, the haplotype will be reused. If a list (or a single)\n"
		"    haplotypes are specified without freq or prop, they are used with\n"
		"    equal probability.  In the last case, if a sequence of genotype is\n"
		"    specified through parameter genotype (not genotypes), it will be\n"
		"    used repeatedly to initialize all alleles sequentially. This works\n"
		"    similar to function Population.setGenotype() except that you can\n"
		"    limit the initialization to certain loci and ploidy.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InitGenotype", (PyCFunction)_wrap_delete_InitGenotype, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InitGenotype()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitGenotype_swigregister", InitGenotype_swigregister, METH_VARARGS, NULL},
	 { (char *)"InitGenotype_swiginit", InitGenotype_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InitLineage", (PyCFunction) _wrap_new_InitLineage, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InitLineage(lineage=[], mode=PER_ALLELE, loci=ALL_AVAIL,\n"
		"      ploidy=ALL_AVAIL, begin=0, end=1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"ind_id\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function creates an initializer that initializes lineages\n"
		"    with either a specified set of values or from the field infoFields\n"
		"    (default to ind_id), whose value will be saved as the lineage of\n"
		"    modified alleles. If a list of values is specified in parameter\n"
		"    lineage, each value in this list is applied to one or more alleles\n"
		"    so that each allele (PER_ALLELE, default mode), alleles on each\n"
		"    chromosome (PER_CHROMOSOME), on chromosomes of each ploidy\n"
		"    (PER_PLOIDY), or for each individual (PER_INDIVIDUAL) have the\n"
		"    same lineage. A single value is allowed and values in lineage will\n"
		"    be re-used if not enough values are provided. If an empty list is\n"
		"    provided, values 1, 2, 3, .. will be used to provide an unique\n"
		"    identify for each allele, genotype, chromosome, etc. If a valid\n"
		"    field is specified (default to ind_id), the value of this field\n"
		"    will be used for all alleles of each individual if mode is set to\n"
		"    FROM_INFO, or be adjusted to produce positive values for alleles\n"
		"    on the frist ploidy, and negative values for the second ploidy\n"
		"    (and so on) if mode equals to FROM_INFO_SIGNED. If loci, ploidy\n"
		"    and/or subPops are specified, only specified loci, ploidy, and\n"
		"    individuals in these (virtual) subpopulations will be initialized.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InitLineage", (PyCFunction)_wrap_delete_InitLineage, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InitLineage()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InitLineage_swigregister", InitLineage_swigregister, METH_VARARGS, NULL},
	 { (char *)"InitLineage_swiginit", InitLineage_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_IdTagger", (PyCFunction) _wrap_new_IdTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    IdTagger(begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, output=\"\", infoFields=[\"ind_id\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an IdTagger that assign an unique ID for each individual it\n"
		"    is applied to. The IDs are created sequentially and are stored in\n"
		"    an information field specified in parameter infoFields (default to\n"
		"    ind_id). This operator is considered a during-mating operator but\n"
		"    it can be used to set ID for all individuals of a population when\n"
		"    it is directly applied to the population.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_IdTagger", (PyCFunction)_wrap_delete_IdTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~IdTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"IdTagger_reset", (PyCFunction) _wrap_IdTagger_reset, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.reset(startID=1)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Reset the global individual ID number so that IdTaggers will start\n"
		"    from id (default to 1) again.\n"
		"\n"
		"\n"
		""},
	 { (char *)"IdTagger_swigregister", IdTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"IdTagger_swiginit", IdTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_InheritTagger", (PyCFunction) _wrap_new_InheritTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    InheritTagger(mode=PATERNAL, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, output=\"\", infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates an inheritance tagger that passes values of parental\n"
		"    information fields (parameter infoFields) to the corresponding\n"
		"    fields of offspring. If there is only one parent, values at the\n"
		"    specified information fields are copied directly. If there are two\n"
		"    parents, parameter mode specifies how to pass them to an\n"
		"    offspring. More specifically,\n"
		"    *   mode=MATERNAL Passing the value from mother.\n"
		"    *   mode=PATERNAL Passing the value from father.\n"
		"    *   mode=MEAN Passing the average of two values.\n"
		"    *   mode=MAXIMUM Passing the maximum value of two values.\n"
		"    *   mode=MINIMUM Passing the minimum value of two values.\n"
		"    *   mode=SUMMATION Passing the summation of two values.\n"
		"    *   mode=MULTIPLICATION Passing the multiplication of two values.\n"
		"    An RuntimeError will be raised if any of the parents does not\n"
		"    exist. This operator does not support parameter subPops and does\n"
		"    not output any information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_InheritTagger", (PyCFunction)_wrap_delete_InheritTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~InheritTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"InheritTagger_swigregister", InheritTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"InheritTagger_swiginit", InheritTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SummaryTagger", (PyCFunction) _wrap_new_SummaryTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SummaryTagger(mode=MEAN, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, output=\"\", infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a summary tagger that summarize values of one or more\n"
		"    parental information field (infoFields[:-1]) to an offspring\n"
		"    information field (infoFields[-1]). A parameter mode specifies how\n"
		"    to pass summarize parental values. More specifically,\n"
		"    *   mode=MEAN Passing the average of values.\n"
		"    *   mode=MAXIMUM Passing the maximum value of values.\n"
		"    *   mode=Minumum Passing the minimum value of values.\n"
		"    *   mode=SUMMATION Passing the sum of values.\n"
		"    *   mode=MULTIPLICATION Passing the multiplication of values. This\n"
		"    operator does not support parameter subPops and does not output\n"
		"    any information.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SummaryTagger", (PyCFunction)_wrap_delete_SummaryTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~SummaryTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"SummaryTagger_swigregister", SummaryTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"SummaryTagger_swiginit", SummaryTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ParentsTagger", (PyCFunction) _wrap_new_ParentsTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ParentsTagger(begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, output=\"\", infoFields=[\"father_idx\",\n"
		"      \"mother_idx\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a parents tagger that records the indexes of parents of\n"
		"    each offspring when it is applied to an offspring during-mating.\n"
		"    If two information fields are specified (parameter infoFields,\n"
		"    with default value ['father_idx', 'mother_idx']), they are used to\n"
		"    record the indexes of each individual's father and mother. Value\n"
		"    -1 will be assigned if any of the parent is missing. If only one\n"
		"    information field is given, it will be used to record the index of\n"
		"    the first valid parent (father if both parents are valid). This\n"
		"    operator ignores parameters output and subPops.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ParentsTagger", (PyCFunction)_wrap_delete_ParentsTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~ParentsTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ParentsTagger_swigregister", ParentsTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"ParentsTagger_swiginit", ParentsTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_OffspringTagger", (PyCFunction) _wrap_new_OffspringTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    OffspringTagger(begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, output=\"\", infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an offspring tagger that records the indexes of offspring\n"
		"    within a family. The index is determined by successful production\n"
		"    of offspring during a mating events so the it does not increase\n"
		"    the index if a previous offspring is discarded, and it resets\n"
		"    index even if adjacent families share the same parents. This\n"
		"    operator ignores parameters stage, output, and subPops.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_OffspringTagger", (PyCFunction)_wrap_delete_OffspringTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~OffspringTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"OffspringTagger_swigregister", OffspringTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"OffspringTagger_swiginit", OffspringTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PedigreeTagger", (PyCFunction) _wrap_new_PedigreeTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PedigreeTagger(idField=\"ind_id\", output=\"\", outputFields=[],\n"
		"      outputLoci=[], begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"father_id\", \"mother_id\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a pedigree tagger that records the ID of parents of each\n"
		"    offspring when it is applied to an offspring during-mating. If two\n"
		"    information fields are specified (parameter infoFields, with\n"
		"    default value ['father_id', 'mother_id']), they are used to record\n"
		"    the ID of each individual's father and mother stored in the\n"
		"    idField (default to ind_id) field of the parents. Value -1 will be\n"
		"    assigned if any of the parent is missing. If only one information\n"
		"    field is given, it will be used to record the ID of the first\n"
		"    valid parent (father if both pedigree are valid).  This operator\n"
		"    by default does not send any output. If a valid output stream is\n"
		"    given (should be in the form of '>>filename' so that output will\n"
		"    be concatenated), this operator will output the ID of offspring,\n"
		"    IDs of his or her parent(s), sex and affection status of\n"
		"    offspring, and values at specified information fields\n"
		"    (outputFields) and loci (outputLoci) in the format of off_id\n"
		"    father_id mother_id M/F A/U fields genotype. father_id or\n"
		"    mother_id will be ignored if only one parent is involved. This\n"
		"    file format can be loaded using function loadPedigree.  Because\n"
		"    only offspring will be outputed, individuals in the top-most\n"
		"    ancestral generation will not be outputed. This is usually not a\n"
		"    problem because individuals who have offspring in the next\n"
		"    generation will be constructed by function loadPedigree, although\n"
		"    their information fields and genotype will be missing. If you\n"
		"    would like to create a file with complete pedigree information,\n"
		"    you can apply this operator before evolution in the initOps\n"
		"    parameter of functions Population.evolve or Simulator.evolve. This\n"
		"    will output all individuals in the initial population (the top-\n"
		"    most ancestral population after evolution) in the same format.\n"
		"    Note that sex, affection status and genotype can be changed by\n"
		"    other operators so this operator should usually be applied after\n"
		"    all other operators are applied.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PedigreeTagger", (PyCFunction)_wrap_delete_PedigreeTagger, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PedigreeTagger()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PedigreeTagger_swigregister", PedigreeTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"PedigreeTagger_swiginit", PedigreeTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyTagger", (PyCFunction) _wrap_new_PyTagger, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyTagger(func=None, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, output=\"\", infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a hybrid tagger that provides an user provided function\n"
		"    func with values of specified information fields (determined by\n"
		"    parameter names of this function) of parents and assign\n"
		"    corresponding information fields of offspring with its return\n"
		"    value. If more than one parent are available, maternal values are\n"
		"    passed after paternal values. For example, if a function func(A,\n"
		"    B) is passed, this operator will send two tuples with parental\n"
		"    values of information fields 'A' and 'B' to this function and\n"
		"    assign its return values to fields 'A' and 'B' of each offspring.\n"
		"    The return value of this function should be a list, although a\n"
		"    single value will be accepted if only one information field is\n"
		"    specified. This operator ignores parameters stage, output and\n"
		"    subPops.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyTagger", (PyCFunction)_wrap_delete_PyTagger, METH_O, NULL},
	 { (char *)"PyTagger_swigregister", PyTagger_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyTagger_swiginit", PyTagger_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Migrator", (PyCFunction) _wrap_new_Migrator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Migrator(rate=[], mode=BY_PROBABILITY, toSubPops=ALL_AVAIL,\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"migrate_to\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Migrator that moves individuals from source (virtual)\n"
		"    subpopulations subPops (default to migrate from all\n"
		"    subpopulations) to destination subpopulations toSubPops (default\n"
		"    to all subpopulations), according to existing values in an\n"
		"    information field infoFields[0], or randomly according to a\n"
		"    migration matrix rate. In the latter case, the size of the matrix\n"
		"    should match the number of source and destination subpopulations.\n"
		"    Depending on the value of parameter mode, elements in the\n"
		"    migration matrix (rate) are interpreted as either the\n"
		"    probabilities to migrate from source to destination subpopulations\n"
		"    (mode = BY_PROBABILITY), proportions of individuals in the source\n"
		"    (virtual) subpopulations to the destination subpopulations (mode =\n"
		"    BY_PROPORTION), numbers of migrants in the source (virtual)\n"
		"    subpopulations (mode = BY_COUNTS), or ignored completely (mode =\n"
		"    BY_IND_INFO). In the last case, parameter subPops is respected\n"
		"    (only individuals in specified (virtual) subpopulations will\n"
		"    migrate) but toSubPops is ignored.  Please refer to operator\n"
		"    BaseOperator for a detailed explanation for all parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Migrator", (PyCFunction)_wrap_delete_Migrator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Migrator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Migrator_swigregister", Migrator_swigregister, METH_VARARGS, NULL},
	 { (char *)"Migrator_swiginit", Migrator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_BackwardMigrator", (PyCFunction) _wrap_new_BackwardMigrator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BackwardMigrator(rate=[], mode=BY_PROBABILITY, begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[\"migrate_to\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a BackwardMigrator that moves individuals between subPop\n"
		"    subpopulations randomly according to a backward migration matrix\n"
		"    rate. The size of the matrix should match the number of\n"
		"    subpopulations.  Depending on the value of parameter mode,\n"
		"    elements in the migration matrix (rate) are interpreted as either\n"
		"    the probabilities to originate from source subpopulations (mode =\n"
		"    BY_PROBABILITY) or proportions of individuals originate from the\n"
		"    source (virtual) subpopulations (mode = BY_PROPORTION). Migration\n"
		"    by count is not supported by this operator.  Please refer to\n"
		"    operator BaseOperator for a detailed explanation for all\n"
		"    parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BackwardMigrator", (PyCFunction)_wrap_delete_BackwardMigrator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BackwardMigrator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BackwardMigrator_swigregister", BackwardMigrator_swigregister, METH_VARARGS, NULL},
	 { (char *)"BackwardMigrator_swiginit", BackwardMigrator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SplitSubPops", (PyCFunction) _wrap_new_SplitSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SplitSubPops(subPops=ALL_AVAIL, sizes=[], proportions=[],\n"
		"      names=[], randomize=True, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Split a list of subpopulations subPops into finer subpopulations.\n"
		"    A single subpopulation is acceptable but virtual subpopulations\n"
		"    are not allowed. All subpopulations will be split if subPops is\n"
		"    not specified.  The subpopulations can be split in three ways:\n"
		"    *   If parameter sizes is given, each subpopulation will be split\n"
		"    into subpopulations with given size. The sizes should add up to\n"
		"    the size of all orignal subpopulations.\n"
		"    *   If parameter proportions is given, each subpopulation will be\n"
		"    split into subpopulations with corresponding proportion of\n"
		"    individuals. proportions should add up to 1.\n"
		"    *   If an information field is given (parameter infoFields),\n"
		"    individuals having the same value at this information field will\n"
		"    be grouped into a subpopulation. The number of resulting\n"
		"    subpopulations is determined by the number of distinct values at\n"
		"    this information field. If parameter randomize is True (default),\n"
		"    individuals will be randomized before a subpopulation is split.\n"
		"    This is designed to remove artificial order of individuals\n"
		"    introduced by, for example, some non- random mating schemes. Note\n"
		"    that, however, the original individual order is not guaranteed\n"
		"    even if this parameter is set to False.  Unless the last\n"
		"    subpopulation is split, the indexes of existing subpopulations\n"
		"    will be changed. If a subpopulation has a name, this name will\n"
		"    become the name for all subpopulations separated from this\n"
		"    subpopulation. Optionally, you can assign names to the new\n"
		"    subpopulations using a list of names specified in parameter names.\n"
		"    Because the same set of names will be used for all subpopulations,\n"
		"    this parameter is not recommended when multiple subpopulations are\n"
		"    split.  Please refer to operator BaseOperator for a detailed\n"
		"    explanation for all parameters.\n"
		"\n"
		"Note:\n"
		"\n"
		"    Unlike operator Migrator, this operator does not require an\n"
		"    information field such as migrate_to.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SplitSubPops", (PyCFunction)_wrap_delete_SplitSubPops, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~SplitSubPops()\n"
		"\n"
		"\n"
		""},
	 { (char *)"SplitSubPops_swigregister", SplitSubPops_swigregister, METH_VARARGS, NULL},
	 { (char *)"SplitSubPops_swiginit", SplitSubPops_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MergeSubPops", (PyCFunction) _wrap_new_MergeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MergeSubPops(subPops=ALL_AVAIL, name=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator that merges subpopulations subPops to a single\n"
		"    subpopulation. If subPops is not given, all subpopulations will be\n"
		"    merged. The merged subpopulation will take the name of the first\n"
		"    subpopulation being merged unless a new name is given.  Please\n"
		"    refer to operator BaseOperator for a detailed explanation for all\n"
		"    parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MergeSubPops", (PyCFunction)_wrap_delete_MergeSubPops, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MergeSubPops()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MergeSubPops_swigregister", MergeSubPops_swigregister, METH_VARARGS, NULL},
	 { (char *)"MergeSubPops_swiginit", MergeSubPops_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ResizeSubPops", (PyCFunction) _wrap_new_ResizeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ResizeSubPops(subPops=ALL_AVAIL, sizes=[], proportions=[],\n"
		"      propagate=True, begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Resize given subpopulations subPops to new sizes size, or sizes\n"
		"    proportional to original sizes (parameter proportions). All\n"
		"    subpopulations will be resized if subPops is not specified. If the\n"
		"    new size of a subpopulation is smaller than its original size,\n"
		"    extra individuals will be removed. If the new size is larger, new\n"
		"    individuals with empty genotype will be inserted, unless parameter\n"
		"    propagate is set to True (default). In this case, existing\n"
		"    individuals will be copied sequentially, and repeatedly if needed.\n"
		"    Please refer to operator BaseOperator for a detailed explanation\n"
		"    for all parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ResizeSubPops", (PyCFunction)_wrap_delete_ResizeSubPops, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~ResizeSubPops()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ResizeSubPops_swigregister", ResizeSubPops_swigregister, METH_VARARGS, NULL},
	 { (char *)"ResizeSubPops_swiginit", ResizeSubPops_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_BaseMutator", (PyCFunction) _wrap_new_BaseMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BaseMutator(rates=[], loci=ALL_AVAIL, mapIn=[], mapOut=[],\n"
		"      context=0, output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[\"ind_id\"],\n"
		"      lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    A mutator mutates alleles from one state to another with given\n"
		"    probability. This base mutator does not perform any mutation but\n"
		"    it defines common behaviors of all mutators.  By default, a\n"
		"    mutator mutates all alleles in all populations of a simulator at\n"
		"    all generations. A number of parameters can be used to restrict\n"
		"    mutations to certain generations (parameters begin, end, step and\n"
		"    at), replicate populations (parameter rep), (virtual)\n"
		"    subpopulations (parameter subPops) and loci (parameter loci).\n"
		"    Parameter loci can be a list of loci indexes, names, list of\n"
		"    chromosome position pairs, ALL_AVAIL, or a function with optional\n"
		"    parameter pop that will be called at each ganeeration to determine\n"
		"    indexes of loci. Please refer to class BaseOperator for a detailed\n"
		"    explanation of these parameters.  Parameter rate or its\n"
		"    equivalence specifies the probability that a a mutation event\n"
		"    happens. The exact form and meaning of rate is mutator-specific.\n"
		"    If a single rate is specified, it will be applied to all loci. If\n"
		"    a list of mutation rates are given, they will be applied to each\n"
		"    locus specified in parameter loci. Note that not all mutators\n"
		"    allow specification of multiple mutation rate, especially when the\n"
		"    mutation rate itself is a list or matrix.  Alleles at a locus are\n"
		"    non-negative numbers 0, 1, ... up to the maximum allowed allele\n"
		"    for the loaded module (1 for binary, 255 for short and 65535 for\n"
		"    long modules). Whereas some general mutation models treat alleles\n"
		"    as numbers, other models assume specific interpretation of\n"
		"    alleles. For example, an AcgtMutator assumes alleles 0, 1, 2 and 3\n"
		"    as nucleotides A, C, G and T. Using a mutator that is incompatible\n"
		"    with your simulation will certainly yield erroneous results.  If\n"
		"    your simulation assumes different alleles with a mutation model,\n"
		"    you can map an allele to the allele used in the model and map the\n"
		"    mutated allele back. This is achieved using a mapIn list with its\n"
		"    i-th item being the corresponding allele of real allele i, and a\n"
		"    mapOut list with its i-th item being the real allele of allele i\n"
		"    assumed in the model. For example mapIn=[0, 0, 1] and mapOut=[1,\n"
		"    2] would allow the use of a SNPMutator to mutate between alleles 1\n"
		"    and 2, instead of 0 and 1. Parameters mapIn and mapOut also accept\n"
		"    a user-defined Python function that returns a corresponding allele\n"
		"    for a given allele. This allows easier mapping between a large\n"
		"    number of alleles and advanced models such as random emission of\n"
		"    alleles.  If a valid information field is specified for parameter\n"
		"    infoFields (default to ind_id) for modules with lineage allele\n"
		"    type, the lineage of the mutated alleles will be the ID (stored in\n"
		"    the first field of infoFields) of individuals that harbor the\n"
		"    mutated alleles if lineageMode is set to FROM_INFO (default). If\n"
		"    lineageMode is set to FROM_INFO_SIGNED, the IDs will be assigned a\n"
		"    sign depending on the ploidy the mutation happens (1 for ploidy 0,\n"
		"    -1 for ploidy 1, etc). The lineage information will be transmitted\n"
		"    along with the alleles so this feature allows you to track the\n"
		"    source of mutants during evolution.A  A mutator by default does\n"
		"    not produce any output. However, if an non-empty output is\n"
		"    specified, the operator will output generation number, locus,\n"
		"    ploidy, original allele, mutant, and values of all information\n"
		"    field specified by parameter infoFields (e.g. individual ID if\n"
		"    ind_id is specified).  Some mutation models are context dependent.\n"
		"    Namely, how an allele mutates will depend on its adjecent alleles.\n"
		"    Whereas most simuPOP mutators are context independent, some of\n"
		"    them accept a parameter context which is the number of alleles to\n"
		"    the left and right of the mutated allele. For example context=1\n"
		"    will make the alleles to the immediate left and right to a mutated\n"
		"    allele available to a mutator. These alleles will be mapped in if\n"
		"    parameter mapIn is defined. How exactly a mutator makes use of\n"
		"    these information is mutator dependent.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BaseMutator", (PyCFunction)_wrap_delete_BaseMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BaseMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseMutator_swigregister", BaseMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"BaseMutator_swiginit", BaseMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MatrixMutator", (PyCFunction) _wrap_new_MatrixMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MatrixMutator(rate, loci=ALL_AVAIL, mapIn=[], mapOut=[],\n"
		"      output=\"\", begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a mutator that mutates alleles 0, 1, ..., n-1 using a n by\n"
		"    n matrix rate. Item (i,j) of this matrix specifies the probability\n"
		"    at which allele i mutates to allele j. Diagnal items (i, i) are\n"
		"    ignored because they are automatically determined by other\n"
		"    probabilities. Only one mutation rate matrix can be specified\n"
		"    which will be used for all loci in the applied population, or loci\n"
		"    specified by parameter loci. If alleles other than 0, 1, ..., n-1\n"
		"    exist in the population, they will not be mutated although a\n"
		"    warning message will be given if debugging code DBG_WARNING is\n"
		"    turned on. Please refer to classes mutator and BaseOperator for\n"
		"    detailed explanation of other parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MatrixMutator", (PyCFunction)_wrap_delete_MatrixMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MatrixMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MatrixMutator_swigregister", MatrixMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"MatrixMutator_swiginit", MatrixMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_KAlleleMutator", (PyCFunction) _wrap_new_KAlleleMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    KAlleleMutator(k, rates=[], loci=ALL_AVAIL, mapIn=[], mapOut=[],\n"
		"      output=\"\", begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a k-allele mutator that mutates alleles to one of the other\n"
		"    k-1 alleles with equal probability. This mutator by default\n"
		"    applies to all loci unless parameter loci is specified. A single\n"
		"    mutation rate will be used for all loci if a single value of\n"
		"    parameter rates is given. Otherwise, a list of mutation rates can\n"
		"    be specified for each locus in parameter loci. If the mutated\n"
		"    allele is larger than or equal to k, it will not be mutated. A\n"
		"    warning message will be displayed if debugging code DBG_WARNING is\n"
		"    turned on. Please refer to classes mutator and BaseOperator for\n"
		"    descriptions of other parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_KAlleleMutator", (PyCFunction)_wrap_delete_KAlleleMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~KAlleleMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"KAlleleMutator_swigregister", KAlleleMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"KAlleleMutator_swiginit", KAlleleMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_StepwiseMutator", (PyCFunction) _wrap_new_StepwiseMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    StepwiseMutator(rates=[], loci=ALL_AVAIL, incProb=0.5,\n"
		"      maxAllele=0, mutStep=[], mapIn=[], mapOut=[], output=\"\",\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a stepwise mutation mutator that mutates an allele by\n"
		"    increasing or decreasing it. This mutator by default applies to\n"
		"    all loci unless parameter loci is specified. A single mutation\n"
		"    rate will be used for all loci if a single value of parameter\n"
		"    rates is given. Otherwise, a list of mutation rates can be\n"
		"    specified for each locus in parameter loci.  When a mutation event\n"
		"    happens, this operator increases or decreases an allele by mutStep\n"
		"    steps. Acceptable input of parameter mutStep include\n"
		"    *   A number: This is the default mode with default value 1.\n"
		"    *   (GEOMETRIC_DISTRIBUTION, p): The number of steps follows a a\n"
		"    geometric distribution with parameter p.\n"
		"    *   A Python function: This user defined function accepts the\n"
		"    allele being mutated and return the steps to mutate. The mutation\n"
		"    process is usually neutral in the sense that mutating up and down\n"
		"    is equally likely. You can adjust parameter incProb to change this\n"
		"    behavior.  If you need to use other generalized stepwise mutation\n"
		"    models, you can implement them using a PyMutator. If performance\n"
		"    becomes a concern, I may add them to this operator if provided\n"
		"    with a reliable reference.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_StepwiseMutator", (PyCFunction)_wrap_delete_StepwiseMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~StepwiseMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"StepwiseMutator_swigregister", StepwiseMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"StepwiseMutator_swiginit", StepwiseMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyMutator", (PyCFunction) _wrap_new_PyMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyMutator(rates=[], loci=ALL_AVAIL, func=None, context=0,\n"
		"      mapIn=[], mapOut=[], output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[\"ind_id\"],\n"
		"      lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a hybrid mutator that uses a user-provided function to\n"
		"    mutate an allele when a mutation event happens. This function\n"
		"    (parameter func) accepts the allele to be mutated as parameter\n"
		"    allele, locus index locus, and optional array of alleles as\n"
		"    parameter context, which are context alleles the left and right of\n"
		"    the mutated allele. Invalid context alleles (e.g. left allele to\n"
		"    the first locus of a chromosome) will be marked by -1. The return\n"
		"    value of this function will be used to mutate the passed allele.\n"
		"    The passed, returned and context alleles might be altered if\n"
		"    parameter mapIn and mapOut are used. This mutator by default\n"
		"    applies to all loci unless parameter loci is specified. A single\n"
		"    mutation rate will be used for all loci if a single value of\n"
		"    parameter rates is given. Otherwise, a list of mutation rates can\n"
		"    be specified for each locus in parameter loci. Please refer to\n"
		"    classes mutator and BaseOperator for descriptions of other\n"
		"    parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyMutator", (PyCFunction)_wrap_delete_PyMutator, METH_O, NULL},
	 { (char *)"PyMutator_swigregister", PyMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyMutator_swiginit", PyMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MixedMutator", (PyCFunction) _wrap_new_MixedMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MixedMutator(rates=[], loci=ALL_AVAIL, mutators=[], prob=[],\n"
		"      mapIn=[], mapOut=[], context=0, output=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a mutator that randomly chooses one of the specified\n"
		"    mutators to mutate an allele when a mutation event happens. The\n"
		"    mutators are choosen according to a list of probabilities ( prob)\n"
		"    that should add up to 1. The passed and returned alleles might be\n"
		"    changed if parameters mapIn and mapOut are used. Most parameters,\n"
		"    including loci, mapIn, mapOut, rep, and subPops of mutators\n"
		"    specified in parameter mutators are ignored. This mutator by\n"
		"    default applies to all loci unless parameter loci is specified.\n"
		"    Please refer to classes mutator and BaseOperator for descriptions\n"
		"    of other parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MixedMutator", (PyCFunction)_wrap_delete_MixedMutator, METH_O, NULL},
	 { (char *)"MixedMutator_swigregister", MixedMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"MixedMutator_swiginit", MixedMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_ContextMutator", (PyCFunction) _wrap_new_ContextMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    ContextMutator(rates=[], loci=ALL_AVAIL, mutators=[],\n"
		"      contexts=[], mapIn=[], mapOut=[], output=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a mutator that choose one of the specified mutators to\n"
		"    mutate an allele when a mutation event happens. The mutators are\n"
		"    choosen according to the context of the mutated allele, which is\n"
		"    specified as a list of alleles to the left and right of an allele\n"
		"    ( contexts). For example, contexts=[(0,0), (0,1), (1,1)] indicates\n"
		"    which mutators should be used to mutate allele X in the context of\n"
		"    0X0, 0X1, and 1X1. A context can include more than one alleles at\n"
		"    both left and right sides of a mutated allele but all contexts\n"
		"    should have the same (even) number of alleles. If an allele does\n"
		"    not have full context (e.g. when a locus is the first locus on a\n"
		"    chromosome), unavailable alleles will be marked as -1. There\n"
		"    should be a mutator for each context but an additional mutator can\n"
		"    be specified as the default mutator for unmatched contexts. If\n"
		"    parameters mapIn is specified, both mutated allele and its context\n"
		"    alleles will be mapped. Most parameters, including loci, mapIn,\n"
		"    mapOut, rep, and subPops of mutators specified in parameter\n"
		"    mutators are ignored. This mutator by default applies to all loci\n"
		"    unless parameter loci is specified. Please refer to classes\n"
		"    mutator and BaseOperator for descriptions of other parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_ContextMutator", (PyCFunction)_wrap_delete_ContextMutator, METH_O, NULL},
	 { (char *)"ContextMutator_swigregister", ContextMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"ContextMutator_swiginit", ContextMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PointMutator", (PyCFunction) _wrap_new_PointMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PointMutator(loci, allele, ploidy=0, inds=[], output=\"\",\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=0,\n"
		"      infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a point mutator that mutates alleles at specified loci to a\n"
		"    given allele of individuals inds. If there are multiple alleles at\n"
		"    a locus (e.g. individuals in a diploid population), only the first\n"
		"    allele is mutated unless indexes of alleles are listed in\n"
		"    parameter ploidy. This operator is by default applied to\n"
		"    individuals in the first subpopulation but you can apply it to a\n"
		"    different or more than one (virtual) subpopulations using\n"
		"    parameter subPops (AllAvail is also accepted). Please refer to\n"
		"    class BaseOperator for detailed descriptions of other parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PointMutator", (PyCFunction)_wrap_delete_PointMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PointMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PointMutator_swigregister", PointMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"PointMutator_swiginit", PointMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_RevertFixedSites", (PyCFunction) _wrap_new_RevertFixedSites, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    RevertFixedSites(loci=ALL_AVAIL, output=\"\", begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[\"ind_id\"])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create an operator to set all alleles to zero at specified\n"
		"    (parameter loci) or all loci if they are fixed (having one non-\n"
		"    zero allele) at these loci. If parameter subPops are specified,\n"
		"    only individuals in these subpopulations are considered.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_RevertFixedSites", (PyCFunction)_wrap_delete_RevertFixedSites, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~RevertFixedSites()\n"
		"\n"
		"\n"
		""},
	 { (char *)"RevertFixedSites_swigregister", RevertFixedSites_swigregister, METH_VARARGS, NULL},
	 { (char *)"RevertFixedSites_swiginit", RevertFixedSites_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_FiniteSitesMutator", (PyCFunction) _wrap_new_FiniteSitesMutator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    FiniteSitesMutator(rate, ranges, model=1, output=\"\", begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[\"ind_id\"], lineageMode=FROM_INFO)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This operator accepts a list of ranges which is the 'real range'\n"
		"    of each chromosome. Mutation happens with muation rate rate and\n"
		"    mutants will be recorded to the population (instead of alleles).\n"
		"    By default, this mutator assumes an finite-allele model where all\n"
		"    mutations are allowed and if a mutant (allele 1) is mutated, it\n"
		"    will be mutated to allele 0 (back mutation). Alternatively (model\n"
		"    = 2), an infinite-sites mutation model can be used where mutations\n"
		"    can happen only at a new locus. Mutations happen at a locus with\n"
		"    existing mutants will be moved to a random locus without existing\n"
		"    mutant. A warning message will be printed if there is no vacant\n"
		"    locus available. If a valid output is given, mutants will be\n"
		"    outputted in the format of \"gen mutant ind type\" where type is 0\n"
		"    for forward (0->1), 1 for backward (1->0), 2 for relocated\n"
		"    mutations, and 3 for ignored mutation because no vacent locus is\n"
		"    available. The second mode has the advantage that all mutants in\n"
		"    the simulated population can be traced to a single mutation event.\n"
		"    If the regions are reasonably wide and mutation rates are low,\n"
		"    these two mutation models should yield similar results.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_FiniteSitesMutator", (PyCFunction)_wrap_delete_FiniteSitesMutator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor.\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~FiniteSitesMutator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"FiniteSitesMutator_swigregister", FiniteSitesMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"FiniteSitesMutator_swiginit", FiniteSitesMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MutSpaceRevertFixedSites", (PyCFunction) _wrap_new_MutSpaceRevertFixedSites, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_MutSpaceRevertFixedSites", (PyCFunction)_wrap_delete_MutSpaceRevertFixedSites, METH_O, NULL},
	 { (char *)"MutSpaceRevertFixedSites_swigregister", MutSpaceRevertFixedSites_swigregister, METH_VARARGS, NULL},
	 { (char *)"MutSpaceRevertFixedSites_swiginit", MutSpaceRevertFixedSites_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MutSpaceMutator", (PyCFunction) _wrap_new_MutSpaceMutator, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_MutSpaceMutator", (PyCFunction)_wrap_delete_MutSpaceMutator, METH_O, NULL},
	 { (char *)"MutSpaceMutator_swigregister", MutSpaceMutator_swigregister, METH_VARARGS, NULL},
	 { (char *)"MutSpaceMutator_swiginit", MutSpaceMutator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_GenoTransmitter", (PyCFunction) _wrap_new_GenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    GenoTransmitter(output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a base genotype transmitter.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoTransmitter_clearChromosome", (PyCFunction) _wrap_GenoTransmitter_clearChromosome, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clearChromosome(ind, ploidy, chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Clear (set alleles to zero) chromosome chrom on the ploidy-th\n"
		"    homologous set of chromosomes of individual ind. It is equivalent\n"
		"    to ind.setGenotype([0], ploidy, chrom), except that it also clears\n"
		"    allele lineage if it is executed in a module with lineage allele\n"
		"    type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoTransmitter_copyChromosome", (PyCFunction) _wrap_GenoTransmitter_copyChromosome, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.copyChromosome(parent, parPloidy, offspring, ploidy, chrom)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Transmit chromosome chrom on the parPloidy set of homologous\n"
		"    chromosomes from parent to the ploidy set of homologous\n"
		"    chromosomes of offspring. It is equivalent to\n"
		"    offspring.setGenotype(parent.genotype(parPloidy, chrom), polidy,\n"
		"    chrom), except that it also copies allelic lineage when it is\n"
		"    executed in a module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"GenoTransmitter_copyChromosomes", (PyCFunction) _wrap_GenoTransmitter_copyChromosomes, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.copyChromosomes(parent, parPloidy, offspring, ploidy)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Transmit the parPloidy set of homologous chromosomes from parent\n"
		"    to the ploidy set of homologous chromosomes of offspring.\n"
		"    Customized chromosomes are not copied. It is equivalent to\n"
		"    offspring.setGenotype(parent.genotype(parPloidy), ploidy), except\n"
		"    that it also copies allelic lineage when it is executed in a\n"
		"    module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_GenoTransmitter", (PyCFunction)_wrap_delete_GenoTransmitter, METH_O, NULL},
	 { (char *)"GenoTransmitter_swigregister", GenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"GenoTransmitter_swiginit", GenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_CloneGenoTransmitter", (PyCFunction) _wrap_new_CloneGenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    CloneGenoTransmitter(output=\"\", chroms=ALL_AVAIL, begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a clone genotype transmitter (a during-mating operator)\n"
		"    that copies genotypes from parents to offspring. If two parents\n"
		"    are specified, genotypes are copied maternally. After genotype\n"
		"    transmission, offspring sex and affection status is copied from\n"
		"    the parent even if sex has been determined by an offspring\n"
		"    generator. All or specified information fields (parameter\n"
		"    infoFields, default to ALL_AVAIL) will also be copied from parent\n"
		"    to offspring. Parameters subPops is ignored. This operator by\n"
		"    default copies genotypes on all autosome and sex chromosomes\n"
		"    (excluding customized chromosomes), unless a parameter chroms is\n"
		"    used to specify which chromosomes to copy. This operator also\n"
		"    copies allelic lineage when it is executed in a module with\n"
		"    lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_CloneGenoTransmitter", (PyCFunction)_wrap_delete_CloneGenoTransmitter, METH_O, NULL},
	 { (char *)"CloneGenoTransmitter_swigregister", CloneGenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"CloneGenoTransmitter_swiginit", CloneGenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MendelianGenoTransmitter", (PyCFunction) _wrap_new_MendelianGenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MendelianGenoTransmitter(output=\"\", begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Mendelian genotype transmitter (a during-mating operator)\n"
		"    that transmits genotypes from parents to offspring following\n"
		"    Mendel's laws. Autosomes and sex chromosomes are handled but\n"
		"    customized chromosomes are ignored. Parameters subPops and\n"
		"    infoFields are ignored. This operator also copies allelic lineage\n"
		"    when it is executed in a module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"MendelianGenoTransmitter_transmitGenotype", (PyCFunction) _wrap_MendelianGenoTransmitter_transmitGenotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.transmitGenotype(parent, offspring, ploidy)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Transmit genotype from parent to offspring, and fill the ploidy\n"
		"    homologous set of chromosomes. This function does not set\n"
		"    genotypes of customized chromosomes and handles sex chromosomes\n"
		"    properly, according to offspring sex and ploidy.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MendelianGenoTransmitter", (PyCFunction)_wrap_delete_MendelianGenoTransmitter, METH_O, NULL},
	 { (char *)"MendelianGenoTransmitter_swigregister", MendelianGenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"MendelianGenoTransmitter_swiginit", MendelianGenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_SelfingGenoTransmitter", (PyCFunction) _wrap_new_SelfingGenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    SelfingGenoTransmitter(output=\"\", begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a self-fertilization genotype transmitter that transmits\n"
		"    genotypes of a parent to an offspring through self-fertilization.\n"
		"    Cutsomized chromosomes are not handled. Parameters subPops and\n"
		"    infoFields are ignored. This operator also copies allelic lineage\n"
		"    when it is executed in a module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SelfingGenoTransmitter", (PyCFunction)_wrap_delete_SelfingGenoTransmitter, METH_O, NULL},
	 { (char *)"SelfingGenoTransmitter_swigregister", SelfingGenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"SelfingGenoTransmitter_swiginit", SelfingGenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_HaplodiploidGenoTransmitter", (PyCFunction) _wrap_new_HaplodiploidGenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    HaplodiploidGenoTransmitter(output=\"\", begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a haplodiploid genotype transmitter (during-mating\n"
		"    operator) that transmit parental genotypes from parents to\n"
		"    offspring in a haplodiploid population. Parameters subPops and\n"
		"    infoFields are ignored. This operator also copies allelic lineage\n"
		"    when it is executed in a module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_HaplodiploidGenoTransmitter", (PyCFunction)_wrap_delete_HaplodiploidGenoTransmitter, METH_O, NULL},
	 { (char *)"HaplodiploidGenoTransmitter_swigregister", HaplodiploidGenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"HaplodiploidGenoTransmitter_swiginit", HaplodiploidGenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MitochondrialGenoTransmitter", (PyCFunction) _wrap_new_MitochondrialGenoTransmitter, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MitochondrialGenoTransmitter(output=\"\", chroms=ALL_AVAIL,\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Createa a mitochondrial genotype transmitter that treats the\n"
		"    Mitochondiral chromosome, or Customized chromosomes if no\n"
		"    Mitochondrial chromosome is specified, or a list of chromosomes\n"
		"    specified by chroms, as human mitochondrial chromosomes. These\n"
		"    chromosomes should have the same length and the same number of\n"
		"    loci. This operator transmits these chromosomes randomly from the\n"
		"    female parent to offspring of both sexes. It also copies allelic\n"
		"    lineage when it is executed in a module with lineage allele type.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MitochondrialGenoTransmitter", (PyCFunction)_wrap_delete_MitochondrialGenoTransmitter, METH_O, NULL},
	 { (char *)"MitochondrialGenoTransmitter_swigregister", MitochondrialGenoTransmitter_swigregister, METH_VARARGS, NULL},
	 { (char *)"MitochondrialGenoTransmitter_swiginit", MitochondrialGenoTransmitter_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Recombinator", (PyCFunction) _wrap_new_Recombinator, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Recombinator(rates=[], intensity=-1, loci=ALL_AVAIL,\n"
		"      convMode=NO_CONVERSION, output=\"\", begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Recombinator (a mendelian genotype transmitter with\n"
		"    recombination and gene conversion) that passes genotypes from\n"
		"    parents (or a parent in case of self-fertilization) to offspring.\n"
		"    Recombination happens by default between all adjacent markers but\n"
		"    can be limited to a given set of loci, which can be a list of loci\n"
		"    indexes, names, list of chromosome position pairs, ALL_AVAIL, or a\n"
		"    function with optional parameter pop that will be called at each\n"
		"    ganeeration to determine indexes of loci. Each locus in this list\n"
		"    specifies a recombination point between the locus and the locus\n"
		"    immediately after it. Loci that are the last locus on each\n"
		"    chromosome are ignored.  If a single recombination rate (parameter\n"
		"    rates) is specified, it will used for all loci (all loci or loci\n"
		"    specified by parameter loci), regardless of physical distances\n"
		"    between adjacent loci.  If a list of recombination rates are\n"
		"    specified in rates, different recombination rates could be applied\n"
		"    after a list of specified loci (between loci and their immediate\n"
		"    neighbor to the right). The loci should be specified by parameter\n"
		"    loci as a list with the same length as rates, or ALL_AVAIL\n"
		"    (default) in which case the length of rates should equal to the\n"
		"    total number of loci. Note that recombination rates specified for\n"
		"    the last locus on each chromosome are ignored because simuPOP\n"
		"    assumes free recombination between chromosomes.  A recombination\n"
		"    intensity (intensity) can be used to specify recombination rates\n"
		"    that are proportional to physical distances between adjacent\n"
		"    markers. If the physical distance between two markers is d, the\n"
		"    recombination rate between them will be intensity * d. No unit is\n"
		"    assume for loci position and recombination intensity.  Gene\n"
		"    conversion is controlled using parameter convMode, which can be\n"
		"    *   NoConversion: no gene conversion (default).\n"
		"    *   (NUM_MARKERS, prob, n): With probability prob, convert a fixed\n"
		"    number (n) of markers if a recombination event happens.\n"
		"    *   (GEOMETRIC_DISTRIBUTION, prob, p): With probability prob,\n"
		"    convert a random number of markers if a recombination event\n"
		"    happens. The number of markes converted follows a geometric\n"
		"    distribution with probability p.\n"
		"    *   (TRACT_LENGTH, prob, n): With probability prob, convert a\n"
		"    region of fixed tract length (n) if a recombination event happens.\n"
		"    The actual number of markers converted depends on loci positions\n"
		"    of surrounding loci. The starting position of this tract is the\n"
		"    middle of two adjacent markers. For example, if four loci are\n"
		"    located at 0, 1, 2, 3 respectively, a conversion event happens\n"
		"    between 0 and 1, with a tract length 2 will start at 0.5 and end\n"
		"    at 2.5, covering the second and third loci.\n"
		"    *   (EXPONENTIAL_DISTRIBUTION, prob, p): With probability prob,\n"
		"    convert a region of random tract length if a recombination event\n"
		"    happens. The distribution of tract length follows a exponential\n"
		"    distribution with probability p. The actual number of markers\n"
		"    converted depends on loci positions of surrounding loci. simuPOP\n"
		"    uses this probabilistic model of gene conversion because when a\n"
		"    recombination event happens, it may become a recombination event\n"
		"    if the if the Holliday junction is resolved/repaired successfully,\n"
		"    or a conversion event if the junction is not resolved/repaired.\n"
		"    The probability, however, is more commonly denoted by the ratio of\n"
		"    conversion to recombination events in the literature. This ratio\n"
		"    varies greatly from study to study, ranging from 0.1 to 15 (Chen\n"
		"    et al, Nature Review Genetics, 2007). This translate to\n"
		"    0.1/0.9~0.1 to 15/16~0.94 of the gene conversion probability.  A\n"
		"    Recombinator usually does not send any output. However, if an\n"
		"    information field is given (parameter infoFields), this operator\n"
		"    will treat this information field as an unique ID of parents and\n"
		"    offspring and output all recombination events in the format of\n"
		"    offspring_id parent_id starting_ploidy loc1 loc2 ... where\n"
		"    starting_ploidy indicates which homologous copy genotype\n"
		"    replication starts from (0 or 1), loc1, loc2 etc are loci after\n"
		"    which recombination events happens. If there are multiple\n"
		"    chromosomes on the genome, you will see a lot of (fake)\n"
		"    recombination events because of independent segregation of\n"
		"    chromosomes. Such a record will be generated for each set of\n"
		"    homologous chromosomes so an diploid offspring will have two lines\n"
		"    of output. Note that individual IDs need to be set (using a\n"
		"    IdTagger operator) before this Recombinator is applied.  In\n"
		"    addition to genotypes, this operator also copies alleleic lineage\n"
		"    if it is executed in a module with lineage allele type.\n"
		"\n"
		"Note:\n"
		"\n"
		"    There is no recombination between sex chromosomes (Chromosomes X\n"
		"    and Y), although recombination is possible between pesudoautosomal\n"
		"    regions on these chromosomes. If such a feature is required, you\n"
		"    will have to simulate the pesudoautosomal regions as separate\n"
		"    chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Recombinator", (PyCFunction)_wrap_delete_Recombinator, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~Recombinator()\n"
		"\n"
		"\n"
		""},
	 { (char *)"Recombinator_transmitGenotype", (PyCFunction) _wrap_Recombinator_transmitGenotype, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.transmitGenotype(parent, offspring, ploidy)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function transmits genotypes from a parent to the ploidy-th\n"
		"    homologous set of chromosomes of an offspring. It can be used, for\n"
		"    example, by a customized genotype transmitter to use sex-specific\n"
		"    recombination rates to transmit parental genotypes to offspring.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Recombinator_swigregister", Recombinator_swigregister, METH_VARARGS, NULL},
	 { (char *)"Recombinator_swiginit", Recombinator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MutSpaceRecombinator", (PyCFunction) _wrap_new_MutSpaceRecombinator, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_MutSpaceRecombinator", (PyCFunction)_wrap_delete_MutSpaceRecombinator, METH_O, NULL},
	 { (char *)"MutSpaceRecombinator_swigregister", MutSpaceRecombinator_swigregister, METH_VARARGS, NULL},
	 { (char *)"MutSpaceRecombinator_swiginit", MutSpaceRecombinator_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_BaseSelector", (PyCFunction) _wrap_new_BaseSelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BaseSelector(output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a base selector object. This operator should not be created\n"
		"    directly.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BaseSelector", (PyCFunction)_wrap_delete_BaseSelector, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BaseSelector()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseSelector_swigregister", BaseSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"BaseSelector_swiginit", BaseSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MapSelector", (PyCFunction) _wrap_new_MapSelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MapSelector(loci, fitness, begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a selector that assigns individual fitness values using a\n"
		"    dictionary fitness with genotype at loci as keys, and fitness as\n"
		"    values. Parameter loci can be a list of indexes, loci names, list\n"
		"    of chromosome position pairs, ALL_AVAIL, or a function with\n"
		"    optional parameter pop that will be called at each ganeeration to\n"
		"    determine indexes of loci. For each individual (parents if this\n"
		"    operator is applied before mating, and offspring if this operator\n"
		"    is applied during mating), genotypes at loci are collected one by\n"
		"    one (e.g. p0_loc0, p1_loc0, p0_loc1, p1_loc1... for a diploid\n"
		"    individual, with number of alleles varying for sex and\n"
		"    mitochondrial DNAs) and are looked up in the dictionary. If a\n"
		"    genotype cannot be found, it will be looked up again without phase\n"
		"    information (e.g. (1,0) will match key (0,1)). If the genotype\n"
		"    still can not be found, a ValueError will be raised. This operator\n"
		"    supports sex chromosomes and haplodiploid populations. In these\n"
		"    cases, only valid genotypes should be used to generator the\n"
		"    dictionary keys.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MapSelector", (PyCFunction)_wrap_delete_MapSelector, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MapSelector()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MapSelector_swigregister", MapSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"MapSelector_swiginit", MapSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MaSelector", (PyCFunction) _wrap_new_MaSelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MaSelector(loci, fitness, wildtype=0, begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a multi-allele selector that groups multiple alleles into\n"
		"    a wildtype group (with alleles wildtype, default to [0]), and a\n"
		"    non-wildtype group. A list of fitness values is specified through\n"
		"    parameter fitness, for genotypes at one or more loci. Parameter\n"
		"    loci can be a list of indexes, loci names , list of chromosome\n"
		"    position pairs, ALL_AVAIL, or a function with optional parameter\n"
		"    pop that will be called at each ganeeration to determine indexes\n"
		"    of loci. If we denote wildtype alleles using capital letters A, B\n"
		"    ... and non-wildtype alleles using small letters a, b ..., the\n"
		"    fitness values should be for\n"
		"    *   genotypes A and a for the haploid single-locus case,\n"
		"    *   genotypes AB, Ab, aB and bb for haploid two=locus cases,\n"
		"    *   genotypes AA, Aa and aa for diploid single-locus cases,\n"
		"    *   genotypes AABB, AABb, AAbb, AaBB, AaBb, Aabb, aaBB, aaBb, and\n"
		"    aabb for diploid two-locus cases,\n"
		"    *   and in general 2**n for diploid and 3**n for haploid cases if\n"
		"    there are n loci. This operator does not support haplodiploid\n"
		"    populations, sex and mitochondrial chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MaSelector", (PyCFunction)_wrap_delete_MaSelector, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MaSelector()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MaSelector_swigregister", MaSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"MaSelector_swiginit", MaSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MlSelector", (PyCFunction) _wrap_new_MlSelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MlSelector(ops, mode=MULTIPLICATIVE, begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a multiple-locus selector from a list selection operator\n"
		"    selectors. When this operator is applied to an individual (parents\n"
		"    when used before mating and offspring when used during mating), it\n"
		"    applies these operators to the individual and obtain a list of\n"
		"    (usually single-locus) fitness values. These fitness values are\n"
		"    combined to a single fitness value using\n"
		"    *   Prod(f_i), namely the product of individual fitness if mode =\n"
		"    MULTIPLICATIVE,\n"
		"    *   1-sum(1 - f_i) if mode = ADDITIVE,\n"
		"    *   1-Prod(1 - f_i) if mode = HETEROGENEITY, and\n"
		"    *   exp(- sum(1 - f_i)) if mode = EXPONENTIAL, zero will be\n"
		"    returned if the combined fitness value is less than zero.\n"
		"    Applicability parameters (begin, end, step, at, reps, subPops)\n"
		"    could be used in both MlSelector and selectors in parameter ops,\n"
		"    but parameters in MlSelector will be interpreted first.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MlSelector", (PyCFunction)_wrap_delete_MlSelector, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MlSelector()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MlSelector_swigregister", MlSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"MlSelector_swiginit", MlSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PySelector", (PyCFunction) _wrap_new_PySelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PySelector(func, loci=[], begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, output=\"\", subPops=ALL_AVAIL,\n"
		"      infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Python hybrid selector that passes genotype at specified\n"
		"    loci, values at specified information fields (if requested) and a\n"
		"    generation number to a user-defined function func. The return\n"
		"    value will be treated as individual fitness.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PySelector", (PyCFunction)_wrap_delete_PySelector, METH_O, NULL},
	 { (char *)"PySelector_swigregister", PySelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"PySelector_swiginit", PySelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyMlSelector", (PyCFunction) _wrap_new_PyMlSelector, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyMlSelector(func, mode=EXPONENTIAL, loci=ALL_AVAIL, output=\"\",\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a selector that assigns individual fitness values by\n"
		"    combining locus-specific fitness values that are determined by a\n"
		"    Python call-back function. The callback function accepts parameter\n"
		"    loc, alleles (both optional) and returns location- or genotype-\n"
		"    specific fitness values that can be constant or random. The\n"
		"    fitness values for each genotype will be cached so the same\n"
		"    fitness values will be assigned to genotypes with previously\n"
		"    assigned values. Note that a function that does not examine the\n"
		"    genotype naturally assumes a dominant model where genotypes with\n"
		"    one or two mutants have the same fitness effect. Because genotypes\n"
		"    at a locus are passed separately and in no particular order, this\n"
		"    function is also responsible for assigning consistent fitness\n"
		"    values for genotypes at the same locus (a class is usually used).\n"
		"    This operator currently ignores chromosome types so unused alleles\n"
		"    will be passed for loci on sex or mitochondrial chromosomes. It\n"
		"    also ignores phase of genotype so it will use the same fitness\n"
		"    value for genotype (a,b) and (b,a).   Individual fitness will be\n"
		"    combined in ADDITIVE, MULTIPLICATIVE, HETEROGENEITY, or\n"
		"    EXPONENTIAL mode from fitness values of loci with at least one\n"
		"    non-zero allele (See MlSelector for details). If an output is\n"
		"    given, location, genotype, fitness and generation at which the new\n"
		"    genotype is assgined the value will be written to the output, in\n"
		"    the format of 'loc a1 a2 fitness gen' for loci on autosomes of\n"
		"    diploid populations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyMlSelector", (PyCFunction)_wrap_delete_PyMlSelector, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyMlSelector()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyMlSelector_swigregister", PyMlSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyMlSelector_swiginit", PyMlSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MutSpaceSelector", (PyCFunction) _wrap_new_MutSpaceSelector, METH_VARARGS | METH_KEYWORDS, NULL},
	 { (char *)"delete_MutSpaceSelector", (PyCFunction)_wrap_delete_MutSpaceSelector, METH_O, NULL},
	 { (char *)"MutSpaceSelector_swigregister", MutSpaceSelector_swigregister, METH_VARARGS, NULL},
	 { (char *)"MutSpaceSelector_swiginit", MutSpaceSelector_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_BaseQuanTrait", (PyCFunction) _wrap_new_BaseQuanTrait, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BaseQuanTrait(ancGens=UNSPECIFIED, begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a base quantitative trait operator. This operator assigns\n"
		"    one or more quantitative traits to trait fields in the present\n"
		"    generation (default). If ALL_AVAIL or a list of ancestral\n"
		"    generations are specified, this operator will be applied to\n"
		"    individuals in these generations as well. A quantitative trait\n"
		"    operator can be applied to specified (virtual) subpopulations\n"
		"    (parameter subPops) and replicates (parameter reps).\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BaseQuanTrait", (PyCFunction)_wrap_delete_BaseQuanTrait, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BaseQuanTrait()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BaseQuanTrait_swigregister", BaseQuanTrait_swigregister, METH_VARARGS, NULL},
	 { (char *)"BaseQuanTrait_swiginit", BaseQuanTrait_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyQuanTrait", (PyCFunction) _wrap_new_PyQuanTrait, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyQuanTrait(func, loci=[], ancGens=UNSPECIFIED, begin=0, end=-1,\n"
		"      step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Python hybrid quantitative trait operator that passes\n"
		"    genotype at specified loci, optional values at specified\n"
		"    information fields (if requested), and an optional generation\n"
		"    number to a user-defined function func. Parameter loci can be a\n"
		"    list of loci indexes, names, or ALL_AVAIL. The return value will\n"
		"    be assigned to specified trait fields (infoField). If only one\n"
		"    trait field is specified, a number or a sequence of one element is\n"
		"    acceptable. Otherwise, a sequence of values will be accepted and\n"
		"    be assigned to each trait field.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyQuanTrait", (PyCFunction)_wrap_delete_PyQuanTrait, METH_O, NULL},
	 { (char *)"PyQuanTrait_swigregister", PyQuanTrait_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyQuanTrait_swiginit", PyQuanTrait_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_BasePenetrance", (PyCFunction) _wrap_new_BasePenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    BasePenetrance(ancGens=UNSPECIFIED, begin=0, end=-1, step=1,\n"
		"      at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a base penetrance operator. This operator assign individual\n"
		"    affection status in the present generation (default). If ALL_AVAIL\n"
		"    or a list of ancestral generations are spcified in parameter\n"
		"    ancGens, individuals in specified ancestral generations will be\n"
		"    processed. A penetrance operator can be applied to specified\n"
		"    (virtual) subpopulations (parameter subPops) and replicates\n"
		"    (parameter reps). If an informatio field is given, penetrance\n"
		"    value will be stored in this information field of each individual.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_BasePenetrance", (PyCFunction)_wrap_delete_BasePenetrance, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Description:\n"
		"\n"
		"    destructor\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~BasePenetrance()\n"
		"\n"
		"\n"
		""},
	 { (char *)"BasePenetrance_applyToIndividual", (PyCFunction) _wrap_BasePenetrance_applyToIndividual, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.applyToIndividual(ind, pop=None)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Apply the penetrance operator to a single individual ind and set\n"
		"    his or her affection status. A population reference can be passed\n"
		"    if the penetrance model depends on population properties such as\n"
		"    generation number. This function returns the affection status.\n"
		"\n"
		"\n"
		""},
	 { (char *)"BasePenetrance_swigregister", BasePenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"BasePenetrance_swiginit", BasePenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MapPenetrance", (PyCFunction) _wrap_new_MapPenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MapPenetrance(loci, penetrance, ancGens=UNSPECIFIED, begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a penetrance operator that get penetrance value from a\n"
		"    dictionary penetrance with genotype at loci as keys, and\n"
		"    penetrance as values. For each individual, genotypes at loci are\n"
		"    collected one by one (e.g. p0_loc0, p1_loc0, p0_loc1, p1_loc1...\n"
		"    for a diploid individual) and are looked up in the dictionary.\n"
		"    Parameter loci can be a list of loci indexes, names, list of\n"
		"    chromosome position pairs, ALL_AVAIL, or a function with optional\n"
		"    parameter pop that will be called at each ganeeration to determine\n"
		"    indexes of loci. If a genotype cannot be found, it will be looked\n"
		"    up again without phase information (e.g. (1,0) will match key\n"
		"    (0,1)). If the genotype still can not be found, a ValueError will\n"
		"    be raised. This operator supports sex chromosomes and haplodiploid\n"
		"    populations. In these cases, only valid genotypes should be used\n"
		"    to generator the dictionary keys.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MapPenetrance", (PyCFunction)_wrap_delete_MapPenetrance, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MapPenetrance()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MapPenetrance_swigregister", MapPenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"MapPenetrance_swiginit", MapPenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MaPenetrance", (PyCFunction) _wrap_new_MaPenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MaPenetrance(loci, penetrance, wildtype=0, ancGens=UNSPECIFIED,\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Creates a multi-allele penetrance operator that groups multiple\n"
		"    alleles into a wildtype group (with alleles wildtype, default to\n"
		"    [0]), and a non-wildtype group. A list of penetrance values is\n"
		"    specified through parameter penetrance, for genotypes at one or\n"
		"    more loci. Parameter loci can be a list of loci indexes, names,\n"
		"    list of chromosome position pairs, ALL_AVAIL, or a function with\n"
		"    optional parameter pop that will be called at each ganeeration to\n"
		"    determine indexes of loci. If we denote wildtype alleles using\n"
		"    capital letters A, B ... and non-wildtype alleles using small\n"
		"    letters a, b ..., the penetrance values should be for\n"
		"    *   genotypes A and a for the haploid single-locus case,\n"
		"    *   genotypes AB, Ab, aB and bb for haploid two=locus cases,\n"
		"    *   genotypes AA, Aa and aa for diploid single-locus cases,\n"
		"    *   genotypes AABB, AABb, AAbb, AaBB, AaBb, Aabb, aaBB, aaBb, and\n"
		"    aabb for diploid two-locus cases,\n"
		"    *   and in general 2**n for diploid and 3**n for haploid cases if\n"
		"    there are n loci. This operator does not support haplodiploid\n"
		"    populations and sex chromosomes.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MaPenetrance", (PyCFunction)_wrap_delete_MaPenetrance, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MaPenetrance()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MaPenetrance_swigregister", MaPenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"MaPenetrance_swiginit", MaPenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_MlPenetrance", (PyCFunction) _wrap_new_MlPenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    MlPenetrance(ops, mode=MULTIPLICATIVE, ancGens=UNSPECIFIED,\n"
		"      begin=0, end=-1, step=1, at=[], reps=ALL_AVAIL,\n"
		"      subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a multiple-locus penetrance operator from a list penetrance\n"
		"    operator ops. When this operator is applied to an individual\n"
		"    (parents when used before mating and offspring when used during\n"
		"    mating), it applies these operators to the individual and obtain a\n"
		"    list of (usually single-locus) penetrance values. These penetrance\n"
		"    values are combined to a single penetrance value using\n"
		"    *   Prod(f_i), namely the product of individual penetrance if mode\n"
		"    = MULTIPLICATIVE,\n"
		"    *   sum(f_i) if mode = ADDITIVE, and\n"
		"    *   1-Prod(1 - f_i) if mode = HETEROGENEITY 0 or 1 will be\n"
		"    returned if the combined penetrance value is less than zero or\n"
		"    greater than 1.  Applicability parameters (begin, end, step, at,\n"
		"    reps, subPops) could be used in both MlSelector and selectors in\n"
		"    parameter ops, but parameters in MlSelector will be interpreted\n"
		"    first.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_MlPenetrance", (PyCFunction)_wrap_delete_MlPenetrance, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~MlPenetrance()\n"
		"\n"
		"\n"
		""},
	 { (char *)"MlPenetrance_swigregister", MlPenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"MlPenetrance_swiginit", MlPenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyPenetrance", (PyCFunction) _wrap_new_PyPenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyPenetrance(func, loci=[], ancGens=UNSPECIFIED, begin=0,\n"
		"      end=-1, step=1, at=[], reps=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a Python hybrid penetrance operator that passes genotype at\n"
		"    specified loci, values at specified information fields (if\n"
		"    requested), and a generation number to a user-defined function\n"
		"    func. Parameter loci can be a list of loci indexes, names, list of\n"
		"    chromosome position pairs, ALL_AVAIL, or a function with optional\n"
		"    parameter pop that will be called at each ganeeration to determine\n"
		"    indexes of loci. The return value will be treated as Individual\n"
		"    penetrance.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyPenetrance", (PyCFunction)_wrap_delete_PyPenetrance, METH_O, NULL},
	 { (char *)"PyPenetrance_swigregister", PyPenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyPenetrance_swiginit", PyPenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_PyMlPenetrance", (PyCFunction) _wrap_new_PyMlPenetrance, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    PyMlPenetrance(func, mode=MULTIPLICATIVE, loci=ALL_AVAIL,\n"
		"      ancGens=UNSPECIFIED, output=\"\", begin=0, end=-1, step=1, at=[],\n"
		"      reps=ALL_AVAIL, subPops=ALL_AVAIL, infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a penetrance operator that assigns individual affection\n"
		"    status according to penetrance values combined from locus-specific\n"
		"    penetrance values that are determined by a Python call-back\n"
		"    function. The callback function accepts parameter loc, alleles\n"
		"    (both optional) and returns location- or genotype-specific\n"
		"    penetrance values that can be constant or random. The penetrance\n"
		"    values for each genotype will be cached so the same penetrance\n"
		"    values will be assigned to genotypes with previously assigned\n"
		"    values. Note that a function that does not examine the genotype\n"
		"    naturally assumes a dominant model where genotypes with one or two\n"
		"    mutants have the same penetrance value. Because genotypes at a\n"
		"    locus are passed separately and in no particular order, this\n"
		"    function is also responsible for assigning consistent fitness\n"
		"    values for genotypes at the same locus (a class is usually used).\n"
		"    This operator currently ignores chromosome types so unused alleles\n"
		"    will be passed for loci on sex or mitochondrial chromosomes. This\n"
		"    operator also ignores the phase of genotype so genotypes (a,b) and\n"
		"    (b,a) are assumed to have the same fitness effect.   Individual\n"
		"    penetrance will be combined in ADDITIVE, MULTIPLICATIVE, or\n"
		"    HETEROGENEITY mode from penetrance values of loci with at least\n"
		"    one non-zero allele (See MlPenetrance for details).\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_PyMlPenetrance", (PyCFunction)_wrap_delete_PyMlPenetrance, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.~PyMlPenetrance()\n"
		"\n"
		"\n"
		""},
	 { (char *)"PyMlPenetrance_swigregister", PyMlPenetrance_swigregister, METH_VARARGS, NULL},
	 { (char *)"PyMlPenetrance_swiginit", PyMlPenetrance_swiginit, METH_VARARGS, NULL},
	 { (char *)"new_Pedigree", (PyCFunction) _wrap_new_Pedigree, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    Pedigree(pop, loci=[], infoFields=[], ancGens=ALL_AVAIL,\n"
		"      idField=\"ind_id\", fatherField=\"father_id\",\n"
		"      motherField=\"mother_id\", stealPop=False)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a pedigree object from a population, using a subset of loci\n"
		"    (parameter loci, can be a list of loci indexes, names, or\n"
		"    ALL_AVAIL, default to no locus), information fields (parameter\n"
		"    infoFields, default to no information field besides idField,\n"
		"    fatherField and motherField), and ancestral generations (parameter\n"
		"    ancGens, default to all ancestral generations). By default,\n"
		"    information field father_id (parameter fatherField) and mother_id\n"
		"    (parameter motherField) are used to locate parents identified by\n"
		"    ind_id (parameter idField), which should store an unique ID for\n"
		"    all individuals. Multiple individuls with the same ID are allowed\n"
		"    and will be considered as the same individual, but a warning will\n"
		"    be given if they actually differ in genotype or information\n"
		"    fields. Operators IdTagger and PedigreeTagger are usually used to\n"
		"    assign such IDs, although function sampling.indexToID could be\n"
		"    used to assign unique IDs and construct parental IDs from index\n"
		"    based relationship recorded by operator ParentsTagger. A pedigree\n"
		"    object could be constructed with one or no parent but certain\n"
		"    functions such as relative tracking will not be available for such\n"
		"    pedigrees. In case that your are no longer using your population\n"
		"    object, you could steal the content from the population by setting\n"
		"    stealPop to True.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_clone", (PyCFunction)_wrap_Pedigree_clone, METH_O, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.clone()\n"
		"\n"
		"Details:\n"
		"\n"
		"    Create a cloned copy of a Pedigree.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_save", (PyCFunction) _wrap_Pedigree_save, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.save(filename, infoFields=[], loci=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Save a pedigree to file filename. This function goes through all\n"
		"    individuals of a pedigree and outputs in each line the ID of\n"
		"    individual, IDs of his or her parents, sex ('M' or 'F'), affection\n"
		"    status ('A' or 'U'), values of specified information fields\n"
		"    infoFields and genotypes at specified loci (parameter loci, which\n"
		"    can be a list of loci indexes, names, or ALL_AVAIL). Allele\n"
		"    numbers, instead of their names are outputed. Two columns are used\n"
		"    for each locus if the population is diploid. This file can be\n"
		"    loaded using function loadPedigree although additional information\n"
		"    such as names of information fields need to be specified. This\n"
		"    format differs from a .ped file used in some genetic analysis\n"
		"    software in that there is no family ID and IDs of all individuals\n"
		"    have to be unique. Note that parental IDs will be set to zero if\n"
		"    the parent is not in the pedigree object. Therefore, the parents\n"
		"    of individuals in the top-most ancestral generation will always be\n"
		"    zero.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_indByID", (PyCFunction) _wrap_Pedigree_indByID, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.indByID(id)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a reference to individual with id. An IndexError will be\n"
		"    raised if no individual with id is found. An float id is\n"
		"    acceptable as long as it rounds closely to an integer.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_numParents", (PyCFunction)_wrap_Pedigree_numParents, METH_O, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_locateRelatives", (PyCFunction) _wrap_Pedigree_locateRelatives, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.locateRelatives(relType, resultFields=[], sex=ANY_SEX,\n"
		"      affectionStatus=ANY_AFFECTION_STATUS, ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function locates relatives (of type relType) of each\n"
		"    individual and store their IDs in information fields relFields.\n"
		"    The length of relFields determines how many relatives an\n"
		"    individual can have.  Parameter relType specifies what type of\n"
		"    relative to locate, which can be\n"
		"    *   SPOUSE locate spouses with whom an individual has at least one\n"
		"    common offspring.\n"
		"    *   OUTBRED_SPOUSE locate non-slibling spouses, namely spouses\n"
		"    with no shared parent.\n"
		"    *   OFFSPRING all offspring of each individual.\n"
		"    *   COMMON_OFFSPRING common offspring between each individual and\n"
		"    its spouse (located by SPOUSE or OUTBRED_SPOUSE). relFields should\n"
		"    consist of an information field for spouse and m-1 fields for\n"
		"    offspring where m is the number of fields.\n"
		"    *   FULLSIBLING siblings with common father and mother,\n"
		"    *   SIBLING siblings with at least one common parent. Optionally,\n"
		"    you can specify the sex and affection status of relatives you\n"
		"    would like to locate, using parameters sex and affectionStatus.\n"
		"    sex can be ANY_SEX (default), MALE_ONLY, FEMALE_ONLY, SAME_SEX or\n"
		"    OPPOSITE_SEX, and affectionStatus can be AFFECTED, UNAFFECTED or\n"
		"    ANY_AFFECTION_STATUS (default). Only relatives with specified\n"
		"    properties will be located.  This function will by default go\n"
		"    through all ancestral generations and locate relatives for all\n"
		"    individuals. This can be changed by setting parameter ancGens to\n"
		"    certain ancestral generations you would like to process.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_traceRelatives", (PyCFunction) _wrap_Pedigree_traceRelatives, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.traceRelatives(fieldPath, sex=[], affectionStatus=[],\n"
		"      resultFields=[], ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Trace a relative path in a population and record the result in the\n"
		"    given information fields resultFields. This function is used to\n"
		"    locate more distant relatives based on the relatives located by\n"
		"    function locateRelatives. For example, after siblings and\n"
		"    offspring of all individuals are located, you can locate mother's\n"
		"    sibling's offspring using a relative path, and save their indexes\n"
		"    in each individuals information fields resultFields.  A relative\n"
		"    path consits of a fieldPath that specifies which information\n"
		"    fields to look for at each step, a sex specifies sex choices at\n"
		"    each generation, and a affectionStatus that specifies affection\n"
		"    status at each generation. fieldPath should be a list of\n"
		"    information fields, sex and affectionStatus are optional. If\n"
		"    specified, they should be a list of ANY_SEX, MALE_ONLY,\n"
		"    FEMALE_ONLY, SAME_SEX and OppsiteSex for parameter sex, and a list\n"
		"    of UNAFFECTED, AFFECTED and ANY_AFFECTION_STATUS for parameter\n"
		"    affectionStatus.  For example, if fieldPath = [['father_id',\n"
		"    'mother_id'], ['sib1', 'sib2'], ['off1', 'off2']], and sex =\n"
		"    [ANY_SEX, MALE_ONLY, FEMALE_ONLY], this function will locate\n"
		"    father_id and mother_id for each individual, find all individuals\n"
		"    referred by father_id and mother_id, find informaton fields sib1\n"
		"    and sib2 from these parents and locate male individuals referred\n"
		"    by these two information fields. Finally, the information fields\n"
		"    off1 and off2 from these siblings are located and are used to\n"
		"    locate their female offspring. The results are father or mother's\n"
		"    brother's daughters. Their indexes will be saved in each\n"
		"    individuals information fields resultFields. If a list of\n"
		"    ancestral generations is given in parameter ancGens is given, only\n"
		"    individuals in these ancestral generations will be processed.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_individualsWithRelatives", (PyCFunction) _wrap_Pedigree_individualsWithRelatives, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.individualsWithRelatives(infoFields, sex=[],\n"
		"      affectionStatus=[], subPops=ALL_AVAIL, ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    Return a list of IDs of individuals who have non-negative values\n"
		"    at information fields infoFields. Additional requirements could be\n"
		"    specified by parameters sex and affectionStatus. sex can be\n"
		"    ANY_SEX (default), MALE_ONLY, FEMALE_ONLY, SAME_SEX or\n"
		"    OPPOSITE_SEX, and affectionStatus can be AFFECTED, UNAFFECTED or\n"
		"    ANY_AFFECTION_STATUS (default). This function by default check all\n"
		"    individuals in all ancestral generations, but you could limit the\n"
		"    search using parameter subPops (a list of (virtual)\n"
		"    subpopulations) and ancestral generations ancGens. Relatives fall\n"
		"    out of specified subpopulations and ancestral generaions will be\n"
		"    considered invalid.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_identifyFamilies", (PyCFunction) _wrap_Pedigree_identifyFamilies, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.identifyFamilies(pedField=\"\", subPops=ALL_AVAIL,\n"
		"      ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function goes through all individuals in a pedigree and group\n"
		"    related individuals into families. If an information field\n"
		"    pedField is given, indexes of families will be assigned to this\n"
		"    field of each family member. The return value is a list of family\n"
		"    sizes corresponding to families 0, 1, 2, ... etc. If a list of\n"
		"    (virtual) subpopulations (parameter subPops) or ancestral\n"
		"    generations are specified (parameter ancGens), the search will be\n"
		"    limited to individuals in these subpopulations and generations.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_identifyAncestors", (PyCFunction) _wrap_Pedigree_identifyAncestors, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.identifyAncestors(IDs=ALL_AVAIL, subPops=ALL_AVAIL,\n"
		"      ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    If a list of individuals (IDs) is given, this function traces\n"
		"    backward in time and find all ancestors of these individuals. If\n"
		"    IDs is ALL_AVAIL, ancestors of all individuals in the present\n"
		"    generation will be located. If a list of (virtual) subpopulations\n"
		"    (subPops) or ancestral geneartions (ancGens) is given, the search\n"
		"    will be limited to individuals in these subpopulations and\n"
		"    generations. This could be used to, for example, find all fathers\n"
		"    of IDs. This function returns a list of IDs, which includes valid\n"
		"    specified IDs. Invalid IDs will be silently ignored. Note that\n"
		"    parameters subPops and ancGens will limit starting IDs if IDs is\n"
		"    set to ALL_AVAIL, but specified IDs will not be trimmed according\n"
		"    to these parameters.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_identifyOffspring", (PyCFunction) _wrap_Pedigree_identifyOffspring, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    x.identifyOffspring(IDs=[], subPops=ALL_AVAIL,\n"
		"      ancGens=ALL_AVAIL)\n"
		"\n"
		"Details:\n"
		"\n"
		"    This function traces forward in time and find all offspring of\n"
		"    individuals specified in parameter IDs. If a list of (virtual)\n"
		"    subpopulations (subPops) or ancestral geneartions (ancGens) is\n"
		"    given, the search will be limited to individuals in these\n"
		"    subpopulations and generations. This could be used to, for\n"
		"    example, find all male offspring of IDs. This function returns a\n"
		"    list of IDs, which includes valid starting IDs. Invalid IDs are\n"
		"    silently ignored. Note that parameters subPops and ancGens will\n"
		"    limit search result but will not be used to trim specified IDs.\n"
		"\n"
		"\n"
		""},
	 { (char *)"Pedigree_removeIndividuals", (PyCFunction) _wrap_Pedigree_removeIndividuals, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_removeSubPops", (PyCFunction) _wrap_Pedigree_removeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_push", (PyCFunction) _wrap_Pedigree_push, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_addChrom", (PyCFunction) _wrap_Pedigree_addChrom, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_addChromFrom", (PyCFunction) _wrap_Pedigree_addChromFrom, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_addIndFrom", (PyCFunction) _wrap_Pedigree_addIndFrom, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_mergeSubPops", (PyCFunction) _wrap_Pedigree_mergeSubPops, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_resize", (PyCFunction) _wrap_Pedigree_resize, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"Pedigree_setSubPopByIndInfo", (PyCFunction) _wrap_Pedigree_setSubPopByIndInfo, METH_VARARGS | METH_KEYWORDS, (char *)"Obsolete or undocumented function."},
	 { (char *)"delete_Pedigree", (PyCFunction)_wrap_delete_Pedigree, METH_O, NULL},
	 { (char *)"Pedigree_swigregister", Pedigree_swigregister, METH_VARARGS, NULL},
	 { (char *)"Pedigree_swiginit", Pedigree_swiginit, METH_VARARGS, NULL},
	 { (char *)"loadPedigree", (PyCFunction) _wrap_loadPedigree, METH_VARARGS | METH_KEYWORDS, (char *)"\n"
		"\n"
		"\n"
		"Usage:\n"
		"\n"
		"    loadPedigree(file, idField=\"ind_id\", fatherField=\"father_id\",\n"
		"      motherField=\"mother_id\", ploidy=2, loci=[], chromTypes=[],\n"
		"      lociPos=[], chromNames=[], alleleNames=[], lociNames=[],\n"
		"      subPopNames=[], infoFields=[])\n"
		"\n"
		"Details:\n"
		"\n"
		"    Load a pedigree from a file saved by operator PedigreeTagger or\n"
		"    function Pedigree.save. This file contains the ID of each\n"
		"    offspring and their parent(s) and optionally sex ('M' or 'F'),\n"
		"    affection status ('A' or 'U'), values of information fields and\n"
		"    genotype at some loci. IDs of each individual and their parents\n"
		"    are loaded to information fields idField, fatherField and\n"
		"    motherField. Only numeric IDs are allowed, and individual IDs must\n"
		"    be unique across all generations.  Because this file does not\n"
		"    contain generation information, generations to which offspring\n"
		"    belong are determined by the parent-offspring relationships.\n"
		"    Individuals without parents are assumed to be in the top-most\n"
		"    ancestral generation. This is the case for individuals in the top-\n"
		"    most ancestral generation if the file is saved by function\n"
		"    Pedigree.save(), and for individuals who only appear as another\n"
		"    individual's parent, if the file is saved by operator\n"
		"    PedigreeTagger. The order at which offsprng is specified is not\n"
		"    important because this function essentially creates a top-most\n"
		"    ancestral generation using IDs without parents, and creates the\n"
		"    next generation using offspring of these parents, and so on until\n"
		"    all generations are recreated. That is to say, if you have a\n"
		"    mixture of pedigrees with different generations, they will be\n"
		"    lined up from the top most ancestral generation.  If individual\n"
		"    sex is not specified, sex of of parents are determined by their\n"
		"    parental roles (father or mother) but the sex of individuals in\n"
		"    the last generation can not be determined so they will all be\n"
		"    males. If additional information fields are given, their names\n"
		"    have to be specified using parameter infoFields. The rest of the\n"
		"    columns are assued to be alleles, arranged ploidy consecutive\n"
		"    columns for each locus. If paraemter loci is not specified, the\n"
		"    number of loci is calculated by number of columns divided by\n"
		"    ploidy (default to 2). All loci are assumed to be on one\n"
		"    chromosome unless parameter loci is used to specified number of\n"
		"    loci on each chromosome. Additional parameters such as ploidy,\n"
		"    chromTypes, lociPos, chromNames, alleleNames, lociNames could be\n"
		"    used to specified the genotype structured of the loaded pedigree.\n"
		"    Please refer to class Population for details about these\n"
		"    parameters.\n"
		"\n"
		"\n"
		""},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_simuPOP__MapPenetranceTo_p_simuPOP__BasePenetrance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BasePenetrance *)  ((simuPOP::MapPenetrance *) x));
}
static void *_p_simuPOP__MaPenetranceTo_p_simuPOP__BasePenetrance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BasePenetrance *)  ((simuPOP::MaPenetrance *) x));
}
static void *_p_simuPOP__MlPenetranceTo_p_simuPOP__BasePenetrance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BasePenetrance *)  ((simuPOP::MlPenetrance *) x));
}
static void *_p_simuPOP__PyPenetranceTo_p_simuPOP__BasePenetrance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BasePenetrance *)  ((simuPOP::PyPenetrance *) x));
}
static void *_p_simuPOP__PyMlPenetranceTo_p_simuPOP__BasePenetrance(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BasePenetrance *)  ((simuPOP::PyMlPenetrance *) x));
}
static void *_p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__MendelianGenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MendelianGenoTransmitter *)  ((simuPOP::SelfingGenoTransmitter *) x));
}
static void *_p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__MendelianGenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MendelianGenoTransmitter *)  ((simuPOP::HaplodiploidGenoTransmitter *) x));
}
static void *_p_simuPOP__RecombinatorTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *)  ((simuPOP::Recombinator *) x));
}
static void *_p_simuPOP__MutSpaceRecombinatorTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *)  ((simuPOP::MutSpaceRecombinator *) x));
}
static void *_p_simuPOP__CloneGenoTransmitterTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *)  ((simuPOP::CloneGenoTransmitter *) x));
}
static void *_p_simuPOP__MendelianGenoTransmitterTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *)  ((simuPOP::MendelianGenoTransmitter *) x));
}
static void *_p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *) (simuPOP::MendelianGenoTransmitter *) ((simuPOP::SelfingGenoTransmitter *) x));
}
static void *_p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *) (simuPOP::MendelianGenoTransmitter *) ((simuPOP::HaplodiploidGenoTransmitter *) x));
}
static void *_p_simuPOP__MitochondrialGenoTransmitterTo_p_simuPOP__GenoTransmitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoTransmitter *)  ((simuPOP::MitochondrialGenoTransmitter *) x));
}
static void *_p_simuPOP__InitSexTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InitSex *) x));
}
static void *_p_simuPOP__PyEvalTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PyEval *) x));
}
static void *_p_simuPOP__InitGenotypeTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InitGenotype *) x));
}
static void *_p_simuPOP__SavePopulationTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::SavePopulation *) x));
}
static void *_p_simuPOP__RecombinatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *) ((simuPOP::Recombinator *) x));
}
static void *_p_simuPOP__MutSpaceRecombinatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *) ((simuPOP::MutSpaceRecombinator *) x));
}
static void *_p_simuPOP__StatTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::Stat *) x));
}
static void *_p_simuPOP__RevertIfTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::RevertIf *) x));
}
static void *_p_simuPOP__BackwardMigratorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::BackwardMigrator *) x));
}
static void *_p_simuPOP__MigratorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::Migrator *) x));
}
static void *_p_simuPOP__PauseTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::Pause *) x));
}
static void *_p_simuPOP__RevertFixedSitesTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::RevertFixedSites *) x));
}
static void *_p_simuPOP__MutSpaceRevertFixedSitesTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::MutSpaceRevertFixedSites *) x));
}
static void *_p_simuPOP__TerminateIfTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::TerminateIf *) x));
}
static void *_p_simuPOP__DumperTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::Dumper *) x));
}
static void *_p_simuPOP__InheritTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InheritTagger *) x));
}
static void *_p_simuPOP__IdTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::IdTagger *) x));
}
static void *_p_simuPOP__InitLineageTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InitLineage *) x));
}
static void *_p_simuPOP__PyOperatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PyOperator *) x));
}
static void *_p_simuPOP__TicTocTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::TicToc *) x));
}
static void *_p_simuPOP__DiscardIfTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::DiscardIf *) x));
}
static void *_p_simuPOP__ResizeSubPopsTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::ResizeSubPops *) x));
}
static void *_p_simuPOP__MergeSubPopsTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::MergeSubPops *) x));
}
static void *_p_simuPOP__SplitSubPopsTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::SplitSubPops *) x));
}
static void *_p_simuPOP__BasePenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::BasePenetrance *) x));
}
static void *_p_simuPOP__MapPenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BasePenetrance *) ((simuPOP::MapPenetrance *) x));
}
static void *_p_simuPOP__MaPenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BasePenetrance *) ((simuPOP::MaPenetrance *) x));
}
static void *_p_simuPOP__MlPenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BasePenetrance *) ((simuPOP::MlPenetrance *) x));
}
static void *_p_simuPOP__PyPenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BasePenetrance *) ((simuPOP::PyPenetrance *) x));
}
static void *_p_simuPOP__PyMlPenetranceTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BasePenetrance *) ((simuPOP::PyMlPenetrance *) x));
}
static void *_p_simuPOP__InfoExecTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::InfoEval *) ((simuPOP::InfoExec *) x));
}
static void *_p_simuPOP__NoneOpTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::NoneOp *) x));
}
static void *_p_simuPOP__InitInfoTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InitInfo *) x));
}
static void *_p_simuPOP__MatrixMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::MatrixMutator *) x));
}
static void *_p_simuPOP__BaseMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::BaseMutator *) x));
}
static void *_p_simuPOP__PyExecTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::PyEval *) ((simuPOP::PyExec *) x));
}
static void *_p_simuPOP__KAlleleMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::KAlleleMutator *) x));
}
static void *_p_simuPOP__StepwiseMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::StepwiseMutator *) x));
}
static void *_p_simuPOP__PyMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::PyMutator *) x));
}
static void *_p_simuPOP__MixedMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::MixedMutator *) x));
}
static void *_p_simuPOP__ContextMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseMutator *) ((simuPOP::ContextMutator *) x));
}
static void *_p_simuPOP__PointMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PointMutator *) x));
}
static void *_p_simuPOP__FiniteSitesMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::FiniteSitesMutator *) x));
}
static void *_p_simuPOP__MutSpaceMutatorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::MutSpaceMutator *) x));
}
static void *_p_simuPOP__BaseSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::BaseSelector *) x));
}
static void *_p_simuPOP__MapSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::MapSelector *) x));
}
static void *_p_simuPOP__MaSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::MaSelector *) x));
}
static void *_p_simuPOP__MlSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::MlSelector *) x));
}
static void *_p_simuPOP__PySelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::PySelector *) x));
}
static void *_p_simuPOP__PyMlSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::PyMlSelector *) x));
}
static void *_p_simuPOP__MutSpaceSelectorTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseSelector *) ((simuPOP::MutSpaceSelector *) x));
}
static void *_p_simuPOP__GenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::GenoTransmitter *) x));
}
static void *_p_simuPOP__CloneGenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *) ((simuPOP::CloneGenoTransmitter *) x));
}
static void *_p_simuPOP__MendelianGenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *) ((simuPOP::MendelianGenoTransmitter *) x));
}
static void *_p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *)(simuPOP::MendelianGenoTransmitter *) ((simuPOP::SelfingGenoTransmitter *) x));
}
static void *_p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *)(simuPOP::MendelianGenoTransmitter *) ((simuPOP::HaplodiploidGenoTransmitter *) x));
}
static void *_p_simuPOP__MitochondrialGenoTransmitterTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::GenoTransmitter *) ((simuPOP::MitochondrialGenoTransmitter *) x));
}
static void *_p_simuPOP__PyTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PyTagger *) x));
}
static void *_p_simuPOP__PedigreeTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PedigreeTagger *) x));
}
static void *_p_simuPOP__OffspringTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::OffspringTagger *) x));
}
static void *_p_simuPOP__ParentsTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::ParentsTagger *) x));
}
static void *_p_simuPOP__SummaryTaggerTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::SummaryTagger *) x));
}
static void *_p_simuPOP__BaseQuanTraitTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::BaseQuanTrait *) x));
}
static void *_p_simuPOP__PyQuanTraitTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *) (simuPOP::BaseQuanTrait *) ((simuPOP::PyQuanTrait *) x));
}
static void *_p_simuPOP__PyOutputTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::PyOutput *) x));
}
static void *_p_simuPOP__IfElseTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::IfElse *) x));
}
static void *_p_simuPOP__InfoEvalTo_p_simuPOP__BaseOperator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseOperator *)  ((simuPOP::InfoEval *) x));
}
static void *_p_simuPOP__ControlledOffspringGeneratorTo_p_simuPOP__OffspringGenerator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::OffspringGenerator *)  ((simuPOP::ControlledOffspringGenerator *) x));
}
static void *_p_simuPOP__ConstNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::ConstNumOffModel *) x));
}
static void *_p_simuPOP__GeometricNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::GeometricNumOffModel *) x));
}
static void *_p_simuPOP__PoissonNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::PoissonNumOffModel *) x));
}
static void *_p_simuPOP__BinomialNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::BinomialNumOffModel *) x));
}
static void *_p_simuPOP__UniformNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::UniformNumOffModel *) x));
}
static void *_p_simuPOP__FuncNumOffModelTo_p_simuPOP__NumOffModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::NumOffModel *)  ((simuPOP::FuncNumOffModel *) x));
}
static void *_p_simuPOP__MapSelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::MapSelector *) x));
}
static void *_p_simuPOP__MaSelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::MaSelector *) x));
}
static void *_p_simuPOP__MlSelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::MlSelector *) x));
}
static void *_p_simuPOP__PySelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::PySelector *) x));
}
static void *_p_simuPOP__PyMlSelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::PyMlSelector *) x));
}
static void *_p_simuPOP__MutSpaceSelectorTo_p_simuPOP__BaseSelector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseSelector *)  ((simuPOP::MutSpaceSelector *) x));
}
static void *_p_simuPOP__PyQuanTraitTo_p_simuPOP__BaseQuanTrait(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseQuanTrait *)  ((simuPOP::PyQuanTrait *) x));
}
static void *_p_simuPOP__PopulationTo_p_simuPOP__GenoStruTrait(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoStruTrait *)  ((simuPOP::Population *) x));
}
static void *_p_simuPOP__PedigreeTo_p_simuPOP__GenoStruTrait(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoStruTrait *) (simuPOP::Population *) ((simuPOP::Pedigree *) x));
}
static void *_p_simuPOP__IndividualTo_p_simuPOP__GenoStruTrait(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::GenoStruTrait *)  ((simuPOP::Individual *) x));
}
static void *_p_simuPOP__PyExecTo_p_simuPOP__PyEval(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::PyEval *)  ((simuPOP::PyExec *) x));
}
static void *_p_simuPOP__floatListFuncTo_p_simuPOP__floatList(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::floatList *)  ((simuPOP::floatListFunc *) x));
}
static void *_p_simuPOP__NoSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::NoSexModel *) x));
}
static void *_p_simuPOP__RandomSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::RandomSexModel *) x));
}
static void *_p_simuPOP__ProbOfMalesSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::ProbOfMalesSexModel *) x));
}
static void *_p_simuPOP__NumOfMalesSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::NumOfMalesSexModel *) x));
}
static void *_p_simuPOP__NumOfFemalesSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::NumOfFemalesSexModel *) x));
}
static void *_p_simuPOP__SeqSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::SeqSexModel *) x));
}
static void *_p_simuPOP__GlobalSeqSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::GlobalSeqSexModel *) x));
}
static void *_p_simuPOP__FuncSexModelTo_p_simuPOP__SexModel(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::SexModel *)  ((simuPOP::FuncSexModel *) x));
}
static void *_p_simuPOP__SequentialParentChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::SequentialParentChooser *) x));
}
static void *_p_simuPOP__RandomParentChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::RandomParentChooser *) x));
}
static void *_p_simuPOP__RandomParentsChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::RandomParentsChooser *) x));
}
static void *_p_simuPOP__PolyParentsChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::PolyParentsChooser *) x));
}
static void *_p_simuPOP__CombinedParentsChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::CombinedParentsChooser *) x));
}
static void *_p_simuPOP__PyParentsChooserTo_p_simuPOP__ParentChooser(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::ParentChooser *)  ((simuPOP::PyParentsChooser *) x));
}
static void *_p_simuPOP__StopEvolutionTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::StopEvolution *) x));
}
static void *_p_simuPOP__RevertEvolutionTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::RevertEvolution *) x));
}
static void *_p_simuPOP__StopIterationTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::StopIteration *) x));
}
static void *_p_simuPOP__ValueErrorTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::ValueError *) x));
}
static void *_p_simuPOP__RuntimeErrorTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::RuntimeError *) x));
}
static void *_p_simuPOP__SystemErrorTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::SystemError *) x));
}
static void *_p_simuPOP__IndexErrorTo_p_simuPOP__Exception(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Exception *)  ((simuPOP::IndexError *) x));
}
static void *_p_simuPOP__MatrixMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::MatrixMutator *) x));
}
static void *_p_simuPOP__KAlleleMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::KAlleleMutator *) x));
}
static void *_p_simuPOP__StepwiseMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::StepwiseMutator *) x));
}
static void *_p_simuPOP__PyMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::PyMutator *) x));
}
static void *_p_simuPOP__MixedMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::MixedMutator *) x));
}
static void *_p_simuPOP__ContextMutatorTo_p_simuPOP__BaseMutator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseMutator *)  ((simuPOP::ContextMutator *) x));
}
static void *_p_simuPOP__InfoExecTo_p_simuPOP__InfoEval(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::InfoEval *)  ((simuPOP::InfoExec *) x));
}
static void *_p_simuPOP__PedigreeTo_p_simuPOP__Population(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::Population *)  ((simuPOP::Pedigree *) x));
}
static void *_p_simuPOP__ConditionalMatingTo_p_simuPOP__MatingScheme(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MatingScheme *)  ((simuPOP::ConditionalMating *) x));
}
static void *_p_simuPOP__HomoMatingTo_p_simuPOP__MatingScheme(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MatingScheme *)  ((simuPOP::HomoMating *) x));
}
static void *_p_simuPOP__PedigreeMatingTo_p_simuPOP__MatingScheme(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MatingScheme *)  ((simuPOP::PedigreeMating *) x));
}
static void *_p_simuPOP__HeteroMatingTo_p_simuPOP__MatingScheme(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::MatingScheme *)  ((simuPOP::HeteroMating *) x));
}
static void *_p_simuPOP__uintListFuncTo_p_simuPOP__uintList(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::uintList *)  ((simuPOP::uintListFunc *) x));
}
static void *_p_simuPOP__CombinedSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::CombinedSplitter *) x));
}
static void *_p_simuPOP__ProductSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::ProductSplitter *) x));
}
static void *_p_simuPOP__SexSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::SexSplitter *) x));
}
static void *_p_simuPOP__AffectionSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::AffectionSplitter *) x));
}
static void *_p_simuPOP__InfoSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::InfoSplitter *) x));
}
static void *_p_simuPOP__ProportionSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::ProportionSplitter *) x));
}
static void *_p_simuPOP__RangeSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::RangeSplitter *) x));
}
static void *_p_simuPOP__GenotypeSplitterTo_p_simuPOP__BaseVspSplitter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((simuPOP::BaseVspSplitter *)  ((simuPOP::GenotypeSplitter *) x));
}
static swig_type_info _swigt__p_IndividualPair = {"_p_IndividualPair", "IndividualPair *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LocGenotype = {"_p_LocGenotype", "LocGenotype *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SelCoef = {"_p_SelCoef", "SelCoef *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bool = {"_p_bool", "bool *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_iterator = {"_p_const_iterator", "const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_first_type = {"_p_first_type", "first_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gsl_rng = {"_p_gsl_rng", "gsl_rng *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_key_type = {"_p_key_type", "key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long = {"_p_long", "ssize_t *|LONG *|long *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mapped_type = {"_p_mapped_type", "mapped_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ostream = {"_p_ostream", "ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_second_type = {"_p_second_type", "second_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__AffectionSplitter = {"_p_simuPOP__AffectionSplitter", "simuPOP::AffectionSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BackwardMigrator = {"_p_simuPOP__BackwardMigrator", "simuPOP::BackwardMigrator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BaseMutator = {"_p_simuPOP__BaseMutator", "simuPOP::BaseMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BaseOperator = {"_p_simuPOP__BaseOperator", "simuPOP::BaseOperator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BasePenetrance = {"_p_simuPOP__BasePenetrance", "simuPOP::BasePenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BaseQuanTrait = {"_p_simuPOP__BaseQuanTrait", "simuPOP::BaseQuanTrait *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BaseSelector = {"_p_simuPOP__BaseSelector", "simuPOP::BaseSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__BaseVspSplitter = {"_p_simuPOP__BaseVspSplitter", "simuPOP::BaseVspSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Bernullitrials = {"_p_simuPOP__Bernullitrials", "simuPOP::Bernullitrials *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Bernullitrials_T = {"_p_simuPOP__Bernullitrials_T", "simuPOP::Bernullitrials_T *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__CloneGenoTransmitter = {"_p_simuPOP__CloneGenoTransmitter", "simuPOP::CloneGenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t = {"_p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t", "simuPOP::CombinedAlleleIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,std::vector< unsigned long,std::allocator< unsigned long > >::const_iterator,unsigned long const & > *|simuPOP::ConstIndAlleleIterator *|simuPOP::CombinedAlleleIterator< std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,std::vector< unsigned long,std::allocator< unsigned long > >::const_iterator,unsigned long const & > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__CombinedParentsChooser = {"_p_simuPOP__CombinedParentsChooser", "simuPOP::CombinedParentsChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__CombinedSplitter = {"_p_simuPOP__CombinedSplitter", "simuPOP::CombinedSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ConditionalMating = {"_p_simuPOP__ConditionalMating", "simuPOP::ConditionalMating *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ContextMutator = {"_p_simuPOP__ContextMutator", "simuPOP::ContextMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ControlledOffspringGenerator = {"_p_simuPOP__ControlledOffspringGenerator", "simuPOP::ControlledOffspringGenerator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__DiscardIf = {"_p_simuPOP__DiscardIf", "simuPOP::DiscardIf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Dumper = {"_p_simuPOP__Dumper", "simuPOP::Dumper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Exception = {"_p_simuPOP__Exception", "simuPOP::Exception *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__FiniteSitesMutator = {"_p_simuPOP__FiniteSitesMutator", "simuPOP::FiniteSitesMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__GenoStruTrait = {"_p_simuPOP__GenoStruTrait", "simuPOP::GenoStruTrait *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__GenoTransmitter = {"_p_simuPOP__GenoTransmitter", "simuPOP::GenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__GenotypeSplitter = {"_p_simuPOP__GenotypeSplitter", "simuPOP::GenotypeSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__HaplodiploidGenoTransmitter = {"_p_simuPOP__HaplodiploidGenoTransmitter", "simuPOP::HaplodiploidGenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__HeteroMating = {"_p_simuPOP__HeteroMating", "simuPOP::HeteroMating *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__HomoMating = {"_p_simuPOP__HomoMating", "simuPOP::HomoMating *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__IdTagger = {"_p_simuPOP__IdTagger", "simuPOP::IdTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__IfElse = {"_p_simuPOP__IfElse", "simuPOP::IfElse *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__IndexError = {"_p_simuPOP__IndexError", "simuPOP::IndexError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Individual = {"_p_simuPOP__Individual", "simuPOP::Individual *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t = {"_p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t", "simuPOP::ConstIndIterator *|simuPOP::IndividualIterator< std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_pointer,std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_reference > *|simuPOP::IndividualIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_pointer,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_reference > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t = {"_p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t", "simuPOP::IndIterator *|simuPOP::IndividualIterator< std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator,std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::pointer,std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::reference > *|simuPOP::IndividualIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::pointer,vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::reference > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InfoEval = {"_p_simuPOP__InfoEval", "simuPOP::InfoEval *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InfoExec = {"_p_simuPOP__InfoExec", "simuPOP::InfoExec *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InfoSplitter = {"_p_simuPOP__InfoSplitter", "simuPOP::InfoSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t = {"_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t", "simuPOP::InformationIterator< std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator > *|simuPOP::InformationIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator > *|simuPOP::ConstIndInfoIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t = {"_p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t", "simuPOP::InformationIterator< std::vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > *|simuPOP::InformationIterator< vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator > *|simuPOP::IndInfoIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InheritTagger = {"_p_simuPOP__InheritTagger", "simuPOP::InheritTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InitGenotype = {"_p_simuPOP__InitGenotype", "simuPOP::InitGenotype *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InitInfo = {"_p_simuPOP__InitInfo", "simuPOP::InitInfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InitLineage = {"_p_simuPOP__InitLineage", "simuPOP::InitLineage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__InitSex = {"_p_simuPOP__InitSex", "simuPOP::InitSex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__KAlleleMutator = {"_p_simuPOP__KAlleleMutator", "simuPOP::KAlleleMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MaPenetrance = {"_p_simuPOP__MaPenetrance", "simuPOP::MaPenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MaSelector = {"_p_simuPOP__MaSelector", "simuPOP::MaSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MapPenetrance = {"_p_simuPOP__MapPenetrance", "simuPOP::MapPenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MapSelector = {"_p_simuPOP__MapSelector", "simuPOP::MapSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MatingScheme = {"_p_simuPOP__MatingScheme", "simuPOP::MatingScheme *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MatrixMutator = {"_p_simuPOP__MatrixMutator", "simuPOP::MatrixMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MendelianGenoTransmitter = {"_p_simuPOP__MendelianGenoTransmitter", "simuPOP::MendelianGenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MergeSubPops = {"_p_simuPOP__MergeSubPops", "simuPOP::MergeSubPops *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Migrator = {"_p_simuPOP__Migrator", "simuPOP::Migrator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MitochondrialGenoTransmitter = {"_p_simuPOP__MitochondrialGenoTransmitter", "simuPOP::MitochondrialGenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MixedMutator = {"_p_simuPOP__MixedMutator", "simuPOP::MixedMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MlPenetrance = {"_p_simuPOP__MlPenetrance", "simuPOP::MlPenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MlSelector = {"_p_simuPOP__MlSelector", "simuPOP::MlSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MutSpaceMutator = {"_p_simuPOP__MutSpaceMutator", "simuPOP::MutSpaceMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MutSpaceRecombinator = {"_p_simuPOP__MutSpaceRecombinator", "simuPOP::MutSpaceRecombinator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MutSpaceRevertFixedSites = {"_p_simuPOP__MutSpaceRevertFixedSites", "simuPOP::MutSpaceRevertFixedSites *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__MutSpaceSelector = {"_p_simuPOP__MutSpaceSelector", "simuPOP::MutSpaceSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__NoneOp = {"_p_simuPOP__NoneOp", "simuPOP::NoneOp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__NumOffModel = {"_p_simuPOP__NumOffModel", "simuPOP::NumOffModel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ConstNumOffModel = {"_p_simuPOP__ConstNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__GeometricNumOffModel = {"_p_simuPOP__GeometricNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__PoissonNumOffModel = {"_p_simuPOP__PoissonNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__BinomialNumOffModel = {"_p_simuPOP__BinomialNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__UniformNumOffModel = {"_p_simuPOP__UniformNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__FuncNumOffModel = {"_p_simuPOP__FuncNumOffModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__OffspringGenerator = {"_p_simuPOP__OffspringGenerator", "simuPOP::OffspringGenerator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__OffspringTagger = {"_p_simuPOP__OffspringTagger", "simuPOP::OffspringTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ParentChooser = {"_p_simuPOP__ParentChooser", "simuPOP::ParentChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ParentsTagger = {"_p_simuPOP__ParentsTagger", "simuPOP::ParentsTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Pause = {"_p_simuPOP__Pause", "simuPOP::Pause *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Pedigree = {"_p_simuPOP__Pedigree", "simuPOP::Pedigree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PedigreeMating = {"_p_simuPOP__PedigreeMating", "simuPOP::PedigreeMating *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PedigreeTagger = {"_p_simuPOP__PedigreeTagger", "simuPOP::PedigreeTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PointMutator = {"_p_simuPOP__PointMutator", "simuPOP::PointMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PolyParentsChooser = {"_p_simuPOP__PolyParentsChooser", "simuPOP::PolyParentsChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Population = {"_p_simuPOP__Population", "simuPOP::Population *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ProductSplitter = {"_p_simuPOP__ProductSplitter", "simuPOP::ProductSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ProportionSplitter = {"_p_simuPOP__ProportionSplitter", "simuPOP::ProportionSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyEval = {"_p_simuPOP__PyEval", "simuPOP::PyEval *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyExec = {"_p_simuPOP__PyExec", "simuPOP::PyExec *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyMlPenetrance = {"_p_simuPOP__PyMlPenetrance", "simuPOP::PyMlPenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyMlSelector = {"_p_simuPOP__PyMlSelector", "simuPOP::PyMlSelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyMutator = {"_p_simuPOP__PyMutator", "simuPOP::PyMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyOperator = {"_p_simuPOP__PyOperator", "simuPOP::PyOperator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyOutput = {"_p_simuPOP__PyOutput", "simuPOP::PyOutput *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyParentsChooser = {"_p_simuPOP__PyParentsChooser", "simuPOP::PyParentsChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyPenetrance = {"_p_simuPOP__PyPenetrance", "simuPOP::PyPenetrance *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyQuanTrait = {"_p_simuPOP__PyQuanTrait", "simuPOP::PyQuanTrait *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PySelector = {"_p_simuPOP__PySelector", "simuPOP::PySelector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__PyTagger = {"_p_simuPOP__PyTagger", "simuPOP::PyTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RNG = {"_p_simuPOP__RNG", "simuPOP::RNG *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RNG_func = {"_p_simuPOP__RNG_func", "simuPOP::RNG_func *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RandomParentChooser = {"_p_simuPOP__RandomParentChooser", "simuPOP::RandomParentChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RandomParentsChooser = {"_p_simuPOP__RandomParentsChooser", "simuPOP::RandomParentsChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RangeSplitter = {"_p_simuPOP__RangeSplitter", "simuPOP::RangeSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Recombinator = {"_p_simuPOP__Recombinator", "simuPOP::Recombinator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ResizeSubPops = {"_p_simuPOP__ResizeSubPops", "simuPOP::ResizeSubPops *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RevertEvolution = {"_p_simuPOP__RevertEvolution", "simuPOP::RevertEvolution *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RevertFixedSites = {"_p_simuPOP__RevertFixedSites", "simuPOP::RevertFixedSites *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RevertIf = {"_p_simuPOP__RevertIf", "simuPOP::RevertIf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__RuntimeError = {"_p_simuPOP__RuntimeError", "simuPOP::RuntimeError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SavePopulation = {"_p_simuPOP__SavePopulation", "simuPOP::SavePopulation *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SelfingGenoTransmitter = {"_p_simuPOP__SelfingGenoTransmitter", "simuPOP::SelfingGenoTransmitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SequentialParentChooser = {"_p_simuPOP__SequentialParentChooser", "simuPOP::SequentialParentChooser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SexModel = {"_p_simuPOP__SexModel", "simuPOP::SexModel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__NoSexModel = {"_p_simuPOP__NoSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__RandomSexModel = {"_p_simuPOP__RandomSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__ProbOfMalesSexModel = {"_p_simuPOP__ProbOfMalesSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__NumOfMalesSexModel = {"_p_simuPOP__NumOfMalesSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__NumOfFemalesSexModel = {"_p_simuPOP__NumOfFemalesSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__SeqSexModel = {"_p_simuPOP__SeqSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__GlobalSeqSexModel = {"_p_simuPOP__GlobalSeqSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__FuncSexModel = {"_p_simuPOP__FuncSexModel", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_simuPOP__SexSplitter = {"_p_simuPOP__SexSplitter", "simuPOP::SexSplitter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Simulator = {"_p_simuPOP__Simulator", "simuPOP::Simulator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SplitSubPops = {"_p_simuPOP__SplitSubPops", "simuPOP::SplitSubPops *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__Stat = {"_p_simuPOP__Stat", "simuPOP::Stat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__StepwiseMutator = {"_p_simuPOP__StepwiseMutator", "simuPOP::StepwiseMutator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__StopEvolution = {"_p_simuPOP__StopEvolution", "simuPOP::StopEvolution *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__StopIteration = {"_p_simuPOP__StopIteration", "simuPOP::StopIteration *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SummaryTagger = {"_p_simuPOP__SummaryTagger", "simuPOP::SummaryTagger *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__SystemError = {"_p_simuPOP__SystemError", "simuPOP::SystemError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__TerminateIf = {"_p_simuPOP__TerminateIf", "simuPOP::TerminateIf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__TicToc = {"_p_simuPOP__TicToc", "simuPOP::TicToc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__ValueError = {"_p_simuPOP__ValueError", "simuPOP::ValueError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__WeightedSampler = {"_p_simuPOP__WeightedSampler", "simuPOP::WeightedSampler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__floatList = {"_p_simuPOP__floatList", "simuPOP::floatList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__floatListFunc = {"_p_simuPOP__floatListFunc", "simuPOP::floatListFunc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__floatMatrix = {"_p_simuPOP__floatMatrix", "simuPOP::floatMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__intList = {"_p_simuPOP__intList", "simuPOP::intList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__intMatrix = {"_p_simuPOP__intMatrix", "simuPOP::intMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__lociList = {"_p_simuPOP__lociList", "simuPOP::lociList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__opList = {"_p_simuPOP__opList", "simuPOP::opList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__pyIndIterator = {"_p_simuPOP__pyIndIterator", "simuPOP::pyIndIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__pyMutantIterator = {"_p_simuPOP__pyMutantIterator", "simuPOP::pyMutantIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__pyPopIterator = {"_p_simuPOP__pyPopIterator", "simuPOP::pyPopIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__stringFunc = {"_p_simuPOP__stringFunc", "simuPOP::stringFunc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__stringList = {"_p_simuPOP__stringList", "simuPOP::stringList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__stringMatrix = {"_p_simuPOP__stringMatrix", "simuPOP::stringMatrix *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__subPopList = {"_p_simuPOP__subPopList", "simuPOP::subPopList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__uintList = {"_p_simuPOP__uintList", "simuPOP::uintList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__uintListFunc = {"_p_simuPOP__uintListFunc", "simuPOP::uintListFunc *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__uintString = {"_p_simuPOP__uintString", "simuPOP::uintString *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__vspFunctor = {"_p_simuPOP__vspFunctor", "simuPOP::vspFunctor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simuPOP__vspID = {"_p_simuPOP__vspID", "simuPOP::vspID *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_t = {"_p_size_t", "size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t = {"_p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t", "std::map< int,double,std::less< int >,std::allocator< std::pair< int const,double > > > *|intDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t = {"_p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t", "std::map< size_t,double,std::less< size_t >,std::allocator< std::pair< size_t const,double > > > *|uintDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t = {"_p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t", "std::map< std::string,double,std::less< std::string >,std::allocator< std::pair< std::string const,double > > > *|strDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t = {"_p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t", "std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long,std::allocator< long > > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *|std::map< std::vector< long,std::allocator< long > >,double,std::less< std::vector< long > >,std::allocator< std::pair< std::vector< long,std::allocator< long > > const,double > > > *|tupleDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_size_t_size_t_t = {"_p_std__pairT_size_t_size_t_t", "pairu *|std::pair< size_t,size_t > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__string_double_t = {"_p_std__pairT_std__string_double_t", "genomic_pos *|std::pair< std::string,double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *|string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t = {"_p_std__vectorT_double_std__allocatorT_double_t_t", "std::vector< double,std::allocator< double > > *|vectorf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator = {"_p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator", "std::vector< double >::const_iterator *|ConstInfoIterator *|std::vector< double,std::allocator< double > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t__iterator = {"_p_std__vectorT_double_std__allocatorT_double_t_t__iterator", "std::vector< double,std::allocator< double > >::iterator *|std::vector< double >::iterator *|InfoIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_long_std__allocatorT_long_t_t = {"_p_std__vectorT_long_std__allocatorT_long_t_t", "std::vector< long,std::allocator< long > > *|vectori *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator = {"_p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator", "std::vector< long >::const_iterator *|ConstLineageIterator *|std::vector< long,std::allocator< long > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_long_std__allocatorT_long_t_t__iterator = {"_p_std__vectorT_long_std__allocatorT_long_t_t__iterator", "std::vector< long,std::allocator< long > >::iterator *|std::vector< long >::iterator *|LineageIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t = {"_p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t", "std::vector< simuPOP::BaseOperator *,std::allocator< simuPOP::BaseOperator * > > *|simuPOP::vectorop *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t = {"_p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t", "simuPOP::vectorsplitter *|std::vector< simuPOP::BaseVspSplitter *,std::allocator< simuPOP::BaseVspSplitter * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t = {"_p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t", "simuPOP::vectormating *|std::vector< simuPOP::HomoMating *,std::allocator< simuPOP::HomoMating * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_size_t_std__allocatorT_size_t_t_t = {"_p_std__vectorT_size_t_std__allocatorT_size_t_t_t", "std::vector< size_t,std::allocator< size_t > > *|vectoru *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t = {"_p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t", "mutantList *|std::vector< std::pair< size_t,size_t >,std::allocator< std::pair< size_t,size_t > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t = {"_p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t", "vectorpos *|std::vector< std::pair< std::string,double >,std::allocator< std::pair< std::string,double > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t = {"_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", "vectorstr *|std::vector< std::string,std::allocator< std::string > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t = {"_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t", "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *|matrixf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t = {"_p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t", "std::vector< std::vector< long,std::allocator< long > >,std::allocator< std::vector< long,std::allocator< long > > > > *|matrixi *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t = {"_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", "matrixstr *|std::vector< std::vector< std::string,std::allocator< std::string > >,std::allocator< std::vector< std::string,std::allocator< std::string > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t = {"_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t", "std::vector< unsigned long,std::allocator< unsigned long > > *|vectora *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator = {"_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator", "std::vector< unsigned long,std::allocator< unsigned long > >::const_iterator *|ConstGenoIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator = {"_p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator", "std::vector< unsigned long,std::allocator< unsigned long > >::iterator *|GenoIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__SwigPyIterator = {"_p_swig__SwigPyIterator", "swig::SwigPyIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "TraitIndexType *|unsigned char *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|UINT *|uint32_t *|unsigned int *|uint_fast16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|ULONG *|Allele *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_bool_std__allocatorT_bool_t_t = {"_p_vectorT_bool_std__allocatorT_bool_t_t", "BitSet *|vector< bool,std::allocator< bool > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator", "simuPOP::ConstRawIndIterator *|vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer", "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_pointer *|simuPOP::ConstRawIndPointer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference", "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::const_reference *|simuPOP::ConstRawIndReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator", "simuPOP::RawIndIterator *|vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer", "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::pointer *|simuPOP::RawIndPointer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference = {"_p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference", "vector< simuPOP::Individual,std::allocator< simuPOP::Individual > >::reference *|simuPOP::RawIndReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator = {"_p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator", "vector< simuPOP::Population *,std::allocator< simuPOP::Population * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vectorvsp = {"_p_vectorvsp", "vectorvsp *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_IndividualPair,
  &_swigt__p_LocGenotype,
  &_swigt__p_SelCoef,
  &_swigt__p_allocator_type,
  &_swigt__p_bool,
  &_swigt__p_char,
  &_swigt__p_const_iterator,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_first_type,
  &_swigt__p_gsl_rng,
  &_swigt__p_int,
  &_swigt__p_iterator,
  &_swigt__p_key_type,
  &_swigt__p_long,
  &_swigt__p_long_long,
  &_swigt__p_mapped_type,
  &_swigt__p_ostream,
  &_swigt__p_reference,
  &_swigt__p_second_type,
  &_swigt__p_short,
  &_swigt__p_signed_char,
  &_swigt__p_simuPOP__AffectionSplitter,
  &_swigt__p_simuPOP__BackwardMigrator,
  &_swigt__p_simuPOP__BaseMutator,
  &_swigt__p_simuPOP__BaseOperator,
  &_swigt__p_simuPOP__BasePenetrance,
  &_swigt__p_simuPOP__BaseQuanTrait,
  &_swigt__p_simuPOP__BaseSelector,
  &_swigt__p_simuPOP__BaseVspSplitter,
  &_swigt__p_simuPOP__Bernullitrials,
  &_swigt__p_simuPOP__Bernullitrials_T,
  &_swigt__p_simuPOP__BinomialNumOffModel,
  &_swigt__p_simuPOP__CloneGenoTransmitter,
  &_swigt__p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t,
  &_swigt__p_simuPOP__CombinedParentsChooser,
  &_swigt__p_simuPOP__CombinedSplitter,
  &_swigt__p_simuPOP__ConditionalMating,
  &_swigt__p_simuPOP__ConstNumOffModel,
  &_swigt__p_simuPOP__ContextMutator,
  &_swigt__p_simuPOP__ControlledOffspringGenerator,
  &_swigt__p_simuPOP__DiscardIf,
  &_swigt__p_simuPOP__Dumper,
  &_swigt__p_simuPOP__Exception,
  &_swigt__p_simuPOP__FiniteSitesMutator,
  &_swigt__p_simuPOP__FuncNumOffModel,
  &_swigt__p_simuPOP__FuncSexModel,
  &_swigt__p_simuPOP__GenoStruTrait,
  &_swigt__p_simuPOP__GenoTransmitter,
  &_swigt__p_simuPOP__GenotypeSplitter,
  &_swigt__p_simuPOP__GeometricNumOffModel,
  &_swigt__p_simuPOP__GlobalSeqSexModel,
  &_swigt__p_simuPOP__HaplodiploidGenoTransmitter,
  &_swigt__p_simuPOP__HeteroMating,
  &_swigt__p_simuPOP__HomoMating,
  &_swigt__p_simuPOP__IdTagger,
  &_swigt__p_simuPOP__IfElse,
  &_swigt__p_simuPOP__IndexError,
  &_swigt__p_simuPOP__Individual,
  &_swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t,
  &_swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t,
  &_swigt__p_simuPOP__InfoEval,
  &_swigt__p_simuPOP__InfoExec,
  &_swigt__p_simuPOP__InfoSplitter,
  &_swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t,
  &_swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t,
  &_swigt__p_simuPOP__InheritTagger,
  &_swigt__p_simuPOP__InitGenotype,
  &_swigt__p_simuPOP__InitInfo,
  &_swigt__p_simuPOP__InitLineage,
  &_swigt__p_simuPOP__InitSex,
  &_swigt__p_simuPOP__KAlleleMutator,
  &_swigt__p_simuPOP__MaPenetrance,
  &_swigt__p_simuPOP__MaSelector,
  &_swigt__p_simuPOP__MapPenetrance,
  &_swigt__p_simuPOP__MapSelector,
  &_swigt__p_simuPOP__MatingScheme,
  &_swigt__p_simuPOP__MatrixMutator,
  &_swigt__p_simuPOP__MendelianGenoTransmitter,
  &_swigt__p_simuPOP__MergeSubPops,
  &_swigt__p_simuPOP__Migrator,
  &_swigt__p_simuPOP__MitochondrialGenoTransmitter,
  &_swigt__p_simuPOP__MixedMutator,
  &_swigt__p_simuPOP__MlPenetrance,
  &_swigt__p_simuPOP__MlSelector,
  &_swigt__p_simuPOP__MutSpaceMutator,
  &_swigt__p_simuPOP__MutSpaceRecombinator,
  &_swigt__p_simuPOP__MutSpaceRevertFixedSites,
  &_swigt__p_simuPOP__MutSpaceSelector,
  &_swigt__p_simuPOP__NoSexModel,
  &_swigt__p_simuPOP__NoneOp,
  &_swigt__p_simuPOP__NumOfFemalesSexModel,
  &_swigt__p_simuPOP__NumOfMalesSexModel,
  &_swigt__p_simuPOP__NumOffModel,
  &_swigt__p_simuPOP__OffspringGenerator,
  &_swigt__p_simuPOP__OffspringTagger,
  &_swigt__p_simuPOP__ParentChooser,
  &_swigt__p_simuPOP__ParentsTagger,
  &_swigt__p_simuPOP__Pause,
  &_swigt__p_simuPOP__Pedigree,
  &_swigt__p_simuPOP__PedigreeMating,
  &_swigt__p_simuPOP__PedigreeTagger,
  &_swigt__p_simuPOP__PointMutator,
  &_swigt__p_simuPOP__PoissonNumOffModel,
  &_swigt__p_simuPOP__PolyParentsChooser,
  &_swigt__p_simuPOP__Population,
  &_swigt__p_simuPOP__ProbOfMalesSexModel,
  &_swigt__p_simuPOP__ProductSplitter,
  &_swigt__p_simuPOP__ProportionSplitter,
  &_swigt__p_simuPOP__PyEval,
  &_swigt__p_simuPOP__PyExec,
  &_swigt__p_simuPOP__PyMlPenetrance,
  &_swigt__p_simuPOP__PyMlSelector,
  &_swigt__p_simuPOP__PyMutator,
  &_swigt__p_simuPOP__PyOperator,
  &_swigt__p_simuPOP__PyOutput,
  &_swigt__p_simuPOP__PyParentsChooser,
  &_swigt__p_simuPOP__PyPenetrance,
  &_swigt__p_simuPOP__PyQuanTrait,
  &_swigt__p_simuPOP__PySelector,
  &_swigt__p_simuPOP__PyTagger,
  &_swigt__p_simuPOP__RNG,
  &_swigt__p_simuPOP__RNG_func,
  &_swigt__p_simuPOP__RandomParentChooser,
  &_swigt__p_simuPOP__RandomParentsChooser,
  &_swigt__p_simuPOP__RandomSexModel,
  &_swigt__p_simuPOP__RangeSplitter,
  &_swigt__p_simuPOP__Recombinator,
  &_swigt__p_simuPOP__ResizeSubPops,
  &_swigt__p_simuPOP__RevertEvolution,
  &_swigt__p_simuPOP__RevertFixedSites,
  &_swigt__p_simuPOP__RevertIf,
  &_swigt__p_simuPOP__RuntimeError,
  &_swigt__p_simuPOP__SavePopulation,
  &_swigt__p_simuPOP__SelfingGenoTransmitter,
  &_swigt__p_simuPOP__SeqSexModel,
  &_swigt__p_simuPOP__SequentialParentChooser,
  &_swigt__p_simuPOP__SexModel,
  &_swigt__p_simuPOP__SexSplitter,
  &_swigt__p_simuPOP__Simulator,
  &_swigt__p_simuPOP__SplitSubPops,
  &_swigt__p_simuPOP__Stat,
  &_swigt__p_simuPOP__StepwiseMutator,
  &_swigt__p_simuPOP__StopEvolution,
  &_swigt__p_simuPOP__StopIteration,
  &_swigt__p_simuPOP__SummaryTagger,
  &_swigt__p_simuPOP__SystemError,
  &_swigt__p_simuPOP__TerminateIf,
  &_swigt__p_simuPOP__TicToc,
  &_swigt__p_simuPOP__UniformNumOffModel,
  &_swigt__p_simuPOP__ValueError,
  &_swigt__p_simuPOP__WeightedSampler,
  &_swigt__p_simuPOP__floatList,
  &_swigt__p_simuPOP__floatListFunc,
  &_swigt__p_simuPOP__floatMatrix,
  &_swigt__p_simuPOP__intList,
  &_swigt__p_simuPOP__intMatrix,
  &_swigt__p_simuPOP__lociList,
  &_swigt__p_simuPOP__opList,
  &_swigt__p_simuPOP__pyIndIterator,
  &_swigt__p_simuPOP__pyMutantIterator,
  &_swigt__p_simuPOP__pyPopIterator,
  &_swigt__p_simuPOP__stringFunc,
  &_swigt__p_simuPOP__stringList,
  &_swigt__p_simuPOP__stringMatrix,
  &_swigt__p_simuPOP__subPopList,
  &_swigt__p_simuPOP__uintList,
  &_swigt__p_simuPOP__uintListFunc,
  &_swigt__p_simuPOP__uintString,
  &_swigt__p_simuPOP__vspFunctor,
  &_swigt__p_simuPOP__vspID,
  &_swigt__p_size_t,
  &_swigt__p_size_type,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t,
  &_swigt__p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t,
  &_swigt__p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t,
  &_swigt__p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t,
  &_swigt__p_std__pairT_size_t_size_t_t,
  &_swigt__p_std__pairT_std__string_double_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__iterator,
  &_swigt__p_std__vectorT_long_std__allocatorT_long_t_t,
  &_swigt__p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator,
  &_swigt__p_std__vectorT_long_std__allocatorT_long_t_t__iterator,
  &_swigt__p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t,
  &_swigt__p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t,
  &_swigt__p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t,
  &_swigt__p_std__vectorT_size_t_std__allocatorT_size_t_t_t,
  &_swigt__p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t,
  &_swigt__p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t,
  &_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  &_swigt__p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t,
  &_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t,
  &_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator,
  &_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator,
  &_swigt__p_swig__SwigPyIterator,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_value_type,
  &_swigt__p_vectorT_bool_std__allocatorT_bool_t_t,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer,
  &_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference,
  &_swigt__p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator,
  &_swigt__p_vectorvsp,
};

static swig_cast_info _swigc__p_IndividualPair[] = {  {&_swigt__p_IndividualPair, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LocGenotype[] = {  {&_swigt__p_LocGenotype, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SelCoef[] = {  {&_swigt__p_SelCoef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bool[] = {  {&_swigt__p_bool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_iterator[] = {  {&_swigt__p_const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_first_type[] = {  {&_swigt__p_first_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gsl_rng[] = {  {&_swigt__p_gsl_rng, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_key_type[] = {  {&_swigt__p_key_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long[] = {  {&_swigt__p_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mapped_type[] = {  {&_swigt__p_mapped_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ostream[] = {  {&_swigt__p_ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_second_type[] = {  {&_swigt__p_second_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__AffectionSplitter[] = {  {&_swigt__p_simuPOP__AffectionSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BackwardMigrator[] = {  {&_swigt__p_simuPOP__BackwardMigrator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BaseMutator[] = {  {&_swigt__p_simuPOP__BaseMutator, 0, 0, 0},  {&_swigt__p_simuPOP__MatrixMutator, _p_simuPOP__MatrixMutatorTo_p_simuPOP__BaseMutator, 0, 0},  {&_swigt__p_simuPOP__KAlleleMutator, _p_simuPOP__KAlleleMutatorTo_p_simuPOP__BaseMutator, 0, 0},  {&_swigt__p_simuPOP__StepwiseMutator, _p_simuPOP__StepwiseMutatorTo_p_simuPOP__BaseMutator, 0, 0},  {&_swigt__p_simuPOP__PyMutator, _p_simuPOP__PyMutatorTo_p_simuPOP__BaseMutator, 0, 0},  {&_swigt__p_simuPOP__MixedMutator, _p_simuPOP__MixedMutatorTo_p_simuPOP__BaseMutator, 0, 0},  {&_swigt__p_simuPOP__ContextMutator, _p_simuPOP__ContextMutatorTo_p_simuPOP__BaseMutator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BaseOperator[] = {  {&_swigt__p_simuPOP__InitSex, _p_simuPOP__InitSexTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InitGenotype, _p_simuPOP__InitGenotypeTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__Recombinator, _p_simuPOP__RecombinatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MutSpaceRecombinator, _p_simuPOP__MutSpaceRecombinatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__SavePopulation, _p_simuPOP__SavePopulationTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__RevertIf, _p_simuPOP__RevertIfTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__IfElse, _p_simuPOP__IfElseTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BackwardMigrator, _p_simuPOP__BackwardMigratorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__Migrator, _p_simuPOP__MigratorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyEval, _p_simuPOP__PyEvalTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__RevertFixedSites, _p_simuPOP__RevertFixedSitesTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MutSpaceRevertFixedSites, _p_simuPOP__MutSpaceRevertFixedSitesTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__TerminateIf, _p_simuPOP__TerminateIfTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__Pause, _p_simuPOP__PauseTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InheritTagger, _p_simuPOP__InheritTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__IdTagger, _p_simuPOP__IdTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InitLineage, _p_simuPOP__InitLineageTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyOperator, _p_simuPOP__PyOperatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BaseOperator, 0, 0, 0},  {&_swigt__p_simuPOP__DiscardIf, _p_simuPOP__DiscardIfTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__ResizeSubPops, _p_simuPOP__ResizeSubPopsTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MergeSubPops, _p_simuPOP__MergeSubPopsTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__SplitSubPops, _p_simuPOP__SplitSubPopsTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BasePenetrance, _p_simuPOP__BasePenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MapPenetrance, _p_simuPOP__MapPenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MaPenetrance, _p_simuPOP__MaPenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MlPenetrance, _p_simuPOP__MlPenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyPenetrance, _p_simuPOP__PyPenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyMlPenetrance, _p_simuPOP__PyMlPenetranceTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__Stat, _p_simuPOP__StatTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InfoExec, _p_simuPOP__InfoExecTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InitInfo, _p_simuPOP__InitInfoTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MatrixMutator, _p_simuPOP__MatrixMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BaseMutator, _p_simuPOP__BaseMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__KAlleleMutator, _p_simuPOP__KAlleleMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__StepwiseMutator, _p_simuPOP__StepwiseMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyMutator, _p_simuPOP__PyMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MixedMutator, _p_simuPOP__MixedMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__ContextMutator, _p_simuPOP__ContextMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PointMutator, _p_simuPOP__PointMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__FiniteSitesMutator, _p_simuPOP__FiniteSitesMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MutSpaceMutator, _p_simuPOP__MutSpaceMutatorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BaseSelector, _p_simuPOP__BaseSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MapSelector, _p_simuPOP__MapSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MaSelector, _p_simuPOP__MaSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MlSelector, _p_simuPOP__MlSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PySelector, _p_simuPOP__PySelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyMlSelector, _p_simuPOP__PyMlSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MutSpaceSelector, _p_simuPOP__MutSpaceSelectorTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__GenoTransmitter, _p_simuPOP__GenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__CloneGenoTransmitter, _p_simuPOP__CloneGenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MendelianGenoTransmitter, _p_simuPOP__MendelianGenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__SelfingGenoTransmitter, _p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__HaplodiploidGenoTransmitter, _p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__MitochondrialGenoTransmitter, _p_simuPOP__MitochondrialGenoTransmitterTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__Dumper, _p_simuPOP__DumperTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyTagger, _p_simuPOP__PyTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PedigreeTagger, _p_simuPOP__PedigreeTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__OffspringTagger, _p_simuPOP__OffspringTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__ParentsTagger, _p_simuPOP__ParentsTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__SummaryTagger, _p_simuPOP__SummaryTaggerTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__TicToc, _p_simuPOP__TicTocTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__NoneOp, _p_simuPOP__NoneOpTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__BaseQuanTrait, _p_simuPOP__BaseQuanTraitTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyQuanTrait, _p_simuPOP__PyQuanTraitTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyExec, _p_simuPOP__PyExecTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__PyOutput, _p_simuPOP__PyOutputTo_p_simuPOP__BaseOperator, 0, 0},  {&_swigt__p_simuPOP__InfoEval, _p_simuPOP__InfoEvalTo_p_simuPOP__BaseOperator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BasePenetrance[] = {  {&_swigt__p_simuPOP__BasePenetrance, 0, 0, 0},  {&_swigt__p_simuPOP__MapPenetrance, _p_simuPOP__MapPenetranceTo_p_simuPOP__BasePenetrance, 0, 0},  {&_swigt__p_simuPOP__MaPenetrance, _p_simuPOP__MaPenetranceTo_p_simuPOP__BasePenetrance, 0, 0},  {&_swigt__p_simuPOP__MlPenetrance, _p_simuPOP__MlPenetranceTo_p_simuPOP__BasePenetrance, 0, 0},  {&_swigt__p_simuPOP__PyPenetrance, _p_simuPOP__PyPenetranceTo_p_simuPOP__BasePenetrance, 0, 0},  {&_swigt__p_simuPOP__PyMlPenetrance, _p_simuPOP__PyMlPenetranceTo_p_simuPOP__BasePenetrance, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BaseQuanTrait[] = {  {&_swigt__p_simuPOP__BaseQuanTrait, 0, 0, 0},  {&_swigt__p_simuPOP__PyQuanTrait, _p_simuPOP__PyQuanTraitTo_p_simuPOP__BaseQuanTrait, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BaseSelector[] = {  {&_swigt__p_simuPOP__BaseSelector, 0, 0, 0},  {&_swigt__p_simuPOP__MapSelector, _p_simuPOP__MapSelectorTo_p_simuPOP__BaseSelector, 0, 0},  {&_swigt__p_simuPOP__MaSelector, _p_simuPOP__MaSelectorTo_p_simuPOP__BaseSelector, 0, 0},  {&_swigt__p_simuPOP__MlSelector, _p_simuPOP__MlSelectorTo_p_simuPOP__BaseSelector, 0, 0},  {&_swigt__p_simuPOP__PySelector, _p_simuPOP__PySelectorTo_p_simuPOP__BaseSelector, 0, 0},  {&_swigt__p_simuPOP__PyMlSelector, _p_simuPOP__PyMlSelectorTo_p_simuPOP__BaseSelector, 0, 0},  {&_swigt__p_simuPOP__MutSpaceSelector, _p_simuPOP__MutSpaceSelectorTo_p_simuPOP__BaseSelector, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BaseVspSplitter[] = {  {&_swigt__p_simuPOP__BaseVspSplitter, 0, 0, 0},  {&_swigt__p_simuPOP__CombinedSplitter, _p_simuPOP__CombinedSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__ProductSplitter, _p_simuPOP__ProductSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__SexSplitter, _p_simuPOP__SexSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__AffectionSplitter, _p_simuPOP__AffectionSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__InfoSplitter, _p_simuPOP__InfoSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__ProportionSplitter, _p_simuPOP__ProportionSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__RangeSplitter, _p_simuPOP__RangeSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},  {&_swigt__p_simuPOP__GenotypeSplitter, _p_simuPOP__GenotypeSplitterTo_p_simuPOP__BaseVspSplitter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Bernullitrials[] = {  {&_swigt__p_simuPOP__Bernullitrials, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Bernullitrials_T[] = {  {&_swigt__p_simuPOP__Bernullitrials_T, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__CloneGenoTransmitter[] = {  {&_swigt__p_simuPOP__CloneGenoTransmitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t[] = {  {&_swigt__p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__CombinedParentsChooser[] = {  {&_swigt__p_simuPOP__CombinedParentsChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__CombinedSplitter[] = {  {&_swigt__p_simuPOP__CombinedSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ConditionalMating[] = {  {&_swigt__p_simuPOP__ConditionalMating, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ContextMutator[] = {  {&_swigt__p_simuPOP__ContextMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ControlledOffspringGenerator[] = {  {&_swigt__p_simuPOP__ControlledOffspringGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__DiscardIf[] = {  {&_swigt__p_simuPOP__DiscardIf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Dumper[] = {  {&_swigt__p_simuPOP__Dumper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Exception[] = {  {&_swigt__p_simuPOP__StopEvolution, _p_simuPOP__StopEvolutionTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__RevertEvolution, _p_simuPOP__RevertEvolutionTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__Exception, 0, 0, 0},  {&_swigt__p_simuPOP__StopIteration, _p_simuPOP__StopIterationTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__ValueError, _p_simuPOP__ValueErrorTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__RuntimeError, _p_simuPOP__RuntimeErrorTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__SystemError, _p_simuPOP__SystemErrorTo_p_simuPOP__Exception, 0, 0},  {&_swigt__p_simuPOP__IndexError, _p_simuPOP__IndexErrorTo_p_simuPOP__Exception, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__FiniteSitesMutator[] = {  {&_swigt__p_simuPOP__FiniteSitesMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__GenoStruTrait[] = {  {&_swigt__p_simuPOP__Population, _p_simuPOP__PopulationTo_p_simuPOP__GenoStruTrait, 0, 0},  {&_swigt__p_simuPOP__Pedigree, _p_simuPOP__PedigreeTo_p_simuPOP__GenoStruTrait, 0, 0},  {&_swigt__p_simuPOP__GenoStruTrait, 0, 0, 0},  {&_swigt__p_simuPOP__Individual, _p_simuPOP__IndividualTo_p_simuPOP__GenoStruTrait, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__GenoTransmitter[] = {  {&_swigt__p_simuPOP__Recombinator, _p_simuPOP__RecombinatorTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__MutSpaceRecombinator, _p_simuPOP__MutSpaceRecombinatorTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__GenoTransmitter, 0, 0, 0},  {&_swigt__p_simuPOP__CloneGenoTransmitter, _p_simuPOP__CloneGenoTransmitterTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__MendelianGenoTransmitter, _p_simuPOP__MendelianGenoTransmitterTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__SelfingGenoTransmitter, _p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__HaplodiploidGenoTransmitter, _p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__GenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__MitochondrialGenoTransmitter, _p_simuPOP__MitochondrialGenoTransmitterTo_p_simuPOP__GenoTransmitter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__GenotypeSplitter[] = {  {&_swigt__p_simuPOP__GenotypeSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__HaplodiploidGenoTransmitter[] = {  {&_swigt__p_simuPOP__HaplodiploidGenoTransmitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__HeteroMating[] = {  {&_swigt__p_simuPOP__HeteroMating, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__HomoMating[] = {  {&_swigt__p_simuPOP__HomoMating, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__IdTagger[] = {  {&_swigt__p_simuPOP__IdTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__IfElse[] = {  {&_swigt__p_simuPOP__IfElse, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__IndexError[] = {  {&_swigt__p_simuPOP__IndexError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Individual[] = {  {&_swigt__p_simuPOP__Individual, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t[] = {  {&_swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t[] = {  {&_swigt__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InfoEval[] = {  {&_swigt__p_simuPOP__InfoExec, _p_simuPOP__InfoExecTo_p_simuPOP__InfoEval, 0, 0},  {&_swigt__p_simuPOP__InfoEval, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InfoExec[] = {  {&_swigt__p_simuPOP__InfoExec, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InfoSplitter[] = {  {&_swigt__p_simuPOP__InfoSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t[] = {  {&_swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t[] = {  {&_swigt__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InheritTagger[] = {  {&_swigt__p_simuPOP__InheritTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InitGenotype[] = {  {&_swigt__p_simuPOP__InitGenotype, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InitInfo[] = {  {&_swigt__p_simuPOP__InitInfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InitLineage[] = {  {&_swigt__p_simuPOP__InitLineage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__InitSex[] = {  {&_swigt__p_simuPOP__InitSex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__KAlleleMutator[] = {  {&_swigt__p_simuPOP__KAlleleMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MaPenetrance[] = {  {&_swigt__p_simuPOP__MaPenetrance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MaSelector[] = {  {&_swigt__p_simuPOP__MaSelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MapPenetrance[] = {  {&_swigt__p_simuPOP__MapPenetrance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MapSelector[] = {  {&_swigt__p_simuPOP__MapSelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MatingScheme[] = {  {&_swigt__p_simuPOP__ConditionalMating, _p_simuPOP__ConditionalMatingTo_p_simuPOP__MatingScheme, 0, 0},  {&_swigt__p_simuPOP__HomoMating, _p_simuPOP__HomoMatingTo_p_simuPOP__MatingScheme, 0, 0},  {&_swigt__p_simuPOP__PedigreeMating, _p_simuPOP__PedigreeMatingTo_p_simuPOP__MatingScheme, 0, 0},  {&_swigt__p_simuPOP__HeteroMating, _p_simuPOP__HeteroMatingTo_p_simuPOP__MatingScheme, 0, 0},  {&_swigt__p_simuPOP__MatingScheme, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MatrixMutator[] = {  {&_swigt__p_simuPOP__MatrixMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MendelianGenoTransmitter[] = {  {&_swigt__p_simuPOP__MendelianGenoTransmitter, 0, 0, 0},  {&_swigt__p_simuPOP__SelfingGenoTransmitter, _p_simuPOP__SelfingGenoTransmitterTo_p_simuPOP__MendelianGenoTransmitter, 0, 0},  {&_swigt__p_simuPOP__HaplodiploidGenoTransmitter, _p_simuPOP__HaplodiploidGenoTransmitterTo_p_simuPOP__MendelianGenoTransmitter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MergeSubPops[] = {  {&_swigt__p_simuPOP__MergeSubPops, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Migrator[] = {  {&_swigt__p_simuPOP__Migrator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MitochondrialGenoTransmitter[] = {  {&_swigt__p_simuPOP__MitochondrialGenoTransmitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MixedMutator[] = {  {&_swigt__p_simuPOP__MixedMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MlPenetrance[] = {  {&_swigt__p_simuPOP__MlPenetrance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MlSelector[] = {  {&_swigt__p_simuPOP__MlSelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MutSpaceMutator[] = {  {&_swigt__p_simuPOP__MutSpaceMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MutSpaceRecombinator[] = {  {&_swigt__p_simuPOP__MutSpaceRecombinator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MutSpaceRevertFixedSites[] = {  {&_swigt__p_simuPOP__MutSpaceRevertFixedSites, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__MutSpaceSelector[] = {  {&_swigt__p_simuPOP__MutSpaceSelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__NoneOp[] = {  {&_swigt__p_simuPOP__NoneOp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ConstNumOffModel[] = {{&_swigt__p_simuPOP__ConstNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__GeometricNumOffModel[] = {{&_swigt__p_simuPOP__GeometricNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PoissonNumOffModel[] = {{&_swigt__p_simuPOP__PoissonNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__BinomialNumOffModel[] = {{&_swigt__p_simuPOP__BinomialNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__UniformNumOffModel[] = {{&_swigt__p_simuPOP__UniformNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__FuncNumOffModel[] = {{&_swigt__p_simuPOP__FuncNumOffModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__NumOffModel[] = {  {&_swigt__p_simuPOP__NumOffModel, 0, 0, 0},  {&_swigt__p_simuPOP__ConstNumOffModel, _p_simuPOP__ConstNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},  {&_swigt__p_simuPOP__GeometricNumOffModel, _p_simuPOP__GeometricNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},  {&_swigt__p_simuPOP__PoissonNumOffModel, _p_simuPOP__PoissonNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},  {&_swigt__p_simuPOP__BinomialNumOffModel, _p_simuPOP__BinomialNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},  {&_swigt__p_simuPOP__UniformNumOffModel, _p_simuPOP__UniformNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},  {&_swigt__p_simuPOP__FuncNumOffModel, _p_simuPOP__FuncNumOffModelTo_p_simuPOP__NumOffModel, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__OffspringGenerator[] = {  {&_swigt__p_simuPOP__OffspringGenerator, 0, 0, 0},  {&_swigt__p_simuPOP__ControlledOffspringGenerator, _p_simuPOP__ControlledOffspringGeneratorTo_p_simuPOP__OffspringGenerator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__OffspringTagger[] = {  {&_swigt__p_simuPOP__OffspringTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ParentChooser[] = {  {&_swigt__p_simuPOP__ParentChooser, 0, 0, 0},  {&_swigt__p_simuPOP__SequentialParentChooser, _p_simuPOP__SequentialParentChooserTo_p_simuPOP__ParentChooser, 0, 0},  {&_swigt__p_simuPOP__RandomParentChooser, _p_simuPOP__RandomParentChooserTo_p_simuPOP__ParentChooser, 0, 0},  {&_swigt__p_simuPOP__RandomParentsChooser, _p_simuPOP__RandomParentsChooserTo_p_simuPOP__ParentChooser, 0, 0},  {&_swigt__p_simuPOP__PolyParentsChooser, _p_simuPOP__PolyParentsChooserTo_p_simuPOP__ParentChooser, 0, 0},  {&_swigt__p_simuPOP__CombinedParentsChooser, _p_simuPOP__CombinedParentsChooserTo_p_simuPOP__ParentChooser, 0, 0},  {&_swigt__p_simuPOP__PyParentsChooser, _p_simuPOP__PyParentsChooserTo_p_simuPOP__ParentChooser, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ParentsTagger[] = {  {&_swigt__p_simuPOP__ParentsTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Pause[] = {  {&_swigt__p_simuPOP__Pause, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Pedigree[] = {  {&_swigt__p_simuPOP__Pedigree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PedigreeMating[] = {  {&_swigt__p_simuPOP__PedigreeMating, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PedigreeTagger[] = {  {&_swigt__p_simuPOP__PedigreeTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PointMutator[] = {  {&_swigt__p_simuPOP__PointMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PolyParentsChooser[] = {  {&_swigt__p_simuPOP__PolyParentsChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Population[] = {  {&_swigt__p_simuPOP__Population, 0, 0, 0},  {&_swigt__p_simuPOP__Pedigree, _p_simuPOP__PedigreeTo_p_simuPOP__Population, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ProductSplitter[] = {  {&_swigt__p_simuPOP__ProductSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ProportionSplitter[] = {  {&_swigt__p_simuPOP__ProportionSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyEval[] = {  {&_swigt__p_simuPOP__PyEval, 0, 0, 0},  {&_swigt__p_simuPOP__PyExec, _p_simuPOP__PyExecTo_p_simuPOP__PyEval, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyExec[] = {  {&_swigt__p_simuPOP__PyExec, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyMlPenetrance[] = {  {&_swigt__p_simuPOP__PyMlPenetrance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyMlSelector[] = {  {&_swigt__p_simuPOP__PyMlSelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyMutator[] = {  {&_swigt__p_simuPOP__PyMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyOperator[] = {  {&_swigt__p_simuPOP__PyOperator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyOutput[] = {  {&_swigt__p_simuPOP__PyOutput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyParentsChooser[] = {  {&_swigt__p_simuPOP__PyParentsChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyPenetrance[] = {  {&_swigt__p_simuPOP__PyPenetrance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyQuanTrait[] = {  {&_swigt__p_simuPOP__PyQuanTrait, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PySelector[] = {  {&_swigt__p_simuPOP__PySelector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__PyTagger[] = {  {&_swigt__p_simuPOP__PyTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RNG[] = {  {&_swigt__p_simuPOP__RNG, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RNG_func[] = {  {&_swigt__p_simuPOP__RNG_func, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RandomParentChooser[] = {  {&_swigt__p_simuPOP__RandomParentChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RandomParentsChooser[] = {  {&_swigt__p_simuPOP__RandomParentsChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RangeSplitter[] = {  {&_swigt__p_simuPOP__RangeSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Recombinator[] = {  {&_swigt__p_simuPOP__Recombinator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ResizeSubPops[] = {  {&_swigt__p_simuPOP__ResizeSubPops, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RevertEvolution[] = {  {&_swigt__p_simuPOP__RevertEvolution, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RevertFixedSites[] = {  {&_swigt__p_simuPOP__RevertFixedSites, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RevertIf[] = {  {&_swigt__p_simuPOP__RevertIf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RuntimeError[] = {  {&_swigt__p_simuPOP__RuntimeError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SavePopulation[] = {  {&_swigt__p_simuPOP__SavePopulation, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SelfingGenoTransmitter[] = {  {&_swigt__p_simuPOP__SelfingGenoTransmitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SequentialParentChooser[] = {  {&_swigt__p_simuPOP__SequentialParentChooser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__NoSexModel[] = {{&_swigt__p_simuPOP__NoSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__RandomSexModel[] = {{&_swigt__p_simuPOP__RandomSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ProbOfMalesSexModel[] = {{&_swigt__p_simuPOP__ProbOfMalesSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__NumOfMalesSexModel[] = {{&_swigt__p_simuPOP__NumOfMalesSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__NumOfFemalesSexModel[] = {{&_swigt__p_simuPOP__NumOfFemalesSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SeqSexModel[] = {{&_swigt__p_simuPOP__SeqSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__GlobalSeqSexModel[] = {{&_swigt__p_simuPOP__GlobalSeqSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__FuncSexModel[] = {{&_swigt__p_simuPOP__FuncSexModel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SexModel[] = {  {&_swigt__p_simuPOP__SexModel, 0, 0, 0},  {&_swigt__p_simuPOP__NoSexModel, _p_simuPOP__NoSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__RandomSexModel, _p_simuPOP__RandomSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__ProbOfMalesSexModel, _p_simuPOP__ProbOfMalesSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__NumOfMalesSexModel, _p_simuPOP__NumOfMalesSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__NumOfFemalesSexModel, _p_simuPOP__NumOfFemalesSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__SeqSexModel, _p_simuPOP__SeqSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__GlobalSeqSexModel, _p_simuPOP__GlobalSeqSexModelTo_p_simuPOP__SexModel, 0, 0},  {&_swigt__p_simuPOP__FuncSexModel, _p_simuPOP__FuncSexModelTo_p_simuPOP__SexModel, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SexSplitter[] = {  {&_swigt__p_simuPOP__SexSplitter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Simulator[] = {  {&_swigt__p_simuPOP__Simulator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SplitSubPops[] = {  {&_swigt__p_simuPOP__SplitSubPops, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__Stat[] = {  {&_swigt__p_simuPOP__Stat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__StepwiseMutator[] = {  {&_swigt__p_simuPOP__StepwiseMutator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__StopEvolution[] = {  {&_swigt__p_simuPOP__StopEvolution, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__StopIteration[] = {  {&_swigt__p_simuPOP__StopIteration, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SummaryTagger[] = {  {&_swigt__p_simuPOP__SummaryTagger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__SystemError[] = {  {&_swigt__p_simuPOP__SystemError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__TerminateIf[] = {  {&_swigt__p_simuPOP__TerminateIf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__TicToc[] = {  {&_swigt__p_simuPOP__TicToc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__ValueError[] = {  {&_swigt__p_simuPOP__ValueError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__WeightedSampler[] = {  {&_swigt__p_simuPOP__WeightedSampler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__floatList[] = {  {&_swigt__p_simuPOP__floatListFunc, _p_simuPOP__floatListFuncTo_p_simuPOP__floatList, 0, 0},  {&_swigt__p_simuPOP__floatList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__floatListFunc[] = {  {&_swigt__p_simuPOP__floatListFunc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__floatMatrix[] = {  {&_swigt__p_simuPOP__floatMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__intList[] = {  {&_swigt__p_simuPOP__intList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__intMatrix[] = {  {&_swigt__p_simuPOP__intMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__lociList[] = {  {&_swigt__p_simuPOP__lociList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__opList[] = {  {&_swigt__p_simuPOP__opList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__pyIndIterator[] = {  {&_swigt__p_simuPOP__pyIndIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__pyMutantIterator[] = {  {&_swigt__p_simuPOP__pyMutantIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__pyPopIterator[] = {  {&_swigt__p_simuPOP__pyPopIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__stringFunc[] = {  {&_swigt__p_simuPOP__stringFunc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__stringList[] = {  {&_swigt__p_simuPOP__stringList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__stringMatrix[] = {  {&_swigt__p_simuPOP__stringMatrix, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__subPopList[] = {  {&_swigt__p_simuPOP__subPopList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__uintList[] = {  {&_swigt__p_simuPOP__uintListFunc, _p_simuPOP__uintListFuncTo_p_simuPOP__uintList, 0, 0},  {&_swigt__p_simuPOP__uintList, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__uintListFunc[] = {  {&_swigt__p_simuPOP__uintListFunc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__uintString[] = {  {&_swigt__p_simuPOP__uintString, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__vspFunctor[] = {  {&_swigt__p_simuPOP__vspFunctor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simuPOP__vspID[] = {  {&_swigt__p_simuPOP__vspID, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_t[] = {  {&_swigt__p_size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t[] = {  {&_swigt__p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t[] = {  {&_swigt__p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t[] = {  {&_swigt__p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_size_t_size_t_t[] = {  {&_swigt__p_std__pairT_size_t_size_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__string_double_t[] = {  {&_swigt__p_std__pairT_std__string_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__iterator[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_long_std__allocatorT_long_t_t[] = {  {&_swigt__p_std__vectorT_long_std__allocatorT_long_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator[] = {  {&_swigt__p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_long_std__allocatorT_long_t_t__iterator[] = {  {&_swigt__p_std__vectorT_long_std__allocatorT_long_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t[] = {  {&_swigt__p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t[] = {  {&_swigt__p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t[] = {  {&_swigt__p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_size_t_std__allocatorT_size_t_t_t[] = {  {&_swigt__p_std__vectorT_size_t_std__allocatorT_size_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t[] = {  {&_swigt__p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t[] = {  {&_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t[] = {  {&_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator[] = {  {&_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator[] = {  {&_swigt__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__SwigPyIterator[] = {  {&_swigt__p_swig__SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_bool_std__allocatorT_bool_t_t[] = {  {&_swigt__p_vectorT_bool_std__allocatorT_bool_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference[] = {  {&_swigt__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator[] = {  {&_swigt__p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vectorvsp[] = {  {&_swigt__p_vectorvsp, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_IndividualPair,
  _swigc__p_LocGenotype,
  _swigc__p_SelCoef,
  _swigc__p_allocator_type,
  _swigc__p_bool,
  _swigc__p_char,
  _swigc__p_const_iterator,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_first_type,
  _swigc__p_gsl_rng,
  _swigc__p_int,
  _swigc__p_iterator,
  _swigc__p_key_type,
  _swigc__p_long,
  _swigc__p_long_long,
  _swigc__p_mapped_type,
  _swigc__p_ostream,
  _swigc__p_reference,
  _swigc__p_second_type,
  _swigc__p_short,
  _swigc__p_signed_char,
  _swigc__p_simuPOP__AffectionSplitter,
  _swigc__p_simuPOP__BackwardMigrator,
  _swigc__p_simuPOP__BaseMutator,
  _swigc__p_simuPOP__BaseOperator,
  _swigc__p_simuPOP__BasePenetrance,
  _swigc__p_simuPOP__BaseQuanTrait,
  _swigc__p_simuPOP__BaseSelector,
  _swigc__p_simuPOP__BaseVspSplitter,
  _swigc__p_simuPOP__Bernullitrials,
  _swigc__p_simuPOP__Bernullitrials_T,
  _swigc__p_simuPOP__BinomialNumOffModel,
  _swigc__p_simuPOP__CloneGenoTransmitter,
  _swigc__p_simuPOP__CombinedAlleleIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator_unsigned_long_const_R_t,
  _swigc__p_simuPOP__CombinedParentsChooser,
  _swigc__p_simuPOP__CombinedSplitter,
  _swigc__p_simuPOP__ConditionalMating,
  _swigc__p_simuPOP__ConstNumOffModel,
  _swigc__p_simuPOP__ContextMutator,
  _swigc__p_simuPOP__ControlledOffspringGenerator,
  _swigc__p_simuPOP__DiscardIf,
  _swigc__p_simuPOP__Dumper,
  _swigc__p_simuPOP__Exception,
  _swigc__p_simuPOP__FiniteSitesMutator,
  _swigc__p_simuPOP__FuncNumOffModel,
  _swigc__p_simuPOP__FuncSexModel,
  _swigc__p_simuPOP__GenoStruTrait,
  _swigc__p_simuPOP__GenoTransmitter,
  _swigc__p_simuPOP__GenotypeSplitter,
  _swigc__p_simuPOP__GeometricNumOffModel,
  _swigc__p_simuPOP__GlobalSeqSexModel,
  _swigc__p_simuPOP__HaplodiploidGenoTransmitter,
  _swigc__p_simuPOP__HeteroMating,
  _swigc__p_simuPOP__HomoMating,
  _swigc__p_simuPOP__IdTagger,
  _swigc__p_simuPOP__IfElse,
  _swigc__p_simuPOP__IndexError,
  _swigc__p_simuPOP__Individual,
  _swigc__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference_t,
  _swigc__p_simuPOP__IndividualIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference_t,
  _swigc__p_simuPOP__InfoEval,
  _swigc__p_simuPOP__InfoExec,
  _swigc__p_simuPOP__InfoSplitter,
  _swigc__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator_t,
  _swigc__p_simuPOP__InformationIteratorT_std__vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator_t,
  _swigc__p_simuPOP__InheritTagger,
  _swigc__p_simuPOP__InitGenotype,
  _swigc__p_simuPOP__InitInfo,
  _swigc__p_simuPOP__InitLineage,
  _swigc__p_simuPOP__InitSex,
  _swigc__p_simuPOP__KAlleleMutator,
  _swigc__p_simuPOP__MaPenetrance,
  _swigc__p_simuPOP__MaSelector,
  _swigc__p_simuPOP__MapPenetrance,
  _swigc__p_simuPOP__MapSelector,
  _swigc__p_simuPOP__MatingScheme,
  _swigc__p_simuPOP__MatrixMutator,
  _swigc__p_simuPOP__MendelianGenoTransmitter,
  _swigc__p_simuPOP__MergeSubPops,
  _swigc__p_simuPOP__Migrator,
  _swigc__p_simuPOP__MitochondrialGenoTransmitter,
  _swigc__p_simuPOP__MixedMutator,
  _swigc__p_simuPOP__MlPenetrance,
  _swigc__p_simuPOP__MlSelector,
  _swigc__p_simuPOP__MutSpaceMutator,
  _swigc__p_simuPOP__MutSpaceRecombinator,
  _swigc__p_simuPOP__MutSpaceRevertFixedSites,
  _swigc__p_simuPOP__MutSpaceSelector,
  _swigc__p_simuPOP__NoSexModel,
  _swigc__p_simuPOP__NoneOp,
  _swigc__p_simuPOP__NumOfFemalesSexModel,
  _swigc__p_simuPOP__NumOfMalesSexModel,
  _swigc__p_simuPOP__NumOffModel,
  _swigc__p_simuPOP__OffspringGenerator,
  _swigc__p_simuPOP__OffspringTagger,
  _swigc__p_simuPOP__ParentChooser,
  _swigc__p_simuPOP__ParentsTagger,
  _swigc__p_simuPOP__Pause,
  _swigc__p_simuPOP__Pedigree,
  _swigc__p_simuPOP__PedigreeMating,
  _swigc__p_simuPOP__PedigreeTagger,
  _swigc__p_simuPOP__PointMutator,
  _swigc__p_simuPOP__PoissonNumOffModel,
  _swigc__p_simuPOP__PolyParentsChooser,
  _swigc__p_simuPOP__Population,
  _swigc__p_simuPOP__ProbOfMalesSexModel,
  _swigc__p_simuPOP__ProductSplitter,
  _swigc__p_simuPOP__ProportionSplitter,
  _swigc__p_simuPOP__PyEval,
  _swigc__p_simuPOP__PyExec,
  _swigc__p_simuPOP__PyMlPenetrance,
  _swigc__p_simuPOP__PyMlSelector,
  _swigc__p_simuPOP__PyMutator,
  _swigc__p_simuPOP__PyOperator,
  _swigc__p_simuPOP__PyOutput,
  _swigc__p_simuPOP__PyParentsChooser,
  _swigc__p_simuPOP__PyPenetrance,
  _swigc__p_simuPOP__PyQuanTrait,
  _swigc__p_simuPOP__PySelector,
  _swigc__p_simuPOP__PyTagger,
  _swigc__p_simuPOP__RNG,
  _swigc__p_simuPOP__RNG_func,
  _swigc__p_simuPOP__RandomParentChooser,
  _swigc__p_simuPOP__RandomParentsChooser,
  _swigc__p_simuPOP__RandomSexModel,
  _swigc__p_simuPOP__RangeSplitter,
  _swigc__p_simuPOP__Recombinator,
  _swigc__p_simuPOP__ResizeSubPops,
  _swigc__p_simuPOP__RevertEvolution,
  _swigc__p_simuPOP__RevertFixedSites,
  _swigc__p_simuPOP__RevertIf,
  _swigc__p_simuPOP__RuntimeError,
  _swigc__p_simuPOP__SavePopulation,
  _swigc__p_simuPOP__SelfingGenoTransmitter,
  _swigc__p_simuPOP__SeqSexModel,
  _swigc__p_simuPOP__SequentialParentChooser,
  _swigc__p_simuPOP__SexModel,
  _swigc__p_simuPOP__SexSplitter,
  _swigc__p_simuPOP__Simulator,
  _swigc__p_simuPOP__SplitSubPops,
  _swigc__p_simuPOP__Stat,
  _swigc__p_simuPOP__StepwiseMutator,
  _swigc__p_simuPOP__StopEvolution,
  _swigc__p_simuPOP__StopIteration,
  _swigc__p_simuPOP__SummaryTagger,
  _swigc__p_simuPOP__SystemError,
  _swigc__p_simuPOP__TerminateIf,
  _swigc__p_simuPOP__TicToc,
  _swigc__p_simuPOP__UniformNumOffModel,
  _swigc__p_simuPOP__ValueError,
  _swigc__p_simuPOP__WeightedSampler,
  _swigc__p_simuPOP__floatList,
  _swigc__p_simuPOP__floatListFunc,
  _swigc__p_simuPOP__floatMatrix,
  _swigc__p_simuPOP__intList,
  _swigc__p_simuPOP__intMatrix,
  _swigc__p_simuPOP__lociList,
  _swigc__p_simuPOP__opList,
  _swigc__p_simuPOP__pyIndIterator,
  _swigc__p_simuPOP__pyMutantIterator,
  _swigc__p_simuPOP__pyPopIterator,
  _swigc__p_simuPOP__stringFunc,
  _swigc__p_simuPOP__stringList,
  _swigc__p_simuPOP__stringMatrix,
  _swigc__p_simuPOP__subPopList,
  _swigc__p_simuPOP__uintList,
  _swigc__p_simuPOP__uintListFunc,
  _swigc__p_simuPOP__uintString,
  _swigc__p_simuPOP__vspFunctor,
  _swigc__p_simuPOP__vspID,
  _swigc__p_size_t,
  _swigc__p_size_type,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__mapT_int_double_std__lessT_int_t_std__allocatorT_std__pairT_int_const_double_t_t_t,
  _swigc__p_std__mapT_size_t_double_std__lessT_size_t_t_std__allocatorT_std__pairT_size_t_const_double_t_t_t,
  _swigc__p_std__mapT_std__string_double_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_double_t_t_t,
  _swigc__p_std__mapT_std__vectorT_long_std__allocatorT_long_t_t_double_std__lessT_std__vectorT_long_t_t_std__allocatorT_std__pairT_std__vectorT_long_std__allocatorT_long_t_t_const_double_t_t_t,
  _swigc__p_std__pairT_size_t_size_t_t,
  _swigc__p_std__pairT_std__string_double_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__const_iterator,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__iterator,
  _swigc__p_std__vectorT_long_std__allocatorT_long_t_t,
  _swigc__p_std__vectorT_long_std__allocatorT_long_t_t__const_iterator,
  _swigc__p_std__vectorT_long_std__allocatorT_long_t_t__iterator,
  _swigc__p_std__vectorT_simuPOP__BaseOperator_p_std__allocatorT_simuPOP__BaseOperator_p_t_t,
  _swigc__p_std__vectorT_simuPOP__BaseVspSplitter_p_std__allocatorT_simuPOP__BaseVspSplitter_p_t_t,
  _swigc__p_std__vectorT_simuPOP__HomoMating_p_std__allocatorT_simuPOP__HomoMating_p_t_t,
  _swigc__p_std__vectorT_size_t_std__allocatorT_size_t_t_t,
  _swigc__p_std__vectorT_std__pairT_size_t_size_t_t_std__allocatorT_std__pairT_size_t_size_t_t_t_t,
  _swigc__p_std__vectorT_std__pairT_std__string_double_t_std__allocatorT_std__pairT_std__string_double_t_t_t,
  _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  _swigc__p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_long_std__allocatorT_long_t_t_std__allocatorT_std__vectorT_long_std__allocatorT_long_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t,
  _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t,
  _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__const_iterator,
  _swigc__p_std__vectorT_unsigned_long_std__allocatorT_unsigned_long_t_t__iterator,
  _swigc__p_swig__SwigPyIterator,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
  _swigc__p_value_type,
  _swigc__p_vectorT_bool_std__allocatorT_bool_t_t,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_iterator,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_pointer,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__const_reference,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__iterator,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__pointer,
  _swigc__p_vectorT_simuPOP__Individual_std__allocatorT_simuPOP__Individual_t_t__reference,
  _swigc__p_vectorT_simuPOP__Population_p_std__allocatorT_simuPOP__Population_p_t_t__iterator,
  _swigc__p_vectorvsp,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        (char *)"swigvarlink",              /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        (printfunc) swig_varlink_print,     /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
        0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
        0,                                  /* tp_prev */
#endif
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
#if PY_VERSION_HEX < 0x02020000
      varlink_type.ob_type = &PyType_Type;
#else
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  SWIG_Python_SetConstant(d, "HAVE_INLINE",SWIG_From_int(static_cast< int >(1)));
  PyDict_SetItemString(md,(char *)"cvar", SWIG_globals());
  SWIG_addvarlink(SWIG_globals(),(char *)"MISSING_VALUE",Swig_var_MISSING_VALUE_get, Swig_var_MISSING_VALUE_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"NOT_FOUND",Swig_var_NOT_FOUND_get, Swig_var_NOT_FOUND_set);
  SWIG_Python_SetConstant(d, "TR1_SUPPORT",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "THREAFPRIVATE_SUPPORT",SWIG_From_int(static_cast< int >(0)));
  SWIG_Python_SetConstant(d, "SIZE_T_FORMAT",SWIG_FromCharPtr("%zu"));
  SWIG_addvarlink(SWIG_globals(),(char *)"ModuleMaxAllele",Swig_var_ModuleMaxAllele_get, Swig_var_ModuleMaxAllele_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"MaxRandomNumber",Swig_var_MaxRandomNumber_get, Swig_var_MaxRandomNumber_set);
  SWIG_Python_SetConstant(d, "OpSWIGType",SWIG_FromCharPtr("simuPOP::BaseOperator *"));
  SWIG_Python_SetConstant(d, "MALE",SWIG_From_int(static_cast< int >(MALE)));
  SWIG_Python_SetConstant(d, "FEMALE",SWIG_From_int(static_cast< int >(FEMALE)));
  SWIG_Python_SetConstant(d, "CUSTOMIZED",SWIG_From_int(static_cast< int >(CUSTOMIZED)));
  SWIG_Python_SetConstant(d, "AUTOSOME",SWIG_From_int(static_cast< int >(AUTOSOME)));
  SWIG_Python_SetConstant(d, "CHROMOSOME_X",SWIG_From_int(static_cast< int >(CHROMOSOME_X)));
  SWIG_Python_SetConstant(d, "CHROMOSOME_Y",SWIG_From_int(static_cast< int >(CHROMOSOME_Y)));
  SWIG_Python_SetConstant(d, "MITOCHONDRIAL",SWIG_From_int(static_cast< int >(MITOCHONDRIAL)));
  SWIG_Python_SetConstant(d, "CONSTANT",SWIG_From_int(static_cast< int >(CONSTANT)));
  SWIG_Python_SetConstant(d, "BINOMIAL_DISTRIBUTION",SWIG_From_int(static_cast< int >(BINOMIAL_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "EXPONENTIAL_DISTRIBUTION",SWIG_From_int(static_cast< int >(EXPONENTIAL_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "GEOMETRIC_DISTRIBUTION",SWIG_From_int(static_cast< int >(GEOMETRIC_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "POISSON_DISTRIBUTION",SWIG_From_int(static_cast< int >(POISSON_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "UNIFORM_DISTRIBUTION",SWIG_From_int(static_cast< int >(UNIFORM_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "NORMAL_DISTRIBUTION",SWIG_From_int(static_cast< int >(NORMAL_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "GAMMA_DISTRIBUTION",SWIG_From_int(static_cast< int >(GAMMA_DISTRIBUTION)));
  SWIG_Python_SetConstant(d, "NO_SEX",SWIG_From_int(static_cast< int >(NO_SEX)));
  SWIG_Python_SetConstant(d, "RANDOM_SEX",SWIG_From_int(static_cast< int >(RANDOM_SEX)));
  SWIG_Python_SetConstant(d, "PROB_OF_MALES",SWIG_From_int(static_cast< int >(PROB_OF_MALES)));
  SWIG_Python_SetConstant(d, "NUM_OF_MALES",SWIG_From_int(static_cast< int >(NUM_OF_MALES)));
  SWIG_Python_SetConstant(d, "NUM_OF_FEMALES",SWIG_From_int(static_cast< int >(NUM_OF_FEMALES)));
  SWIG_Python_SetConstant(d, "SEQUENCE_OF_SEX",SWIG_From_int(static_cast< int >(SEQUENCE_OF_SEX)));
  SWIG_Python_SetConstant(d, "GLOBAL_SEQUENCE_OF_SEX",SWIG_From_int(static_cast< int >(GLOBAL_SEQUENCE_OF_SEX)));
  SWIG_Python_SetConstant(d, "NO_CONVERSION",SWIG_From_int(static_cast< int >(NO_CONVERSION)));
  SWIG_Python_SetConstant(d, "NUM_MARKERS",SWIG_From_int(static_cast< int >(NUM_MARKERS)));
  SWIG_Python_SetConstant(d, "TRACT_LENGTH",SWIG_From_int(static_cast< int >(TRACT_LENGTH)));
  SWIG_Python_SetConstant(d, "OFFSPRING",SWIG_From_int(static_cast< int >(OFFSPRING)));
  SWIG_Python_SetConstant(d, "COMMON_OFFSPRING",SWIG_From_int(static_cast< int >(COMMON_OFFSPRING)));
  SWIG_Python_SetConstant(d, "SPOUSE",SWIG_From_int(static_cast< int >(SPOUSE)));
  SWIG_Python_SetConstant(d, "OUTBRED_SPOUSE",SWIG_From_int(static_cast< int >(OUTBRED_SPOUSE)));
  SWIG_Python_SetConstant(d, "SIBLING",SWIG_From_int(static_cast< int >(SIBLING)));
  SWIG_Python_SetConstant(d, "FULLSIBLING",SWIG_From_int(static_cast< int >(FULLSIBLING)));
  SWIG_Python_SetConstant(d, "ANY_SEX",SWIG_From_int(static_cast< int >(ANY_SEX)));
  SWIG_Python_SetConstant(d, "MALE_ONLY",SWIG_From_int(static_cast< int >(MALE_ONLY)));
  SWIG_Python_SetConstant(d, "FEMALE_ONLY",SWIG_From_int(static_cast< int >(FEMALE_ONLY)));
  SWIG_Python_SetConstant(d, "SAME_SEX",SWIG_From_int(static_cast< int >(SAME_SEX)));
  SWIG_Python_SetConstant(d, "OPPOSITE_SEX",SWIG_From_int(static_cast< int >(OPPOSITE_SEX)));
  SWIG_Python_SetConstant(d, "PAIR_ONLY",SWIG_From_int(static_cast< int >(PAIR_ONLY)));
  SWIG_Python_SetConstant(d, "UNAFFECTED",SWIG_From_int(static_cast< int >(UNAFFECTED)));
  SWIG_Python_SetConstant(d, "AFFECTED",SWIG_From_int(static_cast< int >(AFFECTED)));
  SWIG_Python_SetConstant(d, "ANY_AFFECTION_STATUS",SWIG_From_int(static_cast< int >(ANY_AFFECTION_STATUS)));
  SWIG_Python_SetConstant(d, "MULTIPLICATIVE",SWIG_From_int(static_cast< int >(MULTIPLICATIVE)));
  SWIG_Python_SetConstant(d, "ADDITIVE",SWIG_From_int(static_cast< int >(ADDITIVE)));
  SWIG_Python_SetConstant(d, "HETEROGENEITY",SWIG_From_int(static_cast< int >(HETEROGENEITY)));
  SWIG_Python_SetConstant(d, "EXPONENTIAL",SWIG_From_int(static_cast< int >(EXPONENTIAL)));
  SWIG_Python_SetConstant(d, "BY_IND_INFO",SWIG_From_int(static_cast< int >(BY_IND_INFO)));
  SWIG_Python_SetConstant(d, "BY_PROBABILITY",SWIG_From_int(static_cast< int >(BY_PROBABILITY)));
  SWIG_Python_SetConstant(d, "BY_PROPORTION",SWIG_From_int(static_cast< int >(BY_PROPORTION)));
  SWIG_Python_SetConstant(d, "BY_COUNTS",SWIG_From_int(static_cast< int >(BY_COUNTS)));
  SWIG_Python_SetConstant(d, "PATERNAL",SWIG_From_int(static_cast< int >(PATERNAL)));
  SWIG_Python_SetConstant(d, "MATERNAL",SWIG_From_int(static_cast< int >(MATERNAL)));
  SWIG_Python_SetConstant(d, "MEAN",SWIG_From_int(static_cast< int >(MEAN)));
  SWIG_Python_SetConstant(d, "MAXIMUM",SWIG_From_int(static_cast< int >(MAXIMUM)));
  SWIG_Python_SetConstant(d, "MINIMUM",SWIG_From_int(static_cast< int >(MINIMUM)));
  SWIG_Python_SetConstant(d, "SUMMATION",SWIG_From_int(static_cast< int >(SUMMATION)));
  SWIG_Python_SetConstant(d, "MULTIPLICATION",SWIG_From_int(static_cast< int >(MULTIPLICATION)));
  SWIG_Python_SetConstant(d, "PER_ALLELE",SWIG_From_int(static_cast< int >(PER_ALLELE)));
  SWIG_Python_SetConstant(d, "PER_LOCI",SWIG_From_int(static_cast< int >(PER_LOCI)));
  SWIG_Python_SetConstant(d, "PER_CHROMOSOME",SWIG_From_int(static_cast< int >(PER_CHROMOSOME)));
  SWIG_Python_SetConstant(d, "PER_PLOIDY",SWIG_From_int(static_cast< int >(PER_PLOIDY)));
  SWIG_Python_SetConstant(d, "PER_INDIVIDUAL",SWIG_From_int(static_cast< int >(PER_INDIVIDUAL)));
  SWIG_Python_SetConstant(d, "FROM_INFO",SWIG_From_int(static_cast< int >(FROM_INFO)));
  SWIG_Python_SetConstant(d, "FROM_INFO_SIGNED",SWIG_From_int(static_cast< int >(FROM_INFO_SIGNED)));
  SWIG_Python_SetConstant(d, "DBG_WARNING",SWIG_From_int(static_cast< int >(DBG_WARNING)));
  SWIG_addvarlink(SWIG_globals(),(char *)"MaxTraitIndex",Swig_var_MaxTraitIndex_get, Swig_var_MaxTraitIndex_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"InvalidValue",Swig_var_InvalidValue_get, Swig_var_InvalidValue_set);
  SWIG_addvarlink(SWIG_globals(),(char *)"MaxIndexSize",Swig_var_MaxIndexSize_get, Swig_var_MaxIndexSize_set);
  SWIG_Python_SetConstant(d, "UnnamedSubPop",SWIG_FromCharPtr(""));
  SWIG_Python_SetConstant(d, "cmp_epsilon",SWIG_From_double(static_cast< double >((1.e-9))));
  
  simuPOP::initialize(m);
  
  SWIG_Python_SetConstant(d, "Bernullitrials_npos",SWIG_From_size_t(static_cast< size_t >(simuPOP::Bernullitrials::npos)));
  SWIG_Python_SetConstant(d, "Bernullitrials_T_npos",SWIG_From_size_t(static_cast< size_t >(simuPOP::Bernullitrials_T::npos)));
  SWIG_Python_SetConstant(d, "HAPLODIPLOID",SWIG_From_double(static_cast< double >(2.5)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

